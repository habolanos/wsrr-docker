<?xml version="1.0" encoding="euc-kr"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="ko-KR" xml:lang="ko-kr">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=euc-kr" />
<meta name="dc.language" scheme="rfc1766" content="ko-kr" />
<meta name="dc.date" scheme="iso8601" content="2007-09-21" />
<meta name="copyright" content="(C) Copyright IBM Corp. 2003, 2007" />
<meta name="security" content="public" />
<meta name="Robots" content="index,follow"/>
<meta http-equiv="PICS-Label" content='(PICS-1.1 "http://www.icra.org/ratingsv02.html" l gen true r (cz 1 lz 1 nz 1 oz 1 vz 1) "http://www.rsac.org/ratingsv01.html" l gen true r (n 0 s 0 v 0 l 0) "http://www.classify.org/safesurf/" l gen true r (SS~~000 1))' />
<meta name="type" content="concept, reference, reference, task, task, task, task, task, task, task, task, task, task, task, task, reference, task, task, reference, task, task, task, reference, task, reference, task, reference, reference, task, reference, task, reference, task, task, reference, reference, reference, reference, task, reference, task, task, reference, task, task, task, reference, task, reference, task, task, reference, task, task, task, task, task, task, reference, reference, reference" />
<meta name="keywords" content="Red Hat Enterprise Linux(RHEL) 4, 설치, Red Hat Enterprise Linux(RHEL) 5, SELinux, 설치 제거" />
<meta name="keywords" content="Red Hat Enterprise Linux(RHEL) 4Ii, TAR(Tape Archive), -agentlib:, -agentpath:, -assert, -cp, -classpath, -D, -help, -?, -javaagent:" />
<meta name="keywords" content="-jre-restrict-search, -no-jre-restrict-search, -showversion, -verbose:, -version:, -X, JIT(just-in-time), 컴파일러, JIT(just-in-time) 컴파일, -Xinit" />
<meta name="keywords" content="options, -Xnojit, 테스트, JIT, 지정, 가비지 콜렉션, -Xgcpolicy, 일시정지 시간, 일시정지 시간 단축, 가득 찬 힙, 환경, XML, XSL, 클래스 데이터 공유" />
<meta name="keywords" content="-Xshareclasses, 클래스 공유 옵션, -Xscmx, 캐시 작성, 캐시 채우기, 캐시 모니터링, 캐시 삭제, 성능 이용, 메모리 이용, 제한사항, 클래스 공유, 고려사항" />
<meta name="keywords" content="캐시 크기 한계, 런타임 바이트 코드 수정, 운영 체제 제한사항, 사용, SharedClassPermission, 채택, 클래스 로더, -Xcheck:memory" />
<title>SDK 및 런타임 안내서</title>
<link rel="stylesheet" type="text/css" href="../ibmidwb.css" />
<link rel="stylesheet" type="text/css" href="../swg_info_common.css" />
</head>
<body class="revised">
<a id="Top_Of_Page" name="Top_Of_Page"></a><h1>IBM SDK for Linux, Java Technology Edition,&nbsp;버전 6</h1>
<h1>SDK 및 런타임 안내서</h1><span class="productlevel">버전 6 릴리스 0</span> 
<br />
<span class="ibmdocnum"></span><br />
<a name="notices_link"></a>
<div id="notices_link">
<div class="pblklblbox">
<span class="pblktitle">참고</span>
<p>이 정보 및 이 정보가 지원하는 제품을 사용하기 전에 <a href="#notices">주의사항</a>의 정보를 읽으십시오.</p></div></div>
<a name="copyright"></a>
<div id="copyright">
<span class="ednoticestitle">저작권 정보</span>
<p>이 개정판은 다중 플랫폼의
IBM SDK and Runtime Environment for Linux에
적용됩니다.</p>
<p>이 안내서는 새 개정판에 별도로 명시하지 않는 한 다음 및 모든 후속 릴리스와 수정에 적용됩니다. 
</p>
<ul>
<li>Intel 아키텍처의 IBM 32-bit SDK and Runtime Environment for Linux, Java Technology Edition, 버전 6</li>
<li>AMD64/EM64T 아키텍처의 IBM 64-bit SDK and Runtime Environment for Linux, Java Technology Edition, 버전 6</li>
<li>System
i<sup>(TM)</sup> 및 System p<sup>(TM)</sup> 아키텍처의 IBM 32-bit SDK and Runtime Environment for Linux, Java Technology Edition, 버전 6</li>
<li>System
i 및 System p 아키텍처의 IBM 64-bit SDK and Runtime Environment for Linux, Java Technology Edition, 버전 6</li>
<li>System
z 아키텍처의 IBM 31-bit SDK and Runtime Environment for Linux, Java Technology
Edition, 버전 6</li>
<li>System
z 아키텍처의 IBM 64-bit SDK and Runtime Environment for Linux, Java Technology
Edition, 버전 6</li></ul>
<p>(C) Copyright Sun Microsystems, Inc. 1997, 2007, 901 San Antonio Rd., Palo Alto, CA 94303 USA. All
rights  reserved.</p></div><div><strong>Copyright International Business Machines Corporation 2003, 2007. All rights reserved.</strong></div>

<a name="wq2"></a>
<div id="wq2">
<h1>목차</h1>
<div class="head1"><a id="ToC_1" name="ToC_1" href="#preface" class="toclink">서문</a></div>
<div class="head1"><a id="ToC_2" name="ToC_2" href="#overview" class="toclink">개요</a></div>
<div class="head2"><a id="ToC_3" name="ToC_3" href="#lnx_conventions" class="toclink">규약</a></div>
<div class="head2"><a id="ToC_4" name="ToC_4" href="#compatibility" class="toclink">버전 호환성</a></div>
<div class="head2"><a id="ToC_5" name="ToC_5" href="#migrating" class="toclink">다른 IBM JVM에서 이주</a></div>
<div class="head2"><a id="ToC_6" name="ToC_6" href="#zhardware" class="toclink"> System z에 지원되는 하드웨어</a></div>
<div class="head1"><a id="ToC_7" name="ToC_7" href="#contents_sdk" class="toclink">SDK 및 Runtime Environment의 컨텐츠</a></div>
<div class="head2"><a id="ToC_8" name="ToC_8" href="#jretools" class="toclink">Runtime Environment 클래스 및 도구</a></div>
<div class="head2"><a id="ToC_9" name="ToC_9" href="#sdktools" class="toclink">SDK 도구 및 참조 정보</a></div>
<div class="head1"><a id="ToC_10" name="ToC_10" href="#lin_install_config" class="toclink">SDK 및 Runtime Environment 설치 및 구성</a></div>
<div class="head2"><a id="ToC_11" name="ToC_11" href="#upgrading" class="toclink">SDK 업그레이드</a></div>
<div class="head2"><a id="ToC_12" name="ToC_12" href="#installredhat4" class="toclink">Red Hat Enterprise Linux(RHEL) 4에 설치</a></div>
<div class="head2"><a id="ToC_13" name="ToC_13" href="#installredhat5" class="toclink">Red Hat Enterprise Linux(RHEL) 5에 설치</a></div>
<div class="head3"><a id="ToC_14" name="ToC_14" href="#lin_redhat_selinux" class="toclink">RHEL 5의 SELinux를 사용하여 Java 실행</a></div>
<div class="head2"><a id="ToC_15" name="ToC_15" href="#lin_install" class="toclink">64-bit 구조에 32-bit SDK 설치</a></div>
<div class="head2"><a id="ToC_16" name="ToC_16" href="#lin_rpm_install" class="toclink">RPM 파일로 설치</a></div>
<div class="head2"><a id="ToC_17" name="ToC_17" href="#lin_tgz_install" class="toclink">.tgz 파일로 설치</a></div>
<div class="head2"><a id="ToC_18" name="ToC_18" href="#lin_jpackage_install" class="toclink">JPackage 호환 가능 형식, 포맷 사용</a></div>
<div class="head2"><a id="ToC_19" name="ToC_19" href="#lin_config" class="toclink">Linux용 SDK 및 Runtime Environment 구성</a></div>
<div class="head3"><a id="ToC_20" name="ToC_20" href="#pathcons" class="toclink">경로 설정</a></div>
<div class="head3"><a id="ToC_21" name="ToC_21" href="#classpath" class="toclink">클래스 경로 설정</a></div>
<div class="head2"><a id="ToC_22" name="ToC_22" href="#lin_uninstall" class="toclink">Linux용 SDK 및 Runtime Environment 설치 제거</a></div>
<div class="head3"><a id="ToC_23" name="ToC_23" href="#uninstrpm" class="toclink">Red Hat Package Manager(RPM) 패키지 설치 제거</a></div>
<div class="head3"><a id="ToC_24" name="ToC_24" href="#uninsttar" class="toclink">압축된 TAR(Tape Archive) 패키지 및 Linux용  설치 제거</a></div>
<div class="head1"><a id="ToC_25" name="ToC_25" href="#running_applications" class="toclink">Java 응용프로그램 실행</a></div>
<div class="head2"><a id="ToC_26" name="ToC_26" href="#invint" class="toclink">java 및 javaw 명령</a></div>
<div class="head3"><a id="ToC_30" name="ToC_30" href="#build_number" class="toclink">버전 정보 얻기</a></div>
<div class="head3"><a id="ToC_31" name="ToC_31" href="#specifying_options" class="toclink">Java 옵션 및 시스템 특성 지정</a></div>
<div class="head3"><a id="ToC_32" name="ToC_32" href="#standard_options" class="toclink">표준 옵션</a></div>
<div class="head3"><a id="ToC_33" name="ToC_33" href="#globalization" class="toclink">java 명령의 글로벌화</a></div>
<div class="head2"><a id="ToC_34" name="ToC_34" href="#jit" class="toclink">JIT(just-in-time) 컴파일러</a></div>
<div class="head3"><a id="ToC_35" name="ToC_35" href="#disjit" class="toclink">JIT 사용 안함</a></div>
<div class="head3"><a id="ToC_36" name="ToC_36" href="#enajit" class="toclink">JIT 사용</a></div>
<div class="head3"><a id="ToC_37" name="ToC_37" href="#detjit" class="toclink">JIT가 사용 가능한지 여부 판별</a></div>
<div class="head2"><a id="ToC_38" name="ToC_38" href="#garbage" class="toclink">가비지 콜렉션 정책 지정</a></div>
<div class="head3"><a id="ToC_39" name="ToC_39" href="#garbage_options" class="toclink">가비지 콜렉션 옵션</a></div>
<div class="head3"><a id="ToC_40" name="ToC_40" href="#garbage_pause" class="toclink">일시정지 시간</a></div>
<div class="head3"><a id="ToC_41" name="ToC_41" href="#pausetimereduction" class="toclink">일시정지 시간 단축</a></div>
<div class="head3"><a id="ToC_42" name="ToC_42" href="#garbage_full_heap" class="toclink">힙이 가득 찬 환경</a></div>
<div class="head2"><a id="ToC_43" name="ToC_43" href="#euro_symbol" class="toclink">Euro 기호 지원</a></div>
<div class="head2"><a id="ToC_44" name="ToC_44" href="#fallback_font" class="toclink">대체 글꼴 구성 파일</a></div><span id="changed">|</span>
<span id="changed">|</span><div class="head2"><a id="ToC_45" name="ToC_45" href="#input_method_extensions" class="toclink">인도어 및 태국어 입력 메소드 사용</a></div>
<div class="head1"><a id="ToC_46" name="ToC_46" href="#developing" class="toclink">SDK를 사용하여 Java 응용프로그램 개발</a></div><span id="changed">|</span>
<span id="changed">|</span><div class="head2"><a id="ToC_47" name="ToC_47" href="#xml_using" class="toclink">XML 사용</a></div><span id="changed">|</span>
<span id="changed">|</span><div class="head3"><a id="ToC_50" name="ToC_50" href="#xslt_migration_steps" class="toclink">XL-TXE-J로 이주</a></div><span id="changed">|</span>
<span id="changed">|</span><div class="head3"><a id="ToC_51" name="ToC_51" href="#xml_reference" class="toclink">XML 참조 정보</a></div>
<div class="head2"><a id="ToC_62" name="ToC_62" href="#debugger" class="toclink">Java 응용프로그램 디버깅</a></div>
<div class="head3"><a id="ToC_63" name="ToC_63" href="#jdb" class="toclink">JDB(Java Debugger)</a></div>
<div class="head2"><a id="ToC_64" name="ToC_64" href="#bit_check" class="toclink">응용프로그램을 실행 중인 JVM이 32-bit인지 64-bit인지 판별</a></div>
<div class="head2"><a id="ToC_65" name="ToC_65" href="#signals" class="toclink">JVM의 신호 처리 방법</a></div>
<div class="head3"><a id="ToC_66" name="ToC_66" href="#sighand" class="toclink">JVM에서 사용되는 신호</a></div>
<div class="head3"><a id="ToC_67" name="ToC_67" href="#native_signals" class="toclink">신호 체인 라이브러리에 원시 코드 드라이버 링크</a></div>
<div class="head2"><a id="ToC_68" name="ToC_68" href="#usejni" class="toclink">JNI 응용프로그램 작성</a></div>
<div class="head2"><a id="ToC_69" name="ToC_69" href="#blocked_threads" class="toclink">블록된 커넥터의 스레드 레벨 복구 지원</a></div>
<div class="head2"><a id="ToC_70" name="ToC_70" href="#alloc_large_page" class="toclink">대형 페이지 메모리 할당 구성</a></div>
<div class="head2"><a id="ToC_71" name="ToC_71" href="#corba" class="toclink">CORBA 지원</a></div>
<div class="head3"><a id="ToC_75" name="ToC_75" href="#corba_properties" class="toclink">ORB 추적을 위한 시스템 특성</a></div>
<div class="head3"><a id="ToC_79" name="ToC_79" href="#corba_tuning" class="toclink">ORB 조정을 위한 시스템 특성</a></div>
<div class="head3"><a id="ToC_80" name="ToC_80" href="#corba_security" class="toclink">ORM에 대한 Java 보안 권한</a></div>
<div class="head3"><a id="ToC_81" name="ToC_81" href="#corba_classes" class="toclink">ORB 구현 클래스</a></div>
<div class="head2"><a id="ToC_82" name="ToC_82" href="#rmi-iiop" class="toclink">RMI over IIOP</a></div>
<div class="head2"><a id="ToC_83" name="ToC_83" href="#rmi" class="toclink">RMI 연결 핸들러 풀 구현</a></div>
<div class="head2"><a id="ToC_84" name="ToC_84" href="#bigd" class="toclink">향상된 BigDecimal</a></div>
<div class="head1"><a id="ToC_85" name="ToC_85" href="#deploying" class="toclink">Plug-in, 애플릿 뷰어 및 Web Start</a></div>
<div class="head2"><a id="ToC_86" name="ToC_86" href="#using_plugin" class="toclink"><strong><span class="bold-italic">(Linux IA 32비트 및 PPC32에만 해당) </span></strong> Java Plug-in 사용</a></div>
<div class="head3"><a id="ToC_87" name="ToC_87" href="#suppbrowse" class="toclink">지원되는 브라우저</a></div>
<div class="head3"><a id="ToC_88" name="ToC_88" href="#installing_plugin" class="toclink">Java Plug-in 설치 및 구성</a></div>
<div class="head3"><a id="ToC_91" name="ToC_91" href="#plugin_dom" class="toclink">공통 DOM(Document Object Model) 지원</a></div>
<div class="head3"><a id="ToC_92" name="ToC_92" href="#plugin_dbcs" class="toclink">DBCS 매개변수 사용</a></div>
<div class="head2"><a id="ToC_93" name="ToC_93" href="#applets" class="toclink">애플릿에 대한 작업</a></div>
<div class="head3"><a id="ToC_94" name="ToC_94" href="#applet_viewer" class="toclink">애플릿 뷰어로 애플릿 실행</a></div>
<div class="head3"><a id="ToC_95" name="ToC_95" href="#applet_debugging" class="toclink">애플릿 뷰어로 애플릿 디버깅</a></div>
<div class="head2"><a id="ToC_96" name="ToC_96" href="#using_webstart" class="toclink"><strong><span class="bold-italic">(Linux IA 32-bit, PPC32 및 PPC64에만 해당)</span></strong> Web Start 사용</a></div>
<div class="head3"><a id="ToC_97" name="ToC_97" href="#installing_webstart" class="toclink">Web Start 실행</a></div>
<div class="head3"><a id="ToC_98" name="ToC_98" href="#webstart_ssv" class="toclink"><strong><span class="bold-italic">(Linux IA 32-bit에만 해당) </span></strong>Web Start SSV(Secure Static Versioning)</a></div>
<div class="head2"><a id="ToC_99" name="ToC_99" href="#shipping" class="toclink">Java 응용프로그램 운송</a></div>
<div class="head1"><a id="ToC_100" name="ToC_100" href="#classdatasharing" class="toclink"> JVM 사이에 클래스 데이터 공유</a></div>
<div class="head2"><a id="ToC_101" name="ToC_101" href="#shc_overview" class="toclink">클래스 데이터 공유 개요</a></div>
<div class="head2"><a id="ToC_108" name="ToC_108" href="#sharedclassesxoptions" class="toclink">클래스 데이터 공유 사용 및 구성</a></div>
<div class="head2"><a id="ToC_109" name="ToC_109" href="#shc_admin" class="toclink">캐시 작성, 채우기, 모니터링 및 삭제</a></div>
<div class="head2"><a id="ToC_110" name="ToC_110" href="#shc_performance" class="toclink">성능 및 메모리 이용</a></div>
<div class="head2"><a id="ToC_111" name="ToC_111" href="#shc_limitations" class="toclink">클래스 데이터 공유 사용에 대한 고려사항 및 제한사항</a></div>
<div class="head3"><a id="ToC_112" name="ToC_112" href="#cachesizelimits" class="toclink">캐시 크기 한계</a></div>
<div class="head3"><a id="ToC_113" name="ToC_113" href="#runtimebytecode" class="toclink">런타임 바이트 코드 수정</a></div>
<div class="head3"><a id="ToC_114" name="ToC_114" href="#shc_os_limitations" class="toclink">운영 체제 제한사항</a></div>
<div class="head3"><a id="ToC_115" name="ToC_115" href="#usingsharedclasspermissions" class="toclink">SharedClassPermission 사용</a></div>
<div class="head2"><a id="ToC_116" name="ToC_116" href="#adaptingclassloaders" class="toclink">클래스를 공유하기 위한 사용자 정의 클래스 로더 채택</a></div>
<div class="head1"><a id="ToC_117" name="ToC_117" href="#jcommchapter" class="toclink">Java Communications API(JavaComm) 사용</a></div>
<div class="head2"><a id="ToC_118" name="ToC_118" href="#instcomm" class="toclink">압축 파일에서 Java Communications API 설치</a></div>
<div class="head2"><a id="ToC_119" name="ToC_119" href="#instcomm_rpm" class="toclink">RPM 파일에서 Java Communications API 설치</a></div>
<div class="head2"><a id="ToC_120" name="ToC_120" href="#fileloc" class="toclink">Java Communications API 파일의 위치</a></div>
<div class="head2"><a id="ToC_121" name="ToC_121" href="#javacomm_lnx_serial" class="toclink">직렬 및 병렬 포트의 액세스 모드 변경</a></div>
<div class="head2"><a id="ToC_122" name="ToC_122" href="#javacomm_lnx_devices" class="toclink">javax.comm.properties 파일에 디바이스 지정</a></div>
<div class="head2"><a id="ToC_123" name="ToC_123" href="#javacomm_thinkpad" class="toclink">IBM ThinkPad에서 직렬 포트 사용</a></div>
<div class="head2"><a id="ToC_124" name="ToC_124" href="#javacomm_printing" class="toclink">Java Communications API의 제한사항 인쇄</a></div>
<div class="head2"><a id="ToC_125" name="ToC_125" href="#javacomm_lnx_remove" class="toclink">Java Communications API 설치 제거</a></div>
<div class="head3"><a id="ToC_126" name="ToC_126" href="#javacomm_redhat_remove" class="toclink">Red Hat Package Manager(RPM) 패키지 설치 제거</a></div>
<div class="head3"><a id="ToC_127" name="ToC_127" href="#javacomm_tar_remove" class="toclink">압축된 TAR(Tape Archive) 패키지 설치 제거</a></div>
<div class="head2"><a id="ToC_128" name="ToC_128" href="#javacomm_apidoc" class="toclink">Java Communications API 문서</a></div>
<div class="head1"><a id="ToC_129" name="ToC_129" href="#support" class="toclink">ISV(독립 소프트웨어 벤더)에 대한 서비스 및 지원</a></div>
<div class="head1"><a id="ToC_130" name="ToC_130" href="#accessibility" class="toclink">내게 필요한 옵션</a></div>
<div class="head2"><a id="ToC_131" name="ToC_131" href="#access_keyboard" class="toclink">Swing에서 JComboBox 구성요소의 키보드 종단</a></div>
<div class="head2"><a id="ToC_132" name="ToC_132" href="#access_webstart" class="toclink">Web Start 내게 필요한 옵션(Linux IA 32-bit, PPC32 및 PPC64에만 해당)</a></div>
<div class="head1"><a id="ToC_133" name="ToC_133" href="#rcf" class="toclink">이 책에 대한 고객 의견</a></div>
<div class="head1"><a id="ToC_134" name="ToC_134" href="#xoptions" class="toclink">부록A. 비표준 옵션</a></div>
<div class="head1"><a id="ToC_135" name="ToC_135" href="#limitations" class="toclink">부록B. 알려진 제한사항</a></div>
<div class="head1"><a id="ToC_169" name="ToC_169" href="#notices" class="toclink">주의사항</a></div>
<div class="head2"><a id="ToC_170" name="ToC_170" href="#trademarks" class="toclink">상표</a></div>
</div>
<a name="preface"></a>
<h1 id="preface"><a href="#ToC_1">서문</a></h1>
<div>
<p>이 사용자 안내서는 IBM<sup>(R)</sup> SDK and Runtime Environment for Linux<sup>(R)</sup>, Java<sup>(TM)</sup> Technology
Edition, 버전 6에 대한 일반 정보와
IBM 구현을 Sun 구현과 비교한 차이점에 대한 구체적인 정보를 제공합니다.</p></div>
<p>이 사용자 안내서는 <a href="http://java.sun.com" target="_blank">http://java.sun.com</a>의 Sun 웹 사이트에 나와 있는 다른 다양한 문서와 함께 읽으십시오.</p>
<p>테스트된 Linux용 SDK 및 Runtime Environment 배포판의 목록은
<a href="http://www.ibm.com/developerworks/java/jdk/linux/tested.html" target="_blank">http://www-106.ibm.com/developerworks/java/jdk/linux/tested.html</a>을 참조하십시오.</p>
<p><strong>(Intel<sup>(R)</sup> 32비트
플랫폼에만 해당) </strong>다음과 같은
가상화 환경이 지원됩니다.
</p>
<ul>
<li>VMWare</li>
<li>Xen</li>
<li>Microsoft<sup>(R)</sup> Virtual
Server</li></ul>
<p><a href="http://www.ibm.com/developerworks/java/jdk/diagnosis/60.html" target="_blank">진단
안내서</a>는 Java용 IBM Virtual Machine에 대한 자세한 정보를 제공합니다.</p>
<p>이 사용자 안내서는 릴리스의 일부이며 특정 릴리스에만
적용할 수 있습니다. 사용 중인 릴리스에 해당하는 사용자 안내서인지 확인하십시오.</p>
<p>"Runtime Environment" 및 "JVM(Java Virtual Machine)"이라는 용어는 이 사용자 안내서에서
서로 교환 가능하도록 사용됩니다.</p>
<p><font color="RED"><span id="changed">|</span>사소하거나 명백한 변경사항 이외에 이 사용자 안내서 버전에 대한 기술적
<span id="changed">|</span>변경사항은 Information Center에서는 파란색 갈짓자 무늬 장식으로 표시되고, HTML 또는 컬러 인쇄본에서는
<span id="changed">|</span>변경사항 왼쪽의 수직 막대가 빨간색으로 표시되며, PDF에서는 변경사항 왼쪽에 수직 막대가 표시됩니다.</font></p>
<p>프로그램 코드는 항공기, 항공 교통, 항공기 네비게이션 또는 항공기 통신과 같은
온라인 제어의 실시간 응용프로그램이나 핵 기지의 설계, 구축, 조작 또는 관리에 사용하도록
디자인되거나 의도되지 않았습니다.</p>
<a name="overview"></a>
<h1 id="overview"><a href="#ToC_2">개요</a></h1>
<div>
<p>IBM SDK는
Java 6 코어 API(Application Program Interface)에 부합하는
애플릿 및 응용프로그램을 작성하고 실행하기 위한 개발 환경입니다.</p></div>
<p>SDK에는 Java
응용프로그램을 실행할 수 있는 Runtime Environment for Linux가
있습니다. SDK를 설치한 경우 Runtime Environment가 포함됩니다.</p>
<p>Runtime Environment에는
Java Virtual
Machine 및 지원 파일(디버그할 수 없는 .so 파일 및 클래스 파일 포함)이
있습니다. Runtime Environment에는 SDK에 있는 클래스의 서브세트만 포함되며, 런타임에
Java 프로그램을 지원할 수 있으나
Java 프로그램을
컴파일할 수는 없습니다. Linux용 Runtime Environment에는
<strong>appletviewer</strong>, Java
컴파일러(<strong>javac</strong>) 또는 개발 시스템 전용 클래스 등의 개발 도구는 포함되어 있지 않습니다.</p>
<p>또한 IA32, PPC32/PPC64 및 AMD64/EM64T
플랫폼의 경우 Linux용 Runtime Environment와 함께 사용할 수 있는
Java 통신
API(application programming interface) 패키지가 제공됩니다. 자세한 정보는 <a href="#jcommchapter">Java Communications API(JavaComm) 사용</a>을 참조하십시오.</p>
<p>license_<em>xx</em>.html 파일에는
Runtime Environment for Linux 소프트웨어의
라이센스 계약이 들어 있습니다. 여기서 <em>xx</em>는 언어의 약어입니다. 라이센스 계약을
보거나 인쇄하려면 웹 브라우저에서 이 파일을 여십시오.</p>
<a name="lnx_conventions"></a>
<h2 id="lnx_conventions"><a href="#ToC_3">규약</a></h2>
<div>
<p>이 사용자 안내서에서는 SDK의 기본 설치 디렉토리를
/opt/ibm/java-i386-60/라고 합니다.
 Linux IA 32비트를 사용하고 있으면
기본 설치 디렉토리가 달라집니다.</p></div>
<p>여기에 나열된 플랫폼에는 여러 기본 설치 디렉토리가 있습니다.
/opt/ibm/java-i386-60/을 사용 중인 플랫폼의 디렉토리로 바꾸십시오. 
</p>
<ul>
<li>Linux IA
32-bit: /opt/ibm/java-i386-60/</li>
<li>Linux AMD
64-bit: /opt/ibm/java-x86_64-60/</li>
<li>Linux PPC
32-bit: /opt/ibm/java-ppc-60/</li>
<li>Linux PPC
64-bit: /opt/ibm/java-ppc64-60/</li>
<li>Linux System
z<sup>(TM)</sup> 31-bit: /opt/ibm/java-s390-60/</li>
<li>Linux System
z 64-bit: /opt/ibm/java-s390x-60/</li></ul>
<p>Korn 쉘 명령은 이 사용자 안내서 전체의 예제에 사용됩니다.</p>
<a name="compatibility"></a>
<h2 id="compatibility"><a href="#ToC_4">버전 호환성</a></h2>
<div>
<p>일반적으로 SDK의 이전 버전에서 실행된
모든 애플릿 또는 응용프로그램은
IBM SDK for Linux, v6에서 정확하게 실행됩니다.
이 릴리스로 컴파일한 클래스가 이전 릴리스에서 작동하는지는 보장할 수 없습니다.</p></div>
<p>릴리스 사이의 호환성 문제에 대한 정보는 다음 Sun 웹 사이트를
참조하십시오.</p>
<p><a href="http://java.sun.com/javase/6/webnotes/compatibility.html" target="_blank"><font color="RED"><span id="changed">|</span>http://java.sun.com/javase/6/webnotes/compatibility.html</font></a></p>
<p><a href="http://java.sun.com/j2se/5.0/compatibility.html" target="_blank">http://java.sun.com/j2se/5.0/compatibility.html</a></p>
<p><a href="http://java.sun.com/j2se/1.4/compatibility.html" target="_blank">http://java.sun.com/j2se/1.4/compatibility.html</a></p>
<p><a href="http://java.sun.com/j2se/1.3/compatibility.html" target="_blank">http://java.sun.com/j2se/1.3/compatibility.html</a></p>
<p>다른 제품(예: IBM WebSphere<sup>(R)</sup> Application
Server)의 일부로 SDK를 사용 중이고 이전 레벨의 SDK(v5.0)에서 업그레이드하는 경우, 직렬화된 클래스가 호환되지 않을 수도 있습니다. 그러나 서비스 새로 고치기 사이에는 클래스가 호환됩니다.</p>
<a name="migrating"></a>
<h2 id="migrating"><a href="#ToC_5">다른 IBM JVM에서 이주</a></h2>
<div>
<p>버전 5.0부터 IBM Runtime Environment for Linux에는
IBM Virtual Machine for Java 및 JIT(Just-In-Time) 컴파일러의 새 버전이 있습니다.</p></div>
<p>이전 IBM Runtime Environment에서 이주 중인 경우에는
다음에 주의하십시오.</p>
<ul>
<li>Sun JVM과 일치시키기 위해 JVM 공유 라이브러리 libjvm.so이
jre/lib/&lt;arch&gt;/j9vm 및
jre/lib/&lt;arch&gt;/classic에 저장되어 있습니다.</li>
<li>버전 5.0 이후로는 JVMMI(JVM Monitoring Interface)는
더 이상 사용할 수 없습니다. 대신 JVMTI(JVM Tool Interface)를 사용하는 JVMMI 응용프로그램을
재작성해야 합니다. JVMTI는 기능상으로
JVMMI와 같지 않습니다. JVMTI에 대한 정보는 <a href="http://java.sun.com/javase/6/docs/technotes/guides/jvmti/" target="_blank">http://java.sun.com/javase/6/docs/technotes/guides/jvmti/</a> and the <a href="http://www.ibm.com/developerworks/java/jdk/diagnosis/60.html" target="_blank">진단
안내서</a>를 참조하십시오.</li>
<li>버전 5.0 이후로 JNI의 구현은
JNI 스펙을 준수하지만 버전 1.4.2 구현과는 다릅니다.
새 구현은 오브젝트를 계속 보유하는 대신에
오브젝트의 사본을 리턴합니다. 이러한 차이점이 JNI 응용프로그램 코드의 오류를
일으킬 수 있습니다. JNI 코드 디버깅에 대한 정보는 <a href="#xoptions">부록A. 비표준 옵션</a>의 <strong>-Xcheck:jni</strong>를 참조하십시오.</li>
<li>버전 5.0 이후로 <strong>-verbose:gc</strong>를 사용하여 얻은 가비지 콜렉터 상세 로그의
형식 및 컨텐츠가 변경되었습니다. 이제 데이터가
XML로 포맷됩니다. 데이터 내용은 JVM의 가비지 콜렉션 구현에 대한
변경사항을 반영하게 되므로 출력된 대부분의 통계가 변경되었습니다.
새로운 포맷 및 데이터로 작업할 수 있도록 verbose GC 출력을 처리하는
모든 프로그램을 변경해야 합니다. 새 verbose GC 데이터의 예제는 <a href="http://www.ibm.com/developerworks/java/jdk/diagnosis/60.html" target="_blank">진단 안내서</a>를 참조하십시오.</li>
<li>IBM JRE의 SDK 1.4 버전에는
core.jar이라는 파일에 JVM 특정 클래스가 있었습니다. 버전 5.0 이후로 이 클래스는 vm.jar이라는 파일에
있습니다.</li>
<li>IBM JRE의 이전 버전에서는 jre/lib 디렉토리에
rt.jar이라는 파일이 포함되어 있습니다. 버전 1.4 이후로는 이 파일이
jre/lib 디렉토리의 다중 JAR 파일로 바뀌었습니다.</li>
<li><font color="RED"><span id="changed">|</span>추가 산업 호환성 및 사용되지 않는 API 정보는
<span id="changed">|</span><a href="http://java.sun.com/javase/6/webnotes/compatibility.html" target="_blank">Sun의
<span id="changed">|</span>Java 6 호환성 문서</a> 및
<span id="changed">|</span><a href="http://java.sun.com/javase/6/docs/api/deprecated-list.html" target="_blank">Sun의
<span id="changed">|</span>Java 6 사용되지 않는 API 목록</a>을 참조하십시오.</font></li>
<li><strong>-verbose:Xclassdep</strong>를 사용하여 호출하는 추적 클래스 종속성은
지원되지 않습니다. <strong>-verbose:Xclassdep</strong>를 지정하는 경우 JVM은 오류 메시지를 발행하며, 시작되지 않습니다.</li></ul>
<a name="zhardware"></a>
<h2 id="zhardware"><a href="#ToC_6"> System z에 지원되는 하드웨어</a></h2>
<div>
<p>System z 31-bit
및 64-bit SDK와 Runtime Environment는
System
z9<sup>(TM)</sup> 및 zSeries<sup>(R)</sup> 하드웨어에서
실행됩니다.</p></div>
<p>SDK 및 Runtime Environment는 다음 서버 또는 동등한 제품에서 실행됩니다.
</p>
<ul>
<li>z9-109</li>
<li>z990</li>
<li>z900</li>
<li>z890</li>
<li>z800</li></ul>
<a name="contents_sdk"></a>
<h1 id="contents_sdk"><a href="#ToC_7">SDK 및 Runtime Environment의 컨텐츠</a></h1>
<div>
<p>SDK에는 몇 가지 개발 도구와
JRE(Java Runtime Environment)가
있습니다. 이 절에서는 SDK 도구 및 Runtime
Environment의 컨텐츠에 대해 설명합니다.</p></div>
<p>전체가 Java로 작성된 응용프로그램에는
IBM SDK의 디렉토리 구조(또는 해당 디렉토리 내의 파일)에
대한 종속성이 <strong>없어야</strong> 합니다. SDK의 디렉토리 구조(또는 해당 디렉토리의 파일)에
대한 종속성으로 인해 응용프로그램 이식성 문제가 발생할 수
있습니다. JNI(</p>
<p>사용자 안내서, Javadoc
및 함께 제공되는 라이센스, 저작권
파일, javadoc 및 데모 디렉토리는 이 SDK for Linux에
포함된 유일한 문서입니다. Sun 웹 사이트(<a href="http://java.sun.com" target="_blank">http://java.sun.com</a>)를
방문하여 Sun의 소프트웨어 문서를 보거나 Sun 웹 사이트에서 Sun의 소프트웨어 문서 패키지를
다운로드할 수 있습니다.</p>
<a name="jretools"></a>
<h2 id="jretools"><a href="#ToC_8">Runtime Environment 클래스 및 도구</a></h2>
<div>
<p>표준 Runtime Environment와 함께 사용할 수 있는 클래스 및 도구의 목록입니다.</p></div>
<p></p>
<ul>
<li>코어 클래스 -- 플랫폼용으로 컴파일된 클래스 파일로,
컴파일러 및 해석기가 이 파일을 액세스하려면 압축된 상태여야 합니다. 이러한 클래스를 수정하지
마십시오. 대신 서브클래스를 작성하고 필요한 곳에서
대체하십시오.</li>
<li>JRE 도구 -- 다음 도구는 Runtime Environment의 일부이며
달리 지정하지 않은 경우 /opt/ibm/java-i386-60/jre/bin 디렉토리에 있습니다. 

<dl class="parml">
<dt class="bold">ikeyman(iKeyman GUI 유틸리티)</dt>
<dd>키, 인증서 및 인증 요청을 관리할 수 있습니다. 자세한 정보는 함께 제공된 <em>보안 안내서</em> 및 <a href="http://www.ibm.com/developerworks/java/jdk/security" target="_blank">http://www.ibm.com/developerworks/java/jdk/security</a>를 참조하십시오. SDK도
이 유틸리티의 명령행 버전을 제공합니다.
</dd>
<dt class="bold">java(Java 해석기)</dt>
<dd>Java 클래스를
실행합니다. Java 해석기는
Java 프로그래밍 언어로 작성된 프로그램을
실행합니다.
</dd>
<dt class="bold">javaw(Java 해석기)</dt>
<dd><strong>java</strong> 명령과 동일한 방법으로
Java 클래스를 실행하지만
콘솔 창을 사용하지 않습니다.
</dd>
<dt class="bold"><strong><span class="bold-italic">(Linux IA 32-bit,
PPC32 및 PPC64에만 해당) </span></strong>javaws(Java Web Start)</dt>
<dd>Java 응용프로그램의
배치 및 관리를 사용합니다. 자세한 정보는 웹 사이트 <a href="#installing_webstart">Web Start 실행</a>의 내용을 참조하십시오.
</dd>
<dt class="bold">jextract(덤프 추출기)</dt>
<dd>시스템이 생성한 덤프를 jdmpview에서 사용할 수 있는
일반 형식으로 변환합니다. 자세한 정보는 <a href="#sdktools__jdmpview">jdmpview</a>를 참조하십시오.
</dd>
<dt class="bold">keytool(키 및 인증 관리 도구)</dt>
<dd>해당되는 공용 키를 인증하는 개인용 키 및 연관된 X.509
인증 체인의 키 스토어(데이터베이스)를 관리합니다.
</dd>
<dt class="bold">kinit</dt>
<dd>Kerberos ticket-granting 티켓을 얻어 캐시에 넣습니다.
</dd>
<dt class="bold">klist</dt>
<dd>로컬 신임 캐시 및 키 테이블에 항목을 표시합니다.
</dd>
<dt class="bold">ktab</dt>
<dd>로컬 키 테이블에 저장된 프린시펄 이름 및 서비스 키를 관리합니다.
</dd>
<dt class="bold">pack200</dt>
<dd>Java gzip 압축 프로그램을 사용하여 JAR 파일을 압축된 pack200 파일로
변환합니다.
</dd>
<dt class="bold">policytool(정책 파일 작성 및 관리
도구)</dt>
<dd>설치의 Java 보안 정책을
정의하는 외부 정책 구성 파일을 작성하고 수정합니다.
</dd>
<dt class="bold">rmid(RMI 활성화 시스템 디먼)</dt>
<dd>오브젝트를 JVM(Java
Virtual Machine)에 등록하여 활성화할 수 있도록 활성화 시스템 디먼을 시작합니다.
</dd>
<dt class="bold">rmiregistry(Java
원격 오브젝트 레지스트리)</dt>
<dd>현재 호스트의 지정된 포트에서 원격 오브젝트 레지스트리를
작성하고 시작합니다.
</dd>
<dt class="bold">tnameserv(CORBA(Common Object Request Broker
Architecture) 임시 이름 지정 서비스)</dt>
<dd>CORBA 임시 이름 지정 서비스를 시작합니다.
</dd>
<dt class="bold">unpack200</dt>
<dd>pack200에서 생성된 packed 파일을 JAR 파일로
변환합니다.
</dd>
</dl></li></ul>
<a name="sdktools"></a>
<h2 id="sdktools"><a href="#ToC_9">SDK 도구 및 참조 정보</a></h2>
<div>
<p>표준 SDK에 포함된 도구 및 참조 정보 목록입니다.</p></div>
<p></p>
<dl class="parml">
<dt class="bold">다음 도구는 SDK의 파트이며 /opt/ibm/java-i386-60/bin 디렉토리에 있습니다. </dt>
<dd>
<dl class="parml">
<dt class="bold">appletviewer(Java 애플릿 뷰어)</dt>
<dd>웹 브라우저 밖에서 애플릿을 테스트하고 실행합니다.
</dd>
<dt class="bold">apt(어노테이션 처리 도구)</dt>
<dd>시험할 지정된 소스 파일 세트에 존재하는 어노테이션을 기반으로 어노테이션 프로세서를 찾고 실행합니다.
</dd>
<dt class="bold">extcheck(Extcheck 유틸리티)</dt>
<dd>대상 jar 파일과 현재 설치된 확장
jar 파일 간의 버전 충돌을 검색합니다.
</dd>
<dt class="bold"><strong><span class="bold-italic">(Linux IA 32-bit,
PPC32 및 PPC64에만 해당) </span></strong>HtmlConverter(Java Plug-in
HTML 변환기)</dt>
<dd>애플릿이 포함된 HTML 페이지를 Java Plug-in을
사용할 수 있는 형식으로 변환합니다.
</dd>
<dt class="bold">idlj(IDL to Java 컴파일러) </dt>
<dd>주어진 IDL 파일에서 Java 바인딩을 생성합니다.
</dd>
<dt class="bold">ikeycmd(iKeyman 명령행 유틸리티)</dt>
<dd>명령행에서 키, 인증서 및 인증 요청을 관리할 수
있습니다. 자세한 정보는 함께 제공된 <em>보안 안내서</em> 및 <a href="http://www.ibm.com/developerworks/java/jdk/security" target="_blank">http://www.ibm.com/developerworks/java/jdk/security</a>를 참조하십시오.
</dd>
<dt class="bold">jar(Java 아카이브 도구)</dt>
<dd>여러 파일을 단일 JAR(Java Archive) 파일로 결합합니다.
</dd>
<dt class="bold">jarsigner(JAR 서명 및 확인 도구)</dt>
<dd>JAR 파일에 대한 서명을 생성하고 날인된 JAR 파일의 서명을 확인합니다.
</dd>
<dt class="bold">java-rmi.cgi(HTTP-CGI 요청 전달 도구)</dt>
<dd>HTTP를 통한 RMI 요청을 승인하고 이를 포트로 수신하는 RMI 서버에 전달합니다.
</dd>
<dt class="bold">javac(Java 컴파일러) </dt>
<dd>Java 프로그래밍 언어로 작성한 프로그램을
바이트 코드(컴파일된 Java 코드)로 컴파일합니다.
</dd>
<dt class="bold">javadoc(Java 문서 생성기)</dt>
<dd>Java 소스 파일에서 API 문서의 HTML 페이지를 생성합니다.
</dd>
<dt class="bold">javah(C 헤더 및 스텁 파일 생성기)</dt>
<dd>이를 사용하여 원시 메소드를 Java 프로그래밍 언어로
작성한 코드에 연관시킬 수 있습니다.
</dd>
<dt class="bold">javap(클래스 파일 디스어셈블러)</dt>
<dd>컴파일된 파일을 디스어셈블하고 바이트코드의 표시를 인쇄할 수 있습니다.
</dd>
<dt class="bold">javaw(Java 해석기)</dt>
<dd><strong>java</strong> 명령과 동일한 방법으로
Java 클래스를 실행하지만
콘솔 창을 사용하지 않습니다.
</dd>
<dt class="bold"><strong><span class="bold-italic">(Linux IA 32-bit,
PPC32 및 PPC64에만 해당) </span></strong>javaws(Java Web Start)</dt>
<dd>Java 응용프로그램의
배치 및 관리를 사용합니다. 자세한 정보는 웹 사이트 <a href="#installing_webstart">Web Start 실행</a>의 내용을 참조하십시오.
</dd>
<dt class="bold">jconsole(JConsole 모니터링 및 관리
도구)</dt>
<dd>GUI를 사용하여 로컬 및 원격
JVM을 모니터합니다. JMX 준수.
</dd>
<dt class="bold">jdb(Java 디버거)</dt>
<dd>Java 프로그램을 디버그하도록 도와줍니다.
</dd>
<dt class="bold"><a id="sdktools__jdmpview" name="sdktools__jdmpview"></a>jdmpview(교차 플랫폼 덤프 포맷터)</dt>
<dd>덤프를 분석합니다.  자세한 정보는 <a href="http://www.ibm.com/developerworks/java/jdk/diagnosis/60.html" target="_blank"> 진단 안내서</a>를 참조하십시오.
</dd>
<dt class="bold">native2ascii(Native-To-ASCII 변환기)</dt>
<dd>원본 인코딩 파일을 Latin-1이나 Unicode 또는 둘 다로 인코드된 문자가 포함된
ASCII 파일로 변환합니다.
</dd>
<dt class="bold">rmic(Java
RMI(Remote Method Invocation) 스텁 변환기)</dt>
<dd>원격 오브젝트의 스텁, 스켈레톤 및 타이를 생성합니다. RMI-IIOP(RMI
over Internet Inter-ORB Protocol) 지원이 포함됩니다.
</dd>
<dt class="bold">schemagen</dt>
<dd>Java 클래스에서 참조된 이름 공간마다 스키마 파일을 작성합니다.
</dd>
<dt class="bold">serialver(직렬화 버전 명령)</dt>
<dd>전개되는 클래스로 복사하기에 적합한 포맷으로 하나 이상의
클래스에 대한 serialVersionUID를 리턴합니다.
</dd>
<dt class="bold">wsgen</dt>
<dd>JAX_WS 웹 서비스에 사용되는 JAX-WS 휴대용 아티팩트를 생성합니다.
</dd>
<dt class="bold">wsimport</dt>
<dd>WSDL 파일에서 JAX-WS 휴대용 아티팩트를 생성합니다.
</dd>
<dt class="bold">xjc</dt>
<dd>XML 스키마 파일을 컴파일합니다.
</dd>
</dl>
</dd>
<dt class="bold">포함 파일</dt>
<dd>JNI 프로그램용 C 헤더입니다.
</dd>
<dt class="bold">데모</dt>
<dd>데모 디렉토리에는 사용 가능한 샘플 소스 코드, 데모, 응용프로그램 및
애플릿을 포함하는 많은 서브디렉토리가 있습니다. <span><font color="RED"><span id="changed">|</span>버전 6부터 RMI-IIOP 데모는 SDK에 포함되지 않습니다.</font></span>
</dd>
<dt class="bold">저작권</dt>
<dd>SDK for Linux 소프트웨어에 대한 저작권 표시입니다.
</dd>
<dt class="bold">라이센스</dt>
<dd>
<p>라이센스 파일
/opt/ibm/java-i386-60/docs/content/<em>&lt;locale&gt;</em>/LA_<em>&lt;locale&gt;</em>에는
Linux용 SDK 소프트웨어(여기서
<em>&lt;locale&gt;</em>은 로케일의 이름(예: en))에 대한 라이센스 계약이 포함되어 있습니다. 라이센스 계약을
보거나 인쇄하려면 웹 브라우저에서 이 파일을 여십시오.</p>
</dd>
</dl>
<a name="lin_install_config"></a>
<h1 id="lin_install_config"><a href="#ToC_10">SDK 및 Runtime Environment 설치 및 구성</a></h1>
<div>
<p>RPM 파일 또는 .tgz 파일 둘 중 하나로 IBM Java SDK 및
Runtime Environment를 설치할 수 있습니다. 이 Java 설치에
시스템의 모든 사용자가 액세스할 수 있도록 하지 않으려면 .tgz 설치 메소드를 사용하십시오.
루트 액세스 권한이 없으면 .tgz 파일을 사용하십시오.</p></div>
<p>RPM 파일을 사용하여 설치하는 경우 Java 파일은
/opt/ibm/java-i386-60/에 설치됩니다.
이 안내서의 예제에서는 이 디렉토리에
Java를 설치했다고 가정합니다.</p>
<a name="upgrading"></a>
<h2 id="upgrading"><a href="#ToC_11">SDK 업그레이드</a></h2>
<div>
<p>이전 릴리스에서 SDK를 업그레이드하려면, 업그레이드를 시작하기 전에 모든 구성 파일 및 보안 정책 파일을 백업하십시오.</p></div>
<p>
<p>업그레이드 프로세스 동안에 이러한 파일이 겹쳐쓰여지기 때문에 업그레이드 후에 복원하거나 다시 구성해야만 합니다.
기존 파일을 복원하기 전에 형식이나 파일의 옵션이 변경되었을 수도 있으므로 새 파일의 구문을 확인하십시오.</p></p>
<a name="installredhat4"></a>
<h2 id="installredhat4"><a href="#ToC_12">Red Hat Enterprise Linux(RHEL) 4에 설치</a></h2>
<div>
<p>SDK는 기본적으로 Red Hat Enterprise
Linux(RHEL)에서 설치되지 않은
공유 라이브러리에 따라 달라집니다.</p></div><a id="idx1" name="idx1"></a><a id="idx2" name="idx2"></a>
<p>
<p>RHEL 4에서 이러한 라이브러리가 들어 있는 RPM은 다음과 같습니다.</p></p>
<ul>
<li><tt class="xph">compat-libstdc++-33-3.2.3</tt> and <tt class="xph">xorg-x11-deprecated-libs-6.8.1</tt>(zSeries 이외의 플랫폼)</li>
<li><tt class="xph">compat-libstdc++-295-2.95.3</tt> 및 <tt class="xph">xorg-x11-deprecated-libs-6.8.1</tt>(zSeries)</li></ul>
<p>RHEL 4 설치 시 이러한 라이브러리를 포함하려면 다음을 수행하십시오.</p>
<ol type="1">
<li><strong>패키지 기본값</strong> 화면이 표시되면 <strong>설치할 패키지 세트 사용자 정의</strong>를 선택하십시오.</li>
<li><strong>패키지 그룹 선택</strong> 화면에서 <strong>X
Windows 시스템</strong> 아래에 있는 <strong>세부사항</strong>을 선택하고
<tt class="xph">xorg-x11-deprecated-libs</tt>를 선택했는지 확인하십시오.</li>
<li><strong>개발</strong> 옵션 아래에서 <strong>레거시 소프트웨어 개발</strong>을 선택하십시오.</li></ol>
<a name="installredhat5"></a>
<h2 id="installredhat5"><a href="#ToC_13">Red Hat Enterprise Linux(RHEL) 5에 설치</a></h2>
<div>
<p>SDK는 기본적으로 Red Hat Enterprise
Linux(RHEL)에서 설치되지 않은
공유 라이브러리에 따라 달라집니다.</p></div><a id="idx3" name="idx3"></a><a id="idx4" name="idx4"></a><a id="idx5" name="idx5"></a>
<p>
<p>RHEL 5에서 이러한 라이브러리가 들어 있는 RPM은 다음과 같습니다.</p></p>
<ul>
<li><tt class="xph">libXp-1.0.0-8</tt>(모든 플랫폼)</li>
<li><tt class="xph">compat-libstdc++-33-3.2.3</tt>(zSeries 이외의 플랫폼)</li>
<li><tt class="xph">compat-libstdc++-296-2.95.3</tt>(zSeries)</li></ul>
<p>RHEL 5 설치 시 이러한 라이브러리를 포함하려면 다음을 수행하십시오.</p>
<ol type="1">
<li>소프트웨어 선택 화면에서 <strong>지금 사용자 정의</strong>를 선택하십시오.</li>
<li>다음 화면의 왼쪽 패널에서 <strong>기본 시스템</strong>을 선택하고
오른쪽 패널에서 <strong>레거시 소프트웨어 지원</strong>을 선택하십시오.
선택하면 compat-libstdc++ 패키지가 설치됩니다.</li>
<li>libXp 패키지는 필수이지만 GUI 설치 시 설치하도록 선택할 수 없습니다. 설치가 완료되면
쉘을 열고 Red Hat 설치 매체에서 libXp 패키지를 찾아 설치하십시오.
예를 들어, 32비트 Intel 플랫폼에
<tt class="xph">rpm -i /media/cdrom/Server/libXp-1.0.0-8.i386.rpm</tt>을 설치합니다.</li></ol>
<a name="lin_redhat_selinux"></a>
<h3 id="lin_redhat_selinux"><a href="#ToC_14">RHEL 5의 SELinux를 사용하여 Java 실행</a></h3>
<div>
<p>SELinux를 사용할 수 있는 Red Hat Enterprise Linux 버전 5에서
IBM SDK for Java를 실행하려면
Java를
기본 디렉토리에 설치하거나 명령을 입력해야 합니다.</p></div><a id="idx6" name="idx6"></a>
<p>
<p>Java가 기본 디렉토리에
설치되어 있지 않으면 다음을 입력하십시오.
</p>
<pre class="xmp">chcon -R -t texrel_shlib_t &lt;path_of_sdk&gt;</pre>
<p>여기서 <tt class="xph">&lt;path_of_sdk&gt;</tt>는
Java를 설치한 디렉토리입니다.</p>
<p>SELinux에 대한 자세한 정보는 Red Hat 문서에서
<a href="http://www.redhat.com/docs/manuals/enterprise/RHEL-5-manual/Deployment_Guide-en-US/ch-selinux.html" target="_blank">SELinux 소개</a>를 참조하십시오.</p></p>
<a name="lin_install"></a>
<h2 id="lin_install"><a href="#ToC_15">64-bit 구조에 32-bit SDK 설치</a></h2>
<div>
<p>SDK를 실행하려면 먼저 SDK(32비트 또는 64비트)에 필요한 모든 라이브러리 버전을 정확하게 설치해야 합니다.</p></div>
<p>
<p>RHEL4의 경우 <strong>Compatibility Arch Support</strong> 패키지 그룹에서 64비트 버전의 패키지를 사용할 수 있습니다.</p>
<p>RPM 도구를 사용하면 사용자의 RPM 명령에 <tt class="xph">--queryformat "%{NAME}.%{ARCH}\n"</tt> 옵션을 추가하여 설치한 패키지 버전이 무엇인지 확인할 수 있습니다. 예를 들면 다음과 같습니다.</p></p>
<pre class="xmp">/home/username : rpm --queryformat "%{NAME}.%{ARCH}\n" -q libstdc++
libstdc++.x86_64
libstdc++.i386</pre>
<a name="lin_rpm_install"></a>
<h2 id="lin_rpm_install"><a href="#ToC_16">RPM 파일로 설치</a></h2>
<div>
<p>RPM 파일로 설치 프로시저</p></div>
<p>rpm 도구를 사용하여 JVM을 업그레이드하려면 이전 버전을 설치 제거해야 합니다.
두 개의 JVM 버전을 각각 다른 위치에 설치하려면 rpm 강제 실행 옵션을 사용하여 버전의 충돌을 무시하고 .tgz 파일의 JVM을 설치하십시오.</p>
<ol type="1">
<li>쉘 프롬프트를 열고 루트인지 확인하십시오. </li>
<li>쉘 프롬프트에서 <tt class="xph">rpm -ivh &lt;RPM file&gt;</tt>을 입력하십시오.  예를 들면 다음과 같습니다.


<pre class="xmp">rpm -ivh ibm-java2-&lt;arch&gt;-sdk-6.0-0.0.&lt;arch&gt;.rpm</pre>또는


<pre class="xmp">rpm -ivh ibm-java2-&lt;arch&gt;-jre-6.0-0.0.&lt;arch&gt;.rpm</pre>


<p>여기서 <tt class="xph">&lt;arch&gt;</tt>는
아키텍처(i386, x86_64, ppc, ppc64, s390 또는 s390x)를 나타냅니다.</p></li></ol>
<a name="lin_tgz_install"></a>
<h2 id="lin_tgz_install"><a href="#ToC_17">.tgz 파일로 설치</a></h2>
<div>
<p>.tgz 파일로 설치 프로시저</p></div>
<ol type="1">
<li>Java 패키지 파일을 저장할 디렉토리를 작성하십시오. 이 안내서의 예제에서는
/opt/ibm/java-i386-60/에 설치했다고 가정합니다. 
안내서의 /opt/ibm/java-i386-60/를
Java를 설치한 디렉토리로 바꾸십시오.</li>
<li>쉘 프롬프트에서 <tt class="xph">tar -zxvf &lt;.tgz file&gt;</tt>을 입력하십시오.  

<pre class="xmp">tar -zxvf ibm-java2-sdk-60-linux-&lt;arch&gt;.tgz</pre>또는


<pre class="xmp">tar -zxvf ibm-java2-jre-60-linux-&lt;arch&gt;.tgz</pre>


<p>여기서 <tt class="xph">&lt;arch&gt;</tt>는 아키텍처(i386, x86_64, ppc, ppc64, s390 또는 s390x)를 나타냅니다.</p></li>
<li>SELinux(Security-Enhanced Linux)를
실행하는 경우 시스템에 대한 Java 공유 라이브러리를 식별해야 합니다. 유형은 다음과 같습니다.


<pre class="xmp">chcon -R -t texrel_shlib_t /opt/ibm/java2-i386-60/jre
chcon -R -t texrel_shlib_t /opt/ibm/java2-i386-60/bin
chcon -R -t texrel_shlib_t /opt/ibm/java2-i386-60/lib</pre></li></ol>
<a name="lin_jpackage_install"></a>
<h2 id="lin_jpackage_install"><a href="#ToC_18">JPackage 호환 가능 형식, 포맷 사용</a></h2>
<div>
<p>에서 IBM Java 패키지를
JPackage 호환 가능 형식으로 사용할 수도 있습니다.</p></div>
<p>
<p> 이제 SDK를 간단하게 관리하기 위해 기본
Java Runtime Environment,
Development Kit, Plug-in, JDBC, 데모, 사운드, 소스 및 글꼴과 같이 여러 구성요소를 별도의 RPM으로 사용할 수 있습니다.
"jpackage-utils" RPM(<a href="http://jpackage.org" target="_blank">http://jpackage.org</a>에서 다운로드 가능)을 통해 시스템에서
다중 Java RPM을 괸리할 수 있으며,
또한 IBM SDK에서도 전제조건입니다.
JPackage 스펙에 대한 자세한 정보는 <a href="http://jpackage.org" target="_blank">http://jpackage.org</a>를 참조하십시오.</p></p>
<a name="lin_config"></a>
<h2 id="lin_config"><a href="#ToC_19">Linux용
SDK 및 Runtime Environment 구성</a></h2>
<div>
<p>Red Hat Advanced Server의 글꼴 인코딩 불일치</p></div>
<a name="wq16"></a>
<div class="note-noindent" id="wq16">
<span class="notetitle">주:</span> <span class="notebody"><strong><span class="bold-italic">(Linux IA 32비트
중국어 사용자에 한해)</span></strong> 중국어를 기본 언어로 사용하는 환경에서 제품을 설치하는 경우
Red Hat Advanced Server의 글꼴 인코딩에서 불일치사항이 발생할 수 있으므로
기본 언어를 영어로 설정하여 설치를 완료한 다음, 이를 중국어로 변경하는 것이 좋습니다. 그렇지 않으면
중국어 글꼴이 표시되지 않을 수도 있습니다.</span></div>
<a name="pathcons"></a>
<h3 id="pathcons"><a href="#ToC_20">경로 설정</a></h3>
<div>
<p><strong>PATH</strong> 환경 변수를 변경하면,
해당 경로의 기존 Java 실행기가 대체됩니다.</p></div>
<p>
<p><strong>PATH</strong> 환경 변수를 사용하면 Linux에서는
현재 디렉토리에서 javac, java 및 javadoc와 같은 프로그램 및 유틸리티를
찾을 수 있습니다. <strong>PATH</strong>의 현재 값을 표시하려면
명령 프롬프트에 다음을 입력하십시오. </p>
<pre class="xmp">  echo $PATH</pre>
<p>해당 경로에 Java 실행기를 추가하려면
다음을 수행하십시오. 
</p>
<ol type="1">
<li>홈 디렉토리에 있는 쉘 시작 파일(쉘에 따라 다르며, 일반적으로 .bashrc)을 편집하여 절대 경로를
<strong>PATH</strong> 환경 변수에 추가하십시오. 예: 
<pre class="xmp">export PATH=/opt/ibm/java-i386-60/bin:/opt/ibm/java-i386-60/jre/bin:$PATH</pre></li>
<li>다시 로그온하거나 업데이트된 쉘 스크립트를 실행하여 새 <strong>PATH</strong> 변수를
활성화하십시오.</li></ol></p>
<p>
<p>경로를 설정한 후 임의의 디렉토리의 명령 프롬프트에 이름을 입력하여 도구를 실행할 수
있습니다. 예를 들어, 명령 프롬프트에서 Myfile.Java 파일을 컴파일하려면
다음을 입력하십시오.</p></p>
<pre class="xmp">javac Myfile.Java</pre>
<a name="classpath"></a>
<h3 id="classpath"><a href="#ToC_21">클래스 경로 설정</a></h3>
<div>
<p>클래스 경로는 SDK 도구(예: java,
javac 및 javadoc)에게
Java 클래스 라이브러리가 있는
위치를 알려줍니다.</p></div>
<p>
<p>다음과 같은 경우에만 클래스 경로를 명시적으로 설정해야 합니다. 
</p>
<ul>
<li>직접 개발하거나 현재 디렉토리에 없는 새로운 라이브러리 또는 클래스 파일이
필요한 경우</li>
<li>bin 및 lib 디렉토리의 위치를 변경하여 상위 디렉토리가
더 이상 동일하지 않은 경우.</li>
<li>동일한 시스템에서 다른 런타임 환경을 사용하는 응용프로그램을 개발하거나 실행할
계획인 경우.</li></ul>
<p><strong>CLASSPATH</strong> 환경 변수의 현재 값을 표시하려면
쉘 프롬프트에 다음 명령을 입력하십시오. </p>
<pre class="xmp">  echo $CLASSPATH</pre>
<p>다른
런타임 환경(별도로 설치한 다른 버전 포함)을 사용하는 응용프로그램을 개발하고 실행하는 경우, 각 응용프로그램에 대해
명시적으로 <strong>CLASSPATH</strong> 및 <strong>PATH</strong>를 설정해야 합니다. 여러 응용프로그램을 동시에 실행하며
다른 런타임 환경을 사용하는 경우, 각 응용프로그램을 자체 쉘 프롬프트에서
실행해야 합니다.</p></p>
<a name="lin_uninstall"></a>
<h2 id="lin_uninstall"><a href="#ToC_22">Linux용 SDK 및 Runtime Environment 설치 제거</a></h2>
<div>
<p>Linux용 SDK 및 Runtime Environment를 제거하는 프로세스는 사용한 설치 유형에 따라
다릅니다.</p></div>
<p>자세한 지시사항을 보려면 <a href="#uninstrpm">RPM(Red Hat Package Manager) 패키지 설치 제거</a> 또는 <a href="#uninsttar">압축된
TAR(Tape Archive) 패키지 설치 제거</a>를 참조하십시오.</p>
<a name="uninstrpm"></a>
<h3 id="uninstrpm"><a href="#ToC_23">Red Hat Package Manager(RPM) 패키지 설치 제거</a></h3>
<div>
<p>Red Hat Package Manager(RPM) 패키지 설치 제거 프로시저</p></div><a id="idx7" name="idx7"></a><a id="idx8" name="idx8"></a><a id="idx9" name="idx9"></a>
<p>
<p>RPM 패키지를 설치한 경우 Linux용 SDK 또는 Runtime Environment를 설치 제거하려면
다음을 수행하십시오.</p></p>
<ol type="1">
<li>설치한 RPM 패키지를 확인하려면 <tt class="xph">rpm -qa | grep -i java</tt>를 입력하십시오. 

<p>설치한 IBM Java 패키지의 목록이 다음과 같이 표시됩니다.
</p>
<pre class="xmp">ibm-java2-&lt;arch&gt;-jre-6.0-0.0.<em>&lt;arch&gt;</em>
ibm-java2-&lt;arch&gt;-sdk-6.0-0.0.<em>&lt;arch&gt;</em></pre>



<p>이 출력은 <tt class="xph">rpm -e</tt> 명령을 사용하여 설치 제거할 수 있는 패키지를 알려 줍니다. 예를 들면 다음과 같습니다.
</p>
<pre class="xmp">rpm -e ibm-java2-&lt;arch&gt;-jre-6.0-0.0.<em>&lt;arch&gt;</em>
rpm -e ibm-java2-&lt;arch&gt;-sdk-6.0-0.0.<em>&lt;arch&gt;</em></pre>



<p>kpackage 또는 yast2와 같은 그래픽 도구를 사용할 수도 있습니다.</p></li>
<li><strong>PATH</strong> 명령문에서 SDK 및 Runtime Environment를 설치한 디렉토리를 제거하십시오. </li>
<li>(Linux IA
32비트 및 PPC32에만 해당) Java Plug-in을
설치한 경우, 웹 브라우저 디렉토리에서 Java Plug-in
파일을 제거하십시오.</li></ol>
<a name="uninsttar"></a>
<h3 id="uninsttar"><a href="#ToC_24">압축된 TAR(Tape Archive) 패키지 및 Linux용  설치 제거</a></h3>
<div>
<p>압축된 패키지에서 추출된 IBM SDK for Linux, v6을 제거할
단계의 목록입니다.</p></div><a id="idx10" name="idx10"></a><a id="idx11" name="idx11"></a>
<ol type="1">
<li>SDK 또는
Runtime Environment를 설치한 디렉토리에서
SDK 또는
Runtime Environment 파일을 제거하십시오.</li>
<li><strong>PATH</strong> 명령문에서 SDK 또는 Runtime Environment를 설치한 디렉토리를
제거하십시오. </li>
<li>다시 로그온하거나 업데이트된 쉘 스크립트를 실행하여 새 <strong>PATH</strong> 설정을 활성화하십시오.</li>
<li>(Linux IA
32비트 및 AMD64/EM64T에만 해당) Java Plug-in을 설치한 경우
웹 브라우저 디렉토리에서
Java Plug-in 파일을 제거하십시오.</li></ol>
<a name="running_applications"></a>
<h1 id="running_applications"><a href="#ToC_25">Java 응용프로그램 실행</a></h1>
<div>
<p>Java 응용프로그램은 java 실행기 또는
JNI를 사용하여 시작할 수 있습니다. 설정은 명령행 인수, 환경 변수 및 특성 파일을 사용하여 Java 응용프로그램으로
전달됩니다.</p></div>
<a name="invint"></a>
<h2 id="invint"><a href="#ToC_26">java 및 javaw 명령</a></h2>
<div>
<p>java 및 javaw 명령의 간단한 개요입니다.</p></div>
<p>
<a name="wq24"></a>
<h3 id="wq24">용도</h3>
<p>java 및 javaw 도구는
Java Runtime
Environment를 시작하고 지정한 클래스를 로드하여
Java 응용프로그램을 실행합니다.</p>
<p>javaw 명령은 java와 동일합니다. 단,
javaw에는 연관된 콘솔 창이 없습니다. 명령 프롬프트 창을 표시하지 않으려면
javaw를 사용하십시오. javaw 실행 프로그램은 실행에 실패할 경우 오류 정보가 있는
대화 상자를 표시합니다.</p></p>
<p>
<a name="wq25"></a>
<h3 id="wq25">사용법</h3>
<p>JVM은 세 가지 위치 세트(부트스트랩 클래스 경로, 설치된 확장 및 사용자 클래스 경로)에서
초기 클래스(및 사용되는 기타 클래스)를 검색합니다. 클래스 이름 또는 JAR 파일 이름 다음에 지정한 인수가
기본 함수에 전달됩니다.</p>
<p>java 및 javaw 명령의 구문은
다음과 같습니다.</p></p>
<pre class="xmp">java [ <em>options</em> ] <em>&lt;class&gt;</em> [ <em>arguments ...</em> ]
java [ <em>options</em> ] -jar <em>&lt;file.jar&gt;</em> [ <em>arguments ...</em> ]
javaw [ <em>options</em> ] <em>&lt;class&gt;</em> [ arguments ... ]
javaw [ <em>options</em> ] -jar <em>&lt;file.jar&gt;</em> [ <em>arguments ...</em> ]</pre>
<p>
<a name="wq26"></a>
<h3 id="wq26">매개변수</h3></p>
<dl class="parml">
<dt class="bold">[<em>options</em>]</dt>
<dd>런타임 환경에 전달되는 명령행 옵션입니다.
</dd>
<dt class="bold"><em>&lt;class&gt;</em></dt>
<dd>시작 클래스입니다. 클래스에는 main() 메소드가 있어야 합니다.
</dd>
<dt class="bold"><em>&lt;file.jar&gt;</em></dt>
<dd>호출할 jar 파일의 이름. <strong>-jar</strong> 옵션과 함께만 사용됩니다.
이름 지정된 JAR 파일에는 Main-Class Manifest 헤더로 표시된 시작 클래스와 함께
응용프로그램에 대한 자원 파일 및 클래스가 있어야 합니다.
</dd>
<dt class="bold">[<em>arguments ...</em>]</dt>
<dd>시작 클래스의 main() 함수로 전달되는 명령행 인수입니다.
</dd>
</dl>
<a name="build_number"></a>
<h3 id="build_number"><a href="#ToC_30">버전 정보 얻기</a></h3>
<div>
<p>Java 설치의 IBM 빌드 및
버전 번호는 <strong>-version</strong> 옵션을 사용하여 얻을 수 있습니다. <span><font color="RED"><span id="changed">|</span>또한 <strong>-Xjarversion</strong> 옵션을 사용하여
<span id="changed">|</span>클래스 경로에서 모든 jar 파일의 버전 정보를 얻을 수도 있습니다.</font></span></p></div>
<ol type="1">
<li>쉘 프롬프트를 여십시오. </li>
<li>다음 명령을 입력하십시오.  
<pre class="xmp">    java -version</pre> 다음과 같은 정보가 표시됩니다.




<pre class="xmp">java version "1.6.0-internal"
Java(TM) SE Runtime Environment (build 20070329_01)
IBM J9 VM (build 2.4, J2RE 1.6.0 IBM J9 2.4 Linux x86-32 jvmxi3260-20070326_12091 (JIT enabled)
J9VM - 20070326_12091_lHdSMR
JIT  - dev_20070326_1800
GC   - 20070319_AA)</pre>


정확한 빌드 날짜 및 버전은 변경될 수 있습니다.</li></ol>
<p><font color="RED"><span id="changed">|</span>
<span id="changed">|</span><p>클래스 경로, 부트 클래스 경로 및 확장 디렉토리에서 사용 가능한
<span id="changed">|</span>모든 jar 파일의 버전 정보를 나열할 수도 있습니다. 다음 명령을
<span id="changed">|</span>입력하십시오.</p></p>
<span id="changed">|</span><pre class="xmp">java -Xjarversion</pre>
<span id="changed">|</span><p>다음과 같은 정보가 표시됩니다.</p>
<span id="changed">|</span><pre class="xmp">...
<span id="changed">|</span>/opt/ibm/java-i386-60/jre/lib/ext/ibmpkcs11impl.jar  VERSION: 1.0 build_20070125
<span id="changed">|</span>/opt/ibm/java-i386-60/jre/lib/ext/dtfjview.jar
<span id="changed">|</span>/opt/ibm/java-i386-60/jre/lib/ext/xmlencfw.jar  VERSION: 1.00, 20061011  LEVEL: -20061011
<span id="changed">|</span>
<span id="changed">|</span>...</pre>
<span id="changed">|</span><p>사용 가능한 정보는 각 jar 파일에 따라 다르며,
<span id="changed">|</span>jar 파일 Manifest의 Implementation-Version 및
<span id="changed">|</span>Build-Level 특성에서 가져옵니다.</p></font>
<a name="specifying_options"></a>
<h3 id="specifying_options"><a href="#ToC_31">Java 옵션 및 시스템 특성 지정</a></h3>
<div>
<p>명령행에서 옵션 파일 또는 환경 변수를 사용하여
Java 옵션 및
시스템 특성을 지정할 수 있습니다.</p></div>
<p>Java 옵션을 지정하는
메소드의 우선순위는 다음과 같습니다.</p>
<ol type="1">
<li>명령행에서 옵션 또는 특성을 지정하는 방법.  예를 들면 다음과 같습니다.

<pre class="xmp">java -Dmysysprop1=tcpip -Dmysysprop2=wait -Xdisablejavadump MyJavaClass</pre></li>
<li>옵션이 있는 파일을 작성하고 <strong>-Xoptionsfile=</strong><em>&lt;file&gt;</em>을 사용하여 명령행에서 지정하는 방법. </li>
<li>옵션을 포함하는 <strong>IBM_JAVA_OPTIONS</strong>라는 환경 변수를 작성하는 방법.  예를 들면 다음과 같습니다.

<pre class="xmp">export IBM_JAVA_OPTIONS="-Dmysysprop1=tcpip -Dmysysprop2=wait -Xdisablejavadump"</pre></li></ol>
<p>
<p>명령행의 맨 오른쪽 옵션은 맨 왼쪽 옵션보다 우선순위가 높습니다. 예를 들어, 다음과 같이 지정하는 경우가
있습니다.</p></p>
<pre class="xmp">java -Xint -Xjit myClass</pre>
<p>이 경우 <strong>-Xjit</strong> 옵션이 우선순위가 높습니다.</p>
<a name="standard_options"></a>
<h3 id="standard_options"><a href="#ToC_32">표준 옵션</a></h3>
<div>
<p>표준 옵션의 정의.</p></div><a id="idx12" name="idx12"></a><a id="idx13" name="idx13"></a><a id="idx14" name="idx14"></a><a id="idx15" name="idx15"></a><a id="idx16" name="idx16"></a><a id="idx17" name="idx17"></a><a id="idx18" name="idx18"></a><a id="idx19" name="idx19"></a><a id="idx20" name="idx20"></a><a id="idx21" name="idx21"></a><a id="idx22" name="idx22"></a><a id="idx23" name="idx23"></a><a id="idx24" name="idx24"></a><a id="idx25" name="idx25"></a><a id="idx26" name="idx26"></a>
<p></p>
<dl class="parml">
<dt class="bold"><strong>-agentlib</strong>:<em>&lt;libname&gt;</em>[=<em>&lt;options&gt;</em>]</dt>
<dd>원시 에이전트 라이브러리 <em>&lt;libname&gt;</em>을 로드합니다(예: <strong>-agentlib:hprof</strong>).
 자세한 정보를 보려면 명령행에
<strong>-agentlib:jdwp=help</strong> 및 <strong>-agentlib:hprof=help</strong>를 입력하십시오.
</dd>
<dt class="bold"><strong>-agentpath</strong>:<em>libname</em>[=<em>&lt;options&gt;</em>]</dt>
<dd>전체 경로 이름별로 원시 에이전트 라이브러리를 로드합니다.
</dd>
<dt class="bold"><strong>-cp</strong> <em>&lt;</em>:으로 구분되는 디렉토리 및 zip 또는 jar 파일<em>&gt;</em></dt>
<dd>응용프로그램 클래스 및 자원의 탐색 경로를 설정합니다. <strong>-classpath</strong> 및
<strong>-cp</strong>가 사용되지 않고 <strong>CLASSPATH</strong> 환경 변수가 설정되지 않은 경우,
기본적으로 사용자 클래스 경로는 현재 디렉토리(.)입니다.
</dd>
<dt class="bold"><strong>-classpath</strong> <em>&lt;</em>:으로 구분되는 디렉토리 및 zip 또는 jar 파일<em>&gt;</em></dt>
<dd>응용프로그램 클래스 및 자원의 탐색 경로를 설정합니다. <strong>-classpath</strong> 및
<strong>-cp</strong>가 사용되지 않고 <strong>CLASSPATH</strong> 환경 변수가 설정되지 않은 경우,
기본적으로 사용자 클래스 경로는 현재 디렉토리(.)입니다.
</dd>
<dt class="bold"><strong>-D</strong><em>&lt;property name&gt;</em>=<em>&lt;value&gt;</em></dt>
<dd>시스템 특성을 설정합니다.
</dd>
<dt class="bold"><strong>-help 또는 -?</strong></dt>
<dd>사용법 메시지를 인쇄합니다.
</dd>
<dt class="bold"><strong>-javaagent</strong>:<em>&lt;jarpath&gt;</em>[=<em>&lt;options&gt;</em>] </dt>
<dd>Java 프로그래밍 언어
에이전트를 로드합니다. 자세한 정보는 java.lang.instrument API 문서를 참조하십시오.
</dd>
<dt class="bold"><strong>-jre-restrict-search</strong></dt>
<dd>버전 검색에 사용자 개인용 JRE를 포함합니다.
</dd>
<dt class="bold"><strong>-no-jre-restrict-search</strong></dt>
<dd>버전 검색에서 사용자 개인용 JRE를 제외합니다.
</dd>
<dt class="bold"><strong>-showversion</strong></dt>
<dd>제품 버전을 인쇄하고 계속 진행합니다.
</dd>
<dt id="standard_options__verbose" class="bold">
<a name="standard_options__verbose"></a><strong>-verbose</strong>:<em>&lt;option&gt;</em></dt>
<dd>상세 출력을 사용합니다. 사용 가능한 옵션은 다음과 같습니다. 

<dl class="parml">
<dt class="bold"><strong>class</strong></dt>
<dd>로드한 각 클래스의 stderr에 항목을 기록합니다.
</dd>
<dt class="bold"><strong>gc</strong></dt>
<dd>stderr에 상세 가비지 콜렉션 정보를 기록합니다. 출력을 제어하려면
<a href="#xoptions__xverbosegclog"><strong>-Xverbosegclog</strong></a>를 사용하십시오. 자세한 정보는 <a href="http://www.ibm.com/developerworks/java/jdk/diagnosis/60.html" target="_blank"> 진단 안내서</a>를 참조하십시오.
</dd>
<dt class="bold"><strong>jni</strong></dt>
<dd>응용프로그램 및 JVM에서 호출된 JNI 서비스를 설명하는 정보를 stderr에 기록합니다.
</dd>
<dt class="bold"><strong>sizes</strong></dt>
<dd>활성 메모리 사용량 설정을 설명하는 정보를 stderr에 기록합니다.
</dd>
<dt class="bold"><strong>stack</strong></dt>
<dd>각 스레드의 Java 및
C 스택 사용량을 설명하는 정보를 stderr에 기록합니다.
</dd>
</dl>
</dd>
<dt class="bold"><strong>-version</strong></dt>
<dd>제품 버전을 인쇄합니다. 
</dd>
<dt class="bold"><strong>-version</strong>:<em>&lt;value&gt;</em></dt>
<dd>실행하려면 지정된 버전(예: 『1.5』)이 필요합니다.
</dd>
<dt class="bold"><strong>-X</strong></dt>
<dd>비표준 옵션에 대한 도움말을 인쇄합니다.
</dd>
</dl>
<a name="globalization"></a>
<h3 id="globalization"><a href="#ToC_33">java 명령의 글로벌화</a></h3>
<div>
<p>java 및 javaw 실행기에서는
현재 로케일의 문자 세트에 있는 모든 문자를 포함하는 인수 및 클래스 이름을
사용할 수 있습니다. 또한 Java 이스케이프 시퀀스를 사용하여
클래스 이름 및 인수에 Unicode 문자를 지정할 수 있습니다.</p></div>
<p>이 작업을 수행하려면 <strong>-Xargencoding</strong> 명령행 옵션을 사용하십시오.</p>
<dl class="parml">
<dt class="bold"><strong>-Xargencoding</strong></dt>
<dd>인수 인코딩을 사용합니다. Unicode 문자를 지정하려면 <tt>\u####</tt> 형식의 이스케이프 시퀀스를 사용하십시오. 여기서
#는 16진 숫자(0 - 9, A - F)입니다.
</dd>
<dt class="bold"><strong>-Xargencoding:utf8</strong></dt>
<dd>UTF8 인코딩을 사용합니다.
</dd>
<dt class="bold"><strong>-Xargencoding:latin</strong></dt>
<dd>ISO8859_1 인코딩을 사용합니다.
</dd>
</dl>
<p>예를 들어, 두 대문자에 대해 Unicode 인코딩을 사용하여 HelloWorld라는 클래스를 지정하려면
다음 명령을 사용하십시오.</p>
<pre class="xmp">java -Xargencoding '\u0048ello\u0057orld'</pre>
<p>java 및 javaw 명령은 변환된 메시지를
제공합니다. 이러한 메시지는 Java를 실행 중인
로케일에 따라 다릅니다. java가 리턴하는 자세한 오류 설명 및 기타 디버그 정보는
영어로 되어 있습니다.</p>
<a name="jit"></a>
<h2 id="jit"><a href="#ToC_34">JIT(just-in-time) 컴파일러</a></h2>
<div>
<p>IBM JIT(just-in-time) 컴파일러는
Java 응용프로그램 및 애플릿이
실행될 때 자주 사용되는 바이트 코드 시퀀스의 시스템 코드를 동적으로 생성합니다. <span>JIT
v6 컴파일러는
새로운 최적화를 제공하여 JIT의 이전 버전에서 구현된 최적화를 개선하고 더 나은 하드웨어 환경을 제공합니다. </span></p></div><a id="idx27" name="idx27"></a><a id="idx28" name="idx28"></a><a id="idx29" name="idx29"></a><a id="idx30" name="idx30"></a><a id="idx31" name="idx31"></a>
<p>IBM SDK 및
Runtime Environment 모두에 JIT가 있으며, 사용자 응용프로그램 및 SDK 도구에서 기본적으로
사용할 수 있습니다. 일반적으로 JIT를 명시적으로 호출할 필요는 없습니다.
Java 바이트 코드에서 시스템 코드로의 컴파일은
투명하게 발생합니다.
JIT를 사용 불가능으로 설정하면 문제점을 찾는 데 도움이 됩니다. Java 응용프로그램 또는 애플릿을 실행할 때
문제점이 발생하는 경우 JIT를 사용 불가능으로 설정하면 문제점을 찾는 데 도움이 됩니다. JIT를 사용 불가능으로 설정하는 방법은 임시 수단일 뿐이며, JIT의 성능을 최적화해야 합니다.</p>
<p>JIT에 대한 자세한 정보는 <a href="http://www.ibm.com/developerworks/java/jdk/diagnosis/60.html" target="_blank">진단 안내서</a>를 참조하십시오.</p>
<a name="disjit"></a>
<h3 id="disjit"><a href="#ToC_35">JIT 사용 안함</a></h3>
<div>
<p>JIT를 사용하지 않도록 설정하는 방법에는 여러 가지가 있습니다. 두 명령행 옵션 모두 <strong>JAVA_COMPILER</strong> 환경 변수를 재지정합니다.</p></div>
<p>JIT를 사용하지 않는 것은 Java 응용프로그램을
디버그할 때 문제점을 분리하는 데 도움이 되는 임시 기능입니다.</p>
<ul>
<li><strong>JAVA_COMPILER</strong> 환경 변수를 <tt>NONE</tt> 또는 빈 문자열로 설정한 후
java 응용프로그램을 실행하십시오.  쉘 프롬프트에서 다음을 입력하십시오.

<pre class="xmp">    export JAVA_COMPILER=NONE</pre></li>
<li>JVM 명령행에서 <strong>-D</strong> 옵션을 사용하여
<strong>java.compiler</strong> 특성을 <tt>NONE</tt> 또는 빈 문자열로 설정하십시오.  쉘 프롬프트에서 다음을 입력하십시오.

<pre class="xmp">java -Djava.compiler=NONE <em>&lt;class&gt;</em></pre></li>
<li>JVM 명령행에서 <strong>-Xint</strong> 옵션을 사용하십시오.  쉘 프롬프트에서 다음을 입력하십시오.

<pre class="xmp">java -Xint <em>&lt;class&gt;</em></pre></li></ul>
<a name="enajit"></a>
<h3 id="enajit"><a href="#ToC_36">JIT 사용</a></h3>
<div>
<p>기본적으로 JIT는 사용 가능합니다. 여러 가지 방법으로 JIT를 명시적으로
사용할 수 있습니다. 두 명령행 옵션 모두 <strong>JAVA_COMPILER</strong> 환경 변수를 재지정합니다.</p></div>
<ul>
<li><strong>JAVA_COMPILER</strong> 환경 변수를 <tt>jitc</tt>로 설정한 후
Java 응용프로그램을 실행하십시오.  쉘 프롬프트에서 다음을 입력하십시오.

<pre class="xmp">export JAVA_COMPILER=jitc</pre> <strong>JAVA_COMPILER</strong> 환경 변수가 빈 문자열인 경우 JIT는 그대로 사용되지 않습니다. 환경 변수를
사용하지 않으려면 쉘 프롬프트에서 다음을 입력하십시오.


<pre class="xmp">unset JAVA_COMPILER</pre></li>
<li>JVM 명령행에서 <strong>-D</strong> 옵션을 사용하여
<strong>java.compiler</strong> 특성을 <tt>jitc</tt>로 설정하십시오.  쉘 프롬프트에서 다음을 입력하십시오.

<pre class="xmp">java -Djava.compiler=jitc <em>&lt;class&gt;</em></pre></li>
<li>JVM 명령행에서 <strong>-Xjit</strong> 옵션을 사용하십시오.  <strong>-Xint</strong> 옵션을 동시에 지정하지 <strong>마십시오</strong>.  쉘 프롬프트에서 다음을 입력하십시오.

<pre class="xmp">java -Xjit <em>&lt;class&gt;</em></pre></li></ul>
<a name="detjit"></a>
<h3 id="detjit"><a href="#ToC_37">JIT가 사용 가능한지 여부 판별</a></h3>
<div>
<p><strong>-version</strong> 옵션을 사용하여 JIT의 상태를 판별할 수 있습니다.</p></div><a id="idx32" name="idx32"></a><a id="idx33" name="idx33"></a>
<p><strong>-version</strong> 옵션으로 java 실행기를 실행하십시오.
쉘 프롬프트에서 다음을 입력하십시오.  </p>
<pre class="xmp">    java -version</pre> 
<p>JIT가 사용되고 있지 않으면 다음이 포함된 메시지가 표시됩니다.</p>

<pre class="xmp">(JIT disabled)</pre>

<p>JIT가 사용되고 있으면 다음이 포함된 메시지가 표시됩니다.</p>

<pre class="xmp">(JIT enabled)</pre>
<p>JIT에 대한 자세한 정보는 <a href="http://www.ibm.com/developerworks/java/jdk/diagnosis/60.html" target="_blank">진단 안내서</a>를 참조하십시오.</p>
<a name="garbage"></a>
<h2 id="garbage"><a href="#ToC_38">가비지 콜렉션 정책 지정</a></h2>
<div>
<p>가비지 콜렉터는 JVM에서 실행 중인 응용프로그램 및 Java에서 사용한
메모리를 관리합니다.</p></div><a id="idx34" name="idx34"></a>
<p>가비지 콜렉터가 저장영역에 대한 요청을 수신하는 경우, 힙에서 사용되지 않은 메모리가 "할당"이라는 프로세스에서
따로 설정됩니다. 가비지 콜렉터는 또한 메모리 영역이 더 이상 참조되지 않도록 하고 재사용을 위해 해제합니다. 이를 "콜렉션"이라고 합니다.</p>
<p>콜렉션 단계는 저장영역 요청에 대해 남은 공간이 없는 경우 발생하는 메모리 할당 결함 또는 명시적인
System.gc() 호출로 인해 트리거됩니다.</p>
<p>가비지 콜렉션은 응용프로그램의 성능에 상당한 영향을 미칠 수 있으므로
IBM 가상 시스템은
가비지 콜렉션을 수행하는 방법을 최적화하는 다양한 메소드를 제공하여 잠재적으로 응용프로그램에 대한 영향을 줄입니다.</p>
<p>가비지 콜렉션에 대한 자세한 정보는 <a href="http://www.ibm.com/developerworks/java/jdk/diagnosis/60.html" target="_blank">진단 안내서</a>를 참조하십시오.</p>
<a name="garbage_options"></a>
<h3 id="garbage_options"><a href="#ToC_39">가비지 콜렉션 옵션</a></h3>
<div>
<p><strong>-Xgcpolicy</strong> 옵션은 가비지 콜렉터의 동작을 제어합니다. 이 옵션은
응용프로그램 및 전체 시스템의 처리량과 가비지 콜렉션으로 인한 일시 정지 시간 사이의 균형을 맞춥니다.</p></div><a id="idx35" name="idx35"></a><a id="idx36" name="idx36"></a><a id="idx37" name="idx37"></a>
<p>
<p>옵션 및 해당 값의 형식은 다음과 같습니다. 
</p>
<dl class="parml">
<dt class="bold"><strong>-Xgcpolicy:optthruput</strong></dt>
<dd>(기본값 및 권장 값) 매우 많은 처리량이 응용프로그램으로 전달되지만 종종 일시정지됩니다.
</dd>
<dt class="bold"><strong>-Xgcpolicy:optavgpause</strong></dt>
<dd>가비지 콜렉션의 일시정지 시간을 줄이고 가비지 콜렉션 일시정지 시간에 대한
힙 크기 증가의 영향을 제한합니다. 구성에 매우 큰 힙이 있는 경우에는 <strong>optavgpause</strong>를
사용하십시오.
</dd>
<dt class="bold"><strong>-Xgcpolicy:gencon</strong></dt>
<dd>동시 및 세대별 GC를 결합하여 사용하도록 요청하여 가비지 콜렉션 일시정지 시간을 최소화합니다.
</dd>
<dt class="bold"><strong>-Xgcpolicy:subpool</strong></dt>
<dd>(PPC 및 zSeries에만 해당) 개선된
오브젝트 할당 알고리즘을 사용하여 힙에 오브젝트를 할당할 때 성능이
향상됩니다. 이 옵션을 통해 대규모 SMP 시스템의 성능을 향상시킬 수 있습니다.
</dd>
</dl></p>
<a name="garbage_pause"></a>
<h3 id="garbage_pause"><a href="#ToC_40">일시정지 시간</a></h3>
<div>
<p>오브젝트를 작성하려는 응용프로그램의 시도가 힙의 사용 가능한 공간에서 즉시 충족되지 않는 경우,
가비지 콜렉터는 참조되지 않는 오브젝트(가비지)를 식별하고 삭제하여, 즉각적이며 계속적인 할당 요청을 신속하게 충족시킬 수 있는
상태로 힙을 되돌립니다.</p></div><a id="idx38" name="idx38"></a><a id="idx39" name="idx39"></a>
<p>이러한 가비지 콜렉션 주기로 인해 때때로
응용프로그램 코드의 실행에 있어서 예상치 않았던 일시정지가 발생하기도
합니다.  응용프로그램의 크기와 복잡도가 증가함에 따라 힙도 더 커지게 되므로,
이러한 가비지 콜렉션 일시정지 시간도 크기 및 중요성이 증가하는 경향이 있습니다.</p>
<p>가비지 콜렉션
기본값인 <strong>-Xgcpolicy:optthruput</strong>은 응용프로그램에
매우 많은 처리량을 부과하나 그로 인해 때때로 일시정지될 수 있으며
일시정지 시간은 힙의 크기와 가비지의 양에 따라 밀리 초에서 수 초까지 다양합니다.</p>
<a name="pausetimereduction"></a>
<h3 id="pausetimereduction"><a href="#ToC_41">일시정지 시간 단축</a></h3>
<div>
<p>JVM은 동시 가비지 콜렉션과 세대별 가비지 콜렉션의 두 가지 기술을 사용하여 일시정지 시간을 단축합니다.</p></div><a id="idx40" name="idx40"></a><a id="idx41" name="idx41"></a>
<p><strong>-Xgcpolicy:optavgpause</strong> 명령행 옵션은
동시 가비지 콜렉션 사용을 요청하여 가비지 콜렉션 일시정지 시간을
대폭 줄입니다. 동시 GC는 일부 가비지 콜렉션 활동을 정상적인 프로그램 실행과
동시에 수행하여 힙 콜렉션으로 인한 중단을 최소화함으로써 일시정지 시간을
감소시킵니다. 또한 <strong>-Xgcpolicy:optavgpause</strong> 옵션은 가비지 콜렉션
일시정지 길이에 대한 힙 크기 증가에 따른 영향을 제한합니다.
<strong>-Xgcpolicy:optavgpause</strong> 옵션은 대형 힙이 사용된 구성에서
가장 유용합니다. 그러나 일시정지 시간이 감소되면
응용프로그램의 처리량도 감소할 수 있습니다.</p>
<p>동시 가비지 콜렉션에서는 수집할 수 없는 비교적 오래된 오브젝트를 식별하는 데
상당한 시간이 소요됩니다. 가비지 콜렉션이 재활용 가능성이 높은 오브젝트에만 집중하면
일부 응용프로그램의 일시정지 시간을 더욱 단축할 수 있습니다.
세대별 GC는 힙을 "nursery"와 "tenure" 영역의 두 "세대"로 나누어서
일시정지 시간을 단축합니다. 오브젝트는 연령에 따라 두 영역 중 하나에
속합니다. nursery 영역은 둘 중 더 작은 규모이고 최근의 오브젝트를 포함합니다.
tenure는 더 크고 오래된 오브젝트를 포함합니다. 오브젝트는 처음에
nursery에 할당되며 nursery에서 오래 남아 있게 되면 tenure 영역으로
승격됩니다.</p>
<p>세대별 GC는 대부분 오래 지속되지 않는 오브젝트에 의존합니다. 세대별
GC는 nursery에 가장 많은 재활용 공간이 있기 때문에 이 저장영역을 반환하는
노력에 집중하여 일시정지 시간을 줄입니다. 전체
힙 수집에는 비교적 긴 일시정지 시간이 필요하므로 nursery는
수집을 더 자주 수행하며, nursery가 작으면 일시정지 시간도 그만큼
짧아집니다. 단, 세대별 GC의 경우 시간이 지날수록 많은 오브젝트가
너무 오래 지속되어 tenure가 가득 찰 수 있다는 결점이 있습니다. 이러한
경우 일시정지 시간을 최소화하려면 동시 GC 및
세대별 GC를 함께 사용하십시오. <strong>-Xgcpolicy:gencon</strong> 옵션은
동시 및 세대별 GC를 함께 사용하여 가비지 콜렉션의 일시정지 시간을
최소화합니다.</p>
<a name="garbage_full_heap"></a>
<h3 id="garbage_full_heap"><a href="#ToC_42">힙이 가득 찬 환경</a></h3>
<div>
<p>Java 힙이 거의
가득 차서 재생할 수 있는 가비지가 거의 없는 경우, 새 오브젝트를 요청하면
즉시 사용할 수 있는 공간이 없으므로 빠르게 충족되지 않습니다.</p></div><a id="idx42" name="idx42"></a><a id="idx43" name="idx43"></a>
<p>힙이 용량이 거의 가득 찬 상태로 작동하는 경우, 사용되는 가비지 콜렉션 옵션에
관계 없이 응용프로그램 성능은 저하됩니다. 더 많은 힙 공간을 계속 작성해야 하는 경우
응용프로그램은 OutOfMemoryError를 수신할 수 있으며 예외가 발생하여
처리되지 않는 경우 JVM이 종료됩니다. 이 때 JVM은 진단에 사용할 Javadump 파일을
생성합니다. 이러한 조건에서는 <strong>-Xmx</strong> 옵션을 사용하여 힙 크기를 늘리거나 사용 중인 오브젝트의 수를
줄일 것을 권장합니다.</p>
<p> 자세한 정보는 <a href="http://www.ibm.com/developerworks/java/jdk/diagnosis/60.html" target="_blank"> 진단 안내서</a>를 참조하십시오.</p>
<a name="euro_symbol"></a>
<h2 id="euro_symbol"><a href="#ToC_43">Euro 기호 지원</a></h2>
<div>
<p>IBM
SDK 및 Runtime Environment는
유럽통화동맹(EMU)에 속한 국가의 기본 통화를 2002년 1월 1일부터 Euro로 설정합니다. <span>2008년
1월 1일부터 키프로스 및 몰타에서도 기본 통화로 Euro를 사용합니다. </span></p></div>
<p>기존의 국가별 통화를 사용하려면 Java 명령행에서
<strong>-Duser.variant=PREEURO</strong>을 지정하십시오.</p>
<p>영어(영국), 덴마크어 또는 스웨덴어 로케일을 실행 중이며 Euro를 사용하려는 경우,
Java 명령행에서
<strong>-Duser.variant=EURO</strong>을 지정하십시오.</p>
<a name="fallback_font"></a>
<h2 id="fallback_font"><a href="#ToC_44">대체 글꼴 구성 파일</a></h2>
<div>
<p>Linux
대체 글꼴 구성 파일(fontconfig.RedHat.bfc 및 fontconfig.SuSE.bfc)은
 새로운 엔터프라이즈인
Linux 배포판에 적합한
글꼴 설정을 제공하기 위해  설치됩니다.</p></div>
<p>이러한 파일은 단지 편의상 제공됩니다. 해당 파일은 새
Linux 배포판이
IBM SDK and Runtime Environment for Linux, Java Technology
Edition, 버전 6에 지원되는 플랫폼이라는 것을 의미하지 않습니다.</p><font color="RED"><span id="changed">|</span>
<span id="changed">|</span><a name="input_method_extensions"></a>
<span id="changed">|</span><h2 id="input_method_extensions"><a href="#ToC_45">인도어 및 태국어 입력 메소드 사용</a></h2>
<span id="changed">|</span><div>
<span id="changed">|</span><p>버전 6부터 인도어 및 태국어 메소드는 기본적으로 사용할 수 없습니다. 인도어 및 태국어 입력 메소드를
<span id="changed">|</span>사용하려면 해당 입력 메소드 jar 파일을
<span id="changed">|</span>Java 확장 경로에
<span id="changed">|</span>수동으로 포함시켜야 합니다.</p></div>
<span id="changed">|</span><p>버전 5.0에서 해당 입력 메소드 jar 파일은
<span id="changed">|</span><a name="input_method_extensions__ext"></a><span id="input_method_extensions__ext">jre/lib/ext</span> 디렉토리에
<span id="changed">|</span>있으며 JVM이 자동으로 로드했습니다. 버전 6에서 해당 입력 메소드 jar 파일은
<span id="changed">|</span><a name="input_method_extensions__im"></a><span id="input_method_extensions__im">jre/lib/im</span>
<span id="changed">|</span>디렉토리에 있으며, 인도어 및 태국어 입력 메소드를 사용하려면 Java 확장 경로에
<span id="changed">|</span>수동으로 추가해야 합니다. 수동으로 추가하려면 다음 중 한 가지 방법을 사용하십시오.</p>
<span id="changed">|</span><ul>
<span id="changed">|</span><li>indicim.jar 및 thaiim.jar 파일을
<span id="changed">|</span>jre/lib/im 디렉토리에서
<span id="changed">|</span>jre/lib/ext 디렉토리로 복사하십시오. </li>
<span id="changed">|</span><li>확장 디렉토리 시스템 특성에 jre/lib/im 디렉토리를 추가하십시오.  다음 명령행 옵션을 사용하십시오.
<span id="changed">|</span>
<span id="changed">|</span><pre class="xmp">java -Djava.ext.dirs=/opt/ibm/java-i386-60/jre/lib/ext:/opt/ibm/java-i386-60/jre/lib/im <em>&lt;class&gt;</em></pre></li></ul>
<span id="changed">|</span><p>
<span id="changed">|</span><p>SDK 또는 Runtime Environment를
<span id="changed">|</span>다른 디렉토리에 설치한 경우, /opt/ibm/java-i386-60/을
<span id="changed">|</span>SDK 또는 Runtime Environment를 설치한 디렉토리로 바꾸십시오.</p></p></font>
<a name="developing"></a>
<h1 id="developing"><a href="#ToC_46">SDK를 사용하여
Java 응용프로그램 개발</a></h1>
<div>
<p>SDK for Linux에는
Java 소프트웨어 개발에 필요한 다수의 도구 및 라이브러리가 포함되어 있습니다.</p></div>
<p> 사용 가능한 도구에 대한 자세한 정보는 <a href="#sdktools">SDK 도구 및 참조 정보</a>의
내용을 참조하십시오.</p><font color="RED"><span id="changed">|</span>
<span id="changed">|</span><a name="xml_using"></a>
<span id="changed">|</span><h2 id="xml_using"><a href="#ToC_47">XML 사용</a></h2>
<span id="changed">|</span><div>
<span id="changed">|</span><p>IBM SDK에는 XML4J 및
<span id="changed">|</span>XL XP-J 구문 분석기, XL TXE-J 1.0 XSLT 컴파일러와 XSLT4J XSLT 해석기가 포함되어 있습니다.
<span id="changed">|</span>이러한 도구를 사용하면 제공된 XML 처리 구현과는 독립적으로 XML 문서를
<span id="changed">|</span>구문 분석, 유효성 검증, 변환 및 직렬화할 수 있습니다.</p></div><a id="idx44" name="idx44"></a><a id="idx45" name="idx45"></a>
<span id="changed">|</span><p>
<span id="changed">|</span><p> <a href="#xml_using__select_processor">XML 프로세서 선택</a>에서 설명한 대로 추상 팩토리 클래스 구현을 찾으려면
<span id="changed">|</span>팩토리 찾기 프로그램을 사용하십시오.
<span id="changed">|</span>팩토리 찾기 프로그램을 사용하여 Java 코드를
<span id="changed">|</span>변경하지 않고 다른 XML 라이브러리를 선택할 수 있습니다.</p></p>
<span id="changed">|</span><p>
<span id="changed">|</span><a name="wq40"></a>
<span id="changed">|</span><h3 id="wq40">사용 가능한 XML 라이브러리</h3>
<span id="changed">|</span><p>IBM SDK for Java에는 다음 XML 라이브러리가 있습니다.</p></p>
<span id="changed">|</span><dl>
<span id="changed">|</span><dt class="bold">XML4J 4.5</dt>
<span id="changed">|</span><dd>
<span id="changed">|</span><p>XML4J는 다음 표준을 지원하는 유효성을 검증하는 구문 분석기입니다. 
<span id="changed">|</span></p>
<span id="changed">|</span><ul>
<span id="changed">|</span><li>XML 1.0(제4판)</li>
<span id="changed">|</span><li>Namespaces in XML 1.0(제2판)</li>
<span id="changed">|</span><li>XML 1.1(제2판)</li>
<span id="changed">|</span><li>Namespaces in XML 1.1(제2판)</li>
<span id="changed">|</span><li>W3C XML Schema 1.0(제2판)</li>
<span id="changed">|</span><li>XInclude 1.0(제2판)</li>
<span id="changed">|</span><li>OASIS XML Catalogs 1.0</li>
<span id="changed">|</span><li>SAX 2.0.2</li>
<span id="changed">|</span><li>DOM Level 3 Core, Load and Save</li>
<span id="changed">|</span><li>DOM Level 2 Core, Events, Traversal and Range</li>
<span id="changed">|</span><li>JAXP 1.4</li></ul>
<span id="changed">|</span>
<span id="changed">|</span><p>XML4J 4.5는 Apache Xerces-J 2.9.0을 기반으로 합니다. 자세한 정보는 웹 사이트 <a href="http://xerces.apache.org/xerces2-j/" target="_blank">http://xerces.apache.org/xerces2-j/</a>를 참조하십시오.</p>
<span id="changed">|</span></dd>
<span id="changed">|</span><dt class="bold">XL XP-J 1.1</dt>
<span id="changed">|</span><dd>
<span id="changed">|</span><p>XL XP-J 1.1은 유효성을 검증하지 않는 고성능의 구문 분석기로서
<span id="changed">|</span>StAX 1.0(JSR 173), XML 1.0 및 XML 1.1 문서의 pull-parsing 및 스트림 직렬화를 위한
<span id="changed">|</span>양방향 API를 지원합니다. XL XP-J 1.1에서 지원하는 내용에 대한 자세한 정보는
<span id="changed">|</span><a href="#xlxpj_reference">XL XP-J 참조 정보</a>를 참조하십시오.</p>
<span id="changed">|</span></dd>
<span id="changed">|</span><dt class="bold">XL TXE-J 1.0.1 베타</dt>
<span id="changed">|</span><dd>
<span id="changed">|</span><p>버전 5.0의 경우 IBM SDK for Java에는 XSLT4J 컴파일러 및 해석기가 포함되었습니다.
<span id="changed">|</span>XSLT4J 해석기는 기본적으로 사용되었습니다.</p>
<span id="changed">|</span>
<span id="changed">|</span><p>버전 6의 경우 IBM SDK for Java에는
<span id="changed">|</span>XL TXE-J가 포함되어 있습니다. XL TXE-J에는 XSLT4J 2.7.8 해석기 및 새 XSLT 컴파일러가 포함되어 있습니다.
<span id="changed">|</span>새 컴파일러가 기본적으로 사용됩니다. XSLT4J 컴파일러는 더 이상
<span id="changed">|</span>IBM SDK
<span id="changed">|</span>for Java에 포함되지 않습니다.
<span id="changed">|</span>XL TXE-J 이주에 대한 정보는 <a href="#xslt_migration_steps">XL-TXE-J로 이주</a>를 참조하십시오.</p>
<span id="changed">|</span>
<span id="changed">|</span><p>XL TXE-J는 다음 표준을 지원합니다. 
<span id="changed">|</span></p>
<span id="changed">|</span><ul>
<span id="changed">|</span><li>XSLT 1.0</li>
<span id="changed">|</span><li>XPath 1.0</li>
<span id="changed">|</span><li>JAXP 1.4</li></ul>
<span id="changed">|</span></dd>
<span id="changed">|</span></dl>
<span id="changed">|</span><p>
<span id="changed">|</span><a name="xml_using__select_processor"></a>
<span id="changed">|</span><h3 id="xml_using__select_processor">XML 프로세서 선택</h3>
<span id="changed">|</span><p>XML 프로세서 선택은 서비스 제공자를 사용하여 수행됩니다. 팩토리 찾기 프로그램을 사용하는 경우,
<span id="changed">|</span>Java에서는 사용할 서비스 제공자를 다음 위치에서 찾습니다. 
<span id="changed">|</span></p>
<span id="changed">|</span><ol type="1">
<span id="changed">|</span><li>서비스 제공자와 동일한 이름의 시스템 특성</li>
<span id="changed">|</span><li><strong>XMLEventFactory, XMLInputFactory
<span id="changed">|</span>및 XMLOutputFactory의 경우:</strong> /opt/ibm/java-i386-60/jre/lib/stax.properties 파일에서 서비스 제공자의 값</li>
<span id="changed">|</span><li><strong>기타 팩토리의 경우:</strong> /opt/ibm/java-i386-60/jre/lib/jaxp.properties 파일에서 서비스 제공자의 값</li>
<span id="changed">|</span><li>META-INF/services/&lt;service.provider&gt;
<span id="changed">|</span>파일의 내용</li>
<span id="changed">|</span><li>기본 서비스 제공자</li></ol>
<span id="changed">|</span><p>다음 서비스 제공자는
<span id="changed">|</span>Java에서 사용하는 XML 처리 라이브러리를 제어합니다. 
<span id="changed">|</span></p>
<span id="changed">|</span><dl class="parml">
<span id="changed">|</span><dt class="bold"><strong>javax.xml.parsers.SAXParserFactory</strong></dt>
<span id="changed">|</span><dd>SAX 구문 분석기를 선택합니다. 기본적으로 XML4J 라이브러리의 org.apache.xerces.jaxp.SAXParserFactoryImpl이 사용됩니다.
<span id="changed">|</span></dd>
<span id="changed">|</span><dt class="bold"><strong>javax.xml.parsers.DocumentBuilderFactory</strong></dt>
<span id="changed">|</span><dd>문서 빌더를 선택합니다. 기본적으로 XML4J 라이브러리의 org.apache.xerces.jaxp.DocumentBuilderFactoryImpl이 사용됩니다.
<span id="changed">|</span></dd>
<span id="changed">|</span><dt class="bold"><strong>javax.xml.datatype.DatatypeFactory</strong></dt>
<span id="changed">|</span><dd>데이터 유형 팩토리를 선택합니다. 기본적으로 XML4J 라이브러리의 org.apache.xerces.jaxp.datatype.DatatypeFactoryImpl이
<span id="changed">|</span>사용됩니다.
<span id="changed">|</span></dd>
<span id="changed">|</span><dt class="bold"><strong>javax.xml.stream.XMLEventFactory</strong></dt>
<span id="changed">|</span><dd>StAX 이벤트 팩토리를 선택합니다. 기본적으로 XL XP-J 라이브러리의 com.ibm.xml.xlxp.api.stax.XMLEventFactoryImpl이
<span id="changed">|</span>사용됩니다.
<span id="changed">|</span></dd>
<span id="changed">|</span><dt class="bold"><strong>javax.xml.stream.XMLInputFactory</strong></dt>
<span id="changed">|</span><dd>StAX 구문 분석기를 선택합니다. 기본적으로 XL XP-J 라이브러리의 com.ibm.xml.xlxp.api.stax.XMLInputFactoryImpl이
<span id="changed">|</span>사용됩니다.
<span id="changed">|</span></dd>
<span id="changed">|</span><dt class="bold"><strong>javax.xml.stream.XMLOutputFactory</strong></dt>
<span id="changed">|</span><dd>StAX 직렬 프로그램을 선택합니다. 기본적으로 XL XP-J 라이브러리의 com.ibm.xml.xlxp.api.stax.XMLOutputFactoryImpl이
<span id="changed">|</span>사용됩니다.
<span id="changed">|</span></dd>
<span id="changed">|</span><dt class="bold"><strong>javax.xml.transform.TransformerFactory</strong></dt>
<span id="changed">|</span><dd>XSLT 프로세서를 선택합니다. 가능한 값은 다음과 같습니다. 
<span id="changed">|</span>
<span id="changed">|</span><dl class="parml">
<span id="changed">|</span><dt class="bold">com.ibm.xtq.xslt.jaxp.compiler.TransformerFactoryImpl</dt>
<span id="changed">|</span><dd>XL TXE-J 컴파일러를 사용합니다. 기본값입니다.
<span id="changed">|</span></dd>
<span id="changed">|</span><dt class="bold">org.apache.xalan.processor.TransformerFactoryImpl</dt>
<span id="changed">|</span><dd>XSLT4J 해석기를 사용합니다.
<span id="changed">|</span></dd>
<span id="changed">|</span></dl>
<span id="changed">|</span></dd>
<span id="changed">|</span><dt class="bold"><strong>javax.xml.validation.SchemaFactory:http://www.w3.org/2001/XMLSchema</strong></dt>
<span id="changed">|</span><dd>W3C XML 스키마 언어의 스키마 팩토리를 선택합니다. 기본적으로 XML4J 라이브러리의 org.apache.xerces.jaxp.validation.XMLSchemaFactory가
<span id="changed">|</span>사용됩니다.
<span id="changed">|</span></dd>
<span id="changed">|</span><dt class="bold"><strong>javax.xml.xpath.XPathFactory</strong></dt>
<span id="changed">|</span><dd>XPath 프로세서를 선택합니다. 기본적으로 XSLT4J 라이브러리의 org.apache.xpath.jaxp.XPathFactoryImpl이 사용됩니다.
<span id="changed">|</span></dd>
<span id="changed">|</span></dl></p>
<span id="changed">|</span><a name="xslt_migration_steps"></a>
<span id="changed">|</span><h3 id="xslt_migration_steps"><a href="#ToC_50">XL-TXE-J로 이주</a></h3>
<span id="changed">|</span><div>
<span id="changed">|</span><p>XL TXE-J 컴파일러는 XSLT4J 해석기를 기본
<span id="changed">|</span>XSLT 프로세서로 대체했습니다. 새 라이브러리에 맞게 응용프로그램을 준비하려면 다음 단계를
<span id="changed">|</span>수행하십시오.</p></div>
<span id="changed">|</span><p>
<span id="changed">|</span><p>같은 변환을 두 번 이상 적용하려면 XL TXE-J 컴파일러가 XSLT4J 해석기보다
<span id="changed">|</span>빠릅니다. 각각의 개별 변환을 한번만 수행하는 경우에는 컴파일 및 최적화 오버헤드로 인해
<span id="changed">|</span>XL TXE-J 컴파일러가 XSLT4J 해석기보다 느립니다.</p>
<span id="changed">|</span><p>XSLT 프로세서로 XSLT4J 해석기를 계속 사용하려면
<span id="changed">|</span><strong>javax.xml.transform.TransformerFactory</strong> 서비스 제공자를
<span id="changed">|</span>org.apache.xalan.processor.TransformerFactoryImpl로 설정하십시오.</p>
<span id="changed">|</span><p>XL-TXE-J 컴파일러로 이주하려면 다음 단계를 수행하십시오.</p></p>
<span id="changed">|</span><ol type="1">
<span id="changed">|</span><li><strong>javax.xml.transform.TransformerFactory</strong> 서비스 제공자를 설정하는 경우
<span id="changed">|</span>com.ibm.xtq.xslt.jaxp.compiler.TransformerFactoryImpl을 사용하십시오. </li>
<span id="changed">|</span><li>XSLT4J 컴파일러가 생성한 클래스 파일을 다시 생성하십시오. XL TXE-J는 XSLT4J 컴파일러가 생성한 클래스 파일을 실행할 수 없습니다. </li>
<span id="changed">|</span><li>컴파일러에서 생성된 일부 메소드는 JVM 메소드 크기 한계를 초과할 수 있으며,
<span id="changed">|</span>이 경우 컴파일러는 이러한 메소드를 더 작은 메소드로 분할을
<span id="changed">|</span>시도합니다. 
<span id="changed">|</span>
<span id="changed">|</span><ul>
<span id="changed">|</span><li>컴파일러가 메소드를 분할한 경우 다음과 같은 경고가 수신됩니다.
<span id="changed">|</span>『생성된 일부 기능이 JVM 메소드 크기 한계를 초과했으며 더 작은 기능으로
<span id="changed">|</span>자동 분할되었습니다. Process 또는 Compile 명령에
<span id="changed">|</span>'splitlimit' 옵션을 사용하거나 'http://www.ibm.com/xmlns/prod/xltxe-j/split-limit' 변환기
<span id="changed">|</span>팩토리 속성을 설정하여 매우 큰 템플리트를 더 작은 템플리트로 수동 분할하면 더 나은 성능을 얻을 수 있습니다.』 컴파일된
<span id="changed">|</span>클래스를 사용할 수 있으나 분할 한계를 수동으로 제어하면 더 좋은 성능을 얻을 수 있습니다.</li>
<span id="changed">|</span><li>컴파일러가 메소드를 분할하지 않은 경우, 다음 예외 중 하나를
<span id="changed">|</span>수신하게 됩니다. 『com.ibm.xtq.bcel.generic.ClassGenException:
<span id="changed">|</span>Branch target offset too large for short』 또는 『bytecode array size &gt; 65535
<span id="changed">|</span>at offset=#####』. 분할 한계를 수동으로 설정하거나 보다 낮은 분할 한계를
<span id="changed">|</span>사용하도록 하십시오.</li></ul> 분할 한계를 설정하려면 Process 또는 Compile 명령을 사용하는 경우
<span id="changed">|</span><strong>-SPLITLIMIT</strong> 옵션을 사용하고, 변환기 팩토리를 사용하는 경우
<span id="changed">|</span><strong>http://www.ibm.com/xmlns/prod/xltxe-j/split-limit</strong> 변환기 팩토리
<span id="changed">|</span>속성을 사용하십시오. 분할 한계의 범위는 100 - 200입니다. 분할 한계를
<span id="changed">|</span>수동으로 설정하는 경우 최고 성능을 위해 가능한 한 최대 분할 한계를 사용하십시오.</li>
<span id="changed">|</span><li>XL TXE-J에는 XSLT4J 컴파일러보다 많은 메모리가 필요합니다. 실행 중에 메모리가 부족하거나 성능이 느려지는 경우
<span id="changed">|</span><strong>-Xmx</strong> 옵션을 사용하여 힙 크기를 늘리십시오. </li>
<span id="changed">|</span><li>새 속성 키를 사용하려면 응용프로그램을 이주하십시오. 이전 변환기 팩토리 속성 키는 사용되지 않습니다. 이전 이름은 경고와 함께 허용됩니다.  
<span id="changed">|</span>
<span id="changed">|</span><a name="wq44"></a>
<span id="changed">|</span><table id="wq44" width="90%" summary="" border="1" frame="border" rules="all">
<span id="changed">|</span><caption>표 1. XSL4J 컴파일러에서 XL TXE-J 컴파일러로 속성 키 변경</caption>
<span id="changed">|</span><thead valign="bottom">
<span id="changed">|</span><tr valign="bottom">
<span id="changed">|</span><th id="wq45" align="left">XSL4J 컴파일러 속성</th>
<span id="changed">|</span><th id="wq46" align="left">XL TXE-J 컴파일러 속성</th>
<span id="changed">|</span></tr>
<span id="changed">|</span></thead>
<span id="changed">|</span><tbody valign="top">
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq45">translet-name</td>
<span id="changed">|</span><td headers="wq46">http://www.ibm.com/xmlns/prod/xltxe-j/translet-name</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq45">destination-directory</td>
<span id="changed">|</span><td headers="wq46">http://www.ibm.com/xmlns/prod/xltxe-j/destination-directory</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq45">package-name</td>
<span id="changed">|</span><td headers="wq46">http://www.ibm.com/xmlns/prod/xltxe-j/package-name</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq45">jar-name</td>
<span id="changed">|</span><td headers="wq46">http://www.ibm.com/xmlns/prod/xltxe-j/jar-name</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq45">generate-translet</td>
<span id="changed">|</span><td headers="wq46">http://www.ibm.com/xmlns/prod/xltxe-j/generate-translet</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq45">auto-translet</td>
<span id="changed">|</span><td headers="wq46">http://www.ibm.com/xmlns/prod/xltxe-j/auto-translet</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq45">use-classpath</td>
<span id="changed">|</span><td headers="wq46">http://www.ibm.com/xmlns/prod/xltxe-j/use-classpath</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq45">debug</td>
<span id="changed">|</span><td headers="wq46">http://www.ibm.com/xmlns/prod/xltxe-j/debug</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq45">indent-number</td>
<span id="changed">|</span><td headers="wq46">http://www.ibm.com/xmlns/prod/xltxe-j/indent-number</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq45">enable-inlining</td>
<span id="changed">|</span><td headers="wq46"><em>새 컴파일러에서 사용되지 않음</em></td>
<span id="changed">|</span></tr>
<span id="changed">|</span></tbody>
<span id="changed">|</span></table></li>
<span id="changed">|</span><li>옵션: 성능을 최대화하려면 재사용할 수 있는 XSLT 변환을
<span id="changed">|</span>리컴파일하지 않는지 확인하십시오.  컴파일된 변환을 다시 사용하려면 다음 방법 중 하나를
<span id="changed">|</span>사용하십시오.
<span id="changed">|</span>
<span id="changed">|</span><ul>
<span id="changed">|</span><li>스타일시트가 런타임에 변경되지 않으면 빌드 프로세스 중 일부로 스타일시트를
<span id="changed">|</span>컴파일한 후 컴파일된 클래스를 클래스 경로에 지정하십시오.
<span id="changed">|</span>org.apache.xalan.xsltc.Compile 명령을 사용하여 스타일시트를 컴파일한 후
<span id="changed">|</span><strong>http://www.ibm.com/xmlns/prod/xltxe-j/use-classpath</strong> 변환기 팩토리 속성을
<span id="changed">|</span><tt>true</tt>로 설정하면 클래스 경로에서 클래스를 로드할 수 있습니다.</li>
<span id="changed">|</span><li>다중 실행 중에 응용프로그램에서 같은 스타일시트를 사용하려는 경우
<span id="changed">|</span><strong>http://www.ibm.com/xmlns/prod/xltxe-j/auto-translet</strong> 변환기 팩토리 속성을
<span id="changed">|</span><tt>true</tt>로 설정하면 컴파일된 디스크를 재사용할 디스크에 자동으로
<span id="changed">|</span>저장할 수 있습니다. 컴파일러는 사용 가능한 컴파일된 스타일시트를 사용하지만
<span id="changed">|</span>사용할 수 없거나 날짜가 지난 경우에는 스타일시트를 컴파일합니다. 컴파일된 스타일시트를 저장하는 데 사용한
<span id="changed">|</span>디렉토리를 설정하려면 <strong>http://www.ibm.com/xmlns/prod/xltxe-j/destination-directory</strong> 변환기
<span id="changed">|</span>팩토리 속성을 사용하십시오.
<span id="changed">|</span>기본적으로 컴파일된 스타일시트는 스타일시트와 동일한 디렉토리에 저장됩니다.</li>
<span id="changed">|</span><li>동일한 스타일시트를 재사용하여 실행 시간이 긴 응용프로그램인 경우에는
<span id="changed">|</span>변환기 팩토리를 사용하여 스타일시트를 컴파일한 후
<span id="changed">|</span>Templates 오브젝트를 작성하십시오. Templates 오브젝트를
<span id="changed">|</span>사용하면 스타일시트를 리컴파일하지 않고 Transformer 오브젝트를 작성할 수 있습니다. Transformer 오브젝트도 재사용할 수는 있으나 스레드가 안전하지 않습니다.</li></ul></li></ol>
<span id="changed">|</span><a name="xml_reference"></a>
<span id="changed">|</span><h3 id="xml_reference"><a href="#ToC_51">XML 참조 정보</a></h3>
<span id="changed">|</span><div>
<span id="changed">|</span><p>XL XP-J 및 XL TXE-J XML 라이브러리는 SDK 버전 6의 새로운 기능입니다.
<span id="changed">|</span>이 참조 정보에서는 이러한 라이브러리에서 지원되는 기능에 대해 설명합니다.</p></div><span id="changed">|</span>
<span id="changed">|</span><a name="xlxpj_reference"></a>
<span id="changed">|</span><h4 id="xlxpj_reference">XL XP-J 참조 정보</h4>
<span id="changed">|</span><div>
<span id="changed">|</span><p>XL XP-J 1.1은 StAX 1.0(JSR 173)을 지원하는 유효성을 검증하지 않는 고성능의 구문 분석기로
<span id="changed">|</span>XML 1.0 및 XML 1.1 문서의 풀 구문 분석과 스트리밍 직렬화를 수행할 수 있는 양방향 API입니다.</p></div>
<span id="changed">|</span><p>
<span id="changed">|</span><a name="wq47"></a>
<span id="changed">|</span><h5 id="wq47">지원되는 기능</h5>
<span id="changed">|</span><p>다음과 같은 선택적 StAX 기능은 XL XP-J에서 지원되지 않습니다.
<span id="changed">|</span></p>
<span id="changed">|</span><ul>
<span id="changed">|</span><li>XMLStreamReader 또는 XMLEventReader를 사용하는 경우 DTD 유효성 검증 기능입니다.
<span id="changed">|</span>XL XP-J 구문 분석기는 유효성을 검증하지 않습니다.</li>
<span id="changed">|</span><li>XMLStreamReader 또는 XMLEventReader를 사용하는 경우 위치 정보입니다.
<span id="changed">|</span>위치 오브젝트에서 getCharacterOffset(), getColumnNumber() 및
<span id="changed">|</span>getLineNumber() 메소드를 조회하면 문서에서 구문 분석기의 현재 위치와 관계없이 -1이 리턴됩니다.</li></ul></p>
<span id="changed">|</span><p>
<span id="changed">|</span><a name="wq48"></a>
<span id="changed">|</span><h5 id="wq48">XMLInputFactory 참조</h5>
<span id="changed">|</span><p>다음 특성은 <a href="http://java.sun.com/javase/6/docs/api/javax/xml/stream/XMLInputFactory.html" target="_blank">XMLInputFactory Javadoc</a>에 설명된 대로
<span id="changed">|</span>javax.xml.stream.XMLInputFactory 구현에서 지원됩니다.</p></p>
<span id="changed">|</span><a name="wq49"></a>
<span id="changed">|</span><table id="wq49" width="100%" summary="" border="1" frame="border" rules="all">
<span id="changed">|</span><caption>표 2. </caption>
<span id="changed">|</span><thead valign="bottom">
<span id="changed">|</span><tr valign="bottom">
<span id="changed">|</span><th id="wq50" align="left">특성 이름</th>
<span id="changed">|</span><th id="wq51" align="left">지원</th>
<span id="changed">|</span></tr>
<span id="changed">|</span></thead>
<span id="changed">|</span><tbody valign="top">
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq50"><strong>javax.xml.stream.isValidating</strong></td>
<span id="changed">|</span><td headers="wq51">아니오. XL XP-J 스캐너는 유효성 검증을 지원하지 않습니다.</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq50"><strong>javax.xml.stream.isNamespaceAware</strong></td>
<span id="changed">|</span><td headers="wq51">예(true 및 false 지원). DOMSource에서 작성된
<span id="changed">|</span>XMLStreamReader인 경우
<span id="changed">|</span>DOM 트리를 작성하는 데 사용된 메소드에 따라 이름 공간이 처리되면
<span id="changed">|</span>이 값이 영향을 미치지 않습니다.</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq50"><strong>javax.xml.stream.isCoalescing</strong></td>
<span id="changed">|</span><td headers="wq51">예</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq50"><strong>javax.xml.stream.isReplacingEntityReferences</strong></td>
<span id="changed">|</span><td headers="wq51">예. DOMSource에서 작성된 XMLStreamReader인 경우
<span id="changed">|</span>DOM 트리에서 엔티티가 이미 바뀌어 있으면 이 매개변수의 설정이 영향을 미치지 않습니다.</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq50"><strong>javax.xml.stream.isSupportingExternalEntities</strong></td>
<span id="changed">|</span><td headers="wq51">예</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq50"><strong>javax.xml.stream.supportDTD</strong></td>
<span id="changed">|</span><td headers="wq51">아니오. DTD는 항상 지원됩니다. 값을 false로 설정하면 영향을 미치지 않습니다.</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq50"><strong>javax.xml.stream.reporter</strong></td>
<span id="changed">|</span><td headers="wq51">예</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq50"><strong>javax.xml.stream.resolver</strong></td>
<span id="changed">|</span><td headers="wq51">예</td>
<span id="changed">|</span></tr>
<span id="changed">|</span></tbody>
<span id="changed">|</span></table>
<span id="changed">|</span><p>또한 XL XP-J는
<span id="changed">|</span>선택적 메소드인 createXMLStreamReader(javax.xml.transform.Source)를 지원하며
<span id="changed">|</span>이를 통해 DOM 및 SAX에서 StAX 리더를 작성할 수 있습니다.</p>
<span id="changed">|</span><p>
<span id="changed">|</span><a name="wq52"></a>
<span id="changed">|</span><h5 id="wq52">XMLStreamReader 참조</h5>
<span id="changed">|</span><p>다음 특성은 <a href="http://java.sun.com/javase/6/docs/api/javax/xml/stream/XMLStreamReader.html" target="_blank">XMLStreamReader Javadoc</a>에 설명된 대로
<span id="changed">|</span>javax.xml.stream.XMLStreamReader 구현에서 지원됩니다.</p></p>
<span id="changed">|</span><a name="wq53"></a>
<span id="changed">|</span><table id="wq53" width="100%" summary="" border="1" frame="border" rules="all">
<span id="changed">|</span><caption>표 3. </caption>
<span id="changed">|</span><thead valign="bottom">
<span id="changed">|</span><tr valign="bottom">
<span id="changed">|</span><th id="wq54" align="left">특성 이름</th>
<span id="changed">|</span><th id="wq55" align="left">지원</th>
<span id="changed">|</span></tr>
<span id="changed">|</span></thead>
<span id="changed">|</span><tbody valign="top">
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq54"><strong>javax.xml.stream.entities</strong></td>
<span id="changed">|</span><td headers="wq55">예</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq54"><strong>javax.xml.stream.notations</strong></td>
<span id="changed">|</span><td headers="wq55">예</td>
<span id="changed">|</span></tr>
<span id="changed">|</span></tbody>
<span id="changed">|</span></table>
<span id="changed">|</span><p>또한 XL XP-J <strong>javax.xml.stream.isInterning</strong> 특성을 지원하며
<span id="changed">|</span>이는 API 호출로 리턴된 XML 이름 및 이름 공간 URI가 구문 분석기에서 수행되었는지 여부를 나타내는 부울을 리턴합니다.</p>
<span id="changed">|</span><p>
<span id="changed">|</span><a name="wq56"></a>
<span id="changed">|</span><h5 id="wq56">XMLOutputFactory 참조</h5>
<span id="changed">|</span><p>다음 특성은 <a href="http://java.sun.com/javase/6/docs/api/javax/xml/stream/XMLOutputFactory.html" target="_blank">XMLOutputFactory Javadoc</a>에 설명된 대로
<span id="changed">|</span>javax.xml.stream.XMLOutputFactory 구현에서 지원됩니다.</p></p>
<span id="changed">|</span><a name="wq57"></a>
<span id="changed">|</span><table id="wq57" width="100%" summary="" border="1" frame="border" rules="all">
<span id="changed">|</span><caption>표 4. </caption>
<span id="changed">|</span><thead valign="bottom">
<span id="changed">|</span><tr valign="bottom">
<span id="changed">|</span><th id="wq58" align="left">특성 이름</th>
<span id="changed">|</span><th id="wq59" align="left">지원</th>
<span id="changed">|</span></tr>
<span id="changed">|</span></thead>
<span id="changed">|</span><tbody valign="top">
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq58"><strong>javax.xml.stream.isRepairingNamespaces</strong></td>
<span id="changed">|</span><td headers="wq59">예</td>
<span id="changed">|</span></tr>
<span id="changed">|</span></tbody>
<span id="changed">|</span></table>
<span id="changed">|</span><p>
<span id="changed">|</span><a name="wq60"></a>
<span id="changed">|</span><h5 id="wq60">XMLStreamWriter 참조</h5>
<span id="changed">|</span><p>다음 특성은 <a href="http://java.sun.com/javase/6/docs/api/javax/xml/stream/XMLStreamWriter.html" target="_blank">XMLStreamWriter Javadoc</a>에 설명된 대로
<span id="changed">|</span>javax.xml.stream.XMLStreamWriter 구현에서 지원됩니다.</p></p>
<span id="changed">|</span><a name="wq61"></a>
<span id="changed">|</span><table id="wq61" width="100%" summary="" border="1" frame="border" rules="all">
<span id="changed">|</span><caption>표 5. </caption>
<span id="changed">|</span><thead valign="bottom">
<span id="changed">|</span><tr valign="bottom">
<span id="changed">|</span><th id="wq62" align="left">특성 이름</th>
<span id="changed">|</span><th id="wq63" align="left">지원</th>
<span id="changed">|</span></tr>
<span id="changed">|</span></thead>
<span id="changed">|</span><tbody valign="top">
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq62"><strong>javax.xml.stream.isRepairingNamespaces</strong></td>
<span id="changed">|</span><td headers="wq63">예</td>
<span id="changed">|</span></tr>
<span id="changed">|</span></tbody>
<span id="changed">|</span></table>
<span id="changed">|</span><p>XMLStreamWriter 오브젝트에서 특성은 읽기 전용입니다.</p><span id="changed">|</span>
<span id="changed">|</span><a name="xltxej_reference"></a>
<span id="changed">|</span><h4 id="xltxej_reference">XL TXE-J 참조 정보</h4>
<span id="changed">|</span><div>
<span id="changed">|</span><p>XL TXE-J는 XSLT4J 2.7.8 해석기 및
<span id="changed">|</span>XSLT 컴파일러를 포함하는 XSLT 라이브러리입니다.</p></div>
<span id="changed">|</span><p>
<span id="changed">|</span><a name="wq64"></a>
<span id="changed">|</span><h5 id="wq64">기능 비교 테이블</h5></p>
<span id="changed">|</span><a name="wq65"></a>
<span id="changed">|</span><table id="wq65" width="100%" summary="" border="1" frame="border" rules="all">
<span id="changed">|</span><caption>표 6. XSLT4J 해석기, XSLT4J 컴파일러 및 XL TXE-J 컴파일러의 기능 비교.</caption>
<span id="changed">|</span><thead valign="bottom">
<span id="changed">|</span><tr valign="bottom">
<span id="changed">|</span><th id="wq66" width="46%" align="left">기능</th>
<span id="changed">|</span><th id="wq67" width="17%" align="left">XSLT4J 해석기(포함)</th>
<span id="changed">|</span><th id="wq68" width="17%" align="left">XSLT4J 컴파일러(포함되지 않음)</th>
<span id="changed">|</span><th id="wq69" width="17%" align="left">XL TXE-J 컴파일러(포함)</th>
<span id="changed">|</span></tr>
<span id="changed">|</span></thead>
<span id="changed">|</span><tbody valign="top">
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq66">http://javax.xml.transform.stream.StreamSource/feature
<span id="changed">|</span>기능</td>
<span id="changed">|</span><td headers="wq67">예</td>
<span id="changed">|</span><td headers="wq68">예</td>
<span id="changed">|</span><td headers="wq69">예</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq66">http://javax.xml.transform.stream.StreamResult/feature
<span id="changed">|</span>기능</td>
<span id="changed">|</span><td headers="wq67">예</td>
<span id="changed">|</span><td headers="wq68">예</td>
<span id="changed">|</span><td headers="wq69">예</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq66">http://javax.xml.transform.dom.DOMSource/feature 기능</td>
<span id="changed">|</span><td headers="wq67">예</td>
<span id="changed">|</span><td headers="wq68">예</td>
<span id="changed">|</span><td headers="wq69">예</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq66">http://javax.xml.transform.dom.DOMResult/feature 기능</td>
<span id="changed">|</span><td headers="wq67">예</td>
<span id="changed">|</span><td headers="wq68">예</td>
<span id="changed">|</span><td headers="wq69">예</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq66">http://javax.xml.transform.sax.SAXSource/feature 기능</td>
<span id="changed">|</span><td headers="wq67">예</td>
<span id="changed">|</span><td headers="wq68">예</td>
<span id="changed">|</span><td headers="wq69">예</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq66">http://javax.xml.transform.sax.SAXResult/feature 기능</td>
<span id="changed">|</span><td headers="wq67">예</td>
<span id="changed">|</span><td headers="wq68">예</td>
<span id="changed">|</span><td headers="wq69">예</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq66">http://javax.xml.transform.stax.StAXSource/feature 기능</td>
<span id="changed">|</span><td headers="wq67">예</td>
<span id="changed">|</span><td headers="wq68">아니오</td>
<span id="changed">|</span><td headers="wq69">예</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq66">http://javax.xml.transform.stax.StAXResult/feature 기능</td>
<span id="changed">|</span><td headers="wq67">예</td>
<span id="changed">|</span><td headers="wq68">아니오</td>
<span id="changed">|</span><td headers="wq69">예</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq66">http://javax.xml.transform.sax.SAXTransformerFactory/feature
<span id="changed">|</span>기능</td>
<span id="changed">|</span><td headers="wq67">예</td>
<span id="changed">|</span><td headers="wq68">예</td>
<span id="changed">|</span><td headers="wq69">예</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq66">http://javax.xml.transform.sax.SAXTransformerFactory/feature/xmlfilter
<span id="changed">|</span>기능</td>
<span id="changed">|</span><td headers="wq67">예</td>
<span id="changed">|</span><td headers="wq68">예</td>
<span id="changed">|</span><td headers="wq69">예</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq66">http://javax.xml.XMLConstants/feature/secure-processing
<span id="changed">|</span>기능</td>
<span id="changed">|</span><td headers="wq67">예</td>
<span id="changed">|</span><td headers="wq68">예</td>
<span id="changed">|</span><td headers="wq69">예</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq66">http://xml.apache.org/xalan/features/incremental 속성</td>
<span id="changed">|</span><td headers="wq67">예</td>
<span id="changed">|</span><td headers="wq68">아니오</td>
<span id="changed">|</span><td headers="wq69">아니오</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq66">http://xml.apache.org/xalan/features/optimize 속성</td>
<span id="changed">|</span><td headers="wq67">예</td>
<span id="changed">|</span><td headers="wq68">아니오</td>
<span id="changed">|</span><td headers="wq69">아니오</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq66">http://xml.apache.org/xalan/properties/source-location
<span id="changed">|</span>속성</td>
<span id="changed">|</span><td headers="wq67">예</td>
<span id="changed">|</span><td headers="wq68">아니오</td>
<span id="changed">|</span><td headers="wq69">아니오</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq66">translet-name 속성</td>
<span id="changed">|</span><td headers="wq67">N/A</td>
<span id="changed">|</span><td headers="wq68">예</td>
<span id="changed">|</span><td headers="wq69">예(새 이름으로)</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq66">destination-directory 속성</td>
<span id="changed">|</span><td headers="wq67">N/A</td>
<span id="changed">|</span><td headers="wq68">예</td>
<span id="changed">|</span><td headers="wq69">예(새 이름으로)</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq66">package-name 속성</td>
<span id="changed">|</span><td headers="wq67">N/A</td>
<span id="changed">|</span><td headers="wq68">예</td>
<span id="changed">|</span><td headers="wq69">예(새 이름으로)</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq66">jar-name 속성</td>
<span id="changed">|</span><td headers="wq67">N/A</td>
<span id="changed">|</span><td headers="wq68">예</td>
<span id="changed">|</span><td headers="wq69">예(새 이름으로)</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq66">generate-translet 속성</td>
<span id="changed">|</span><td headers="wq67">N/A</td>
<span id="changed">|</span><td headers="wq68">예</td>
<span id="changed">|</span><td headers="wq69">예(새 이름으로)</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq66">auto-translet 속성</td>
<span id="changed">|</span><td headers="wq67">N/A</td>
<span id="changed">|</span><td headers="wq68">예</td>
<span id="changed">|</span><td headers="wq69">예(새 이름으로)</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq66">use-classpath 속성</td>
<span id="changed">|</span><td headers="wq67">N/A</td>
<span id="changed">|</span><td headers="wq68">예</td>
<span id="changed">|</span><td headers="wq69">예(새 이름으로)</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq66">enable-inlining 속성</td>
<span id="changed">|</span><td headers="wq67">아니오</td>
<span id="changed">|</span><td headers="wq68">예</td>
<span id="changed">|</span><td headers="wq69">아니오(TL TXE-J에서 사용되지 않음)</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq66">indent-number 속성</td>
<span id="changed">|</span><td headers="wq67">아니오</td>
<span id="changed">|</span><td headers="wq68">예</td>
<span id="changed">|</span><td headers="wq69">예(새 이름으로)</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq66">debug 속성</td>
<span id="changed">|</span><td headers="wq67">아니오</td>
<span id="changed">|</span><td headers="wq68">예</td>
<span id="changed">|</span><td headers="wq69">예(새 이름으로)</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq66">Java 확장</td>
<span id="changed">|</span><td headers="wq67">예</td>
<span id="changed">|</span><td colspan="2" headers="wq68 wq69">예(축약된 구문에만 해당, xalan:component/xalan:script
<span id="changed">|</span>구성은 지원되지 않음)</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq66">JavaScript 확장</td>
<span id="changed">|</span><td headers="wq67">예</td>
<span id="changed">|</span><td headers="wq68">아니오</td>
<span id="changed">|</span><td headers="wq69">아니오</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq66">확장 요소</td>
<span id="changed">|</span><td headers="wq67">예</td>
<span id="changed">|</span><td headers="wq68">아니오</td>
<span id="changed">|</span><td headers="wq69">아니오</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq66">EXSLT 확장 기능</td>
<span id="changed">|</span><td headers="wq67">예</td>
<span id="changed">|</span><td headers="wq68">예(동적 제외)</td>
<span id="changed">|</span><td headers="wq69">예(동적 제외)</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq66">redirect 확장</td>
<span id="changed">|</span><td headers="wq67">예</td>
<span id="changed">|</span><td headers="wq68">예(redirect:open 및 redirect:close 제외)</td>
<span id="changed">|</span><td headers="wq69">예</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq66">output 확장</td>
<span id="changed">|</span><td headers="wq67">아니오</td>
<span id="changed">|</span><td headers="wq68">예</td>
<span id="changed">|</span><td headers="wq69">예</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq66">nodeset 확장</td>
<span id="changed">|</span><td headers="wq67">예</td>
<span id="changed">|</span><td headers="wq68">예</td>
<span id="changed">|</span><td headers="wq69">예</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq66">NodeInfo 확장 기능</td>
<span id="changed">|</span><td headers="wq67">예</td>
<span id="changed">|</span><td headers="wq68">아니오</td>
<span id="changed">|</span><td headers="wq69">아니오</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq66">SQL library 확장</td>
<span id="changed">|</span><td headers="wq67">예</td>
<span id="changed">|</span><td headers="wq68">아니오</td>
<span id="changed">|</span><td headers="wq69">아니오</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq66">pipeDocument 확장</td>
<span id="changed">|</span><td headers="wq67">예</td>
<span id="changed">|</span><td headers="wq68">아니오</td>
<span id="changed">|</span><td headers="wq69">아니오</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq66">evaluate 확장</td>
<span id="changed">|</span><td headers="wq67">예</td>
<span id="changed">|</span><td headers="wq68">아니오</td>
<span id="changed">|</span><td headers="wq69">아니오</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq66">tokenize 확장</td>
<span id="changed">|</span><td headers="wq67">예</td>
<span id="changed">|</span><td headers="wq68">아니오</td>
<span id="changed">|</span><td headers="wq69">아니오</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq66">XML 1.1</td>
<span id="changed">|</span><td headers="wq67">예</td>
<span id="changed">|</span><td headers="wq68">예</td>
<span id="changed">|</span><td headers="wq69">예</td>
<span id="changed">|</span></tr>
<span id="changed">|</span></tbody>
<span id="changed">|</span></table>
<span id="changed">|</span><p>
<span id="changed">|</span><a name="wq70"></a>
<span id="changed">|</span><h5 id="wq70">참고</h5>
<span id="changed">|</span><p>프로세스 명령을 사용할 경우 StAX 스트림 처리를 사용하여
<span id="changed">|</span>변환하려면 <strong>-FLAVOR
<span id="changed">|</span>sr2sw</strong>를 사용하고 StAX 이벤트 처리에는 <strong>-FLAVOR
<span id="changed">|</span>er2ew</strong>를 사용하십시오.</p>
<span id="changed">|</span><p>새 컴파일러는 org.apache.xalan.xsltc.dom.XSLTCDTMManager 서비스 제공자를
<span id="changed">|</span>검색하지 않습니다. 대신 StreamSource가 사용된 경우 컴파일러는 고성능 XML 구문 분석기로
<span id="changed">|</span>전환합니다.</p>
<span id="changed">|</span><p>Inlining은 XL TXE-J에서 사용되지 않습니다. 
<span id="changed">|</span></p>
<span id="changed">|</span><ul>
<span id="changed">|</span><li>Process 명령에 대한 <strong>-XN</strong> 옵션은 자동으로 무시됩니다.</li>
<span id="changed">|</span><li>Compile 명령에 대한 <strong>-n</strong> 옵션은 자동으로 무시됩니다.</li>
<span id="changed">|</span><li><strong>enable-inlining</strong> 변환기 팩토리 속성은 자동으로
<span id="changed">|</span>무시됩니다.</li></ul>
<span id="changed">|</span><p>org.apache.xalan.xsltc.trax.SmartTransformerFactoryImpl 클래스는 더 이상 지원되지 않습니다.</p></p>
<span id="changed">|</span><a name="old_xerces"></a>
<span id="changed">|</span><h4 id="old_xerces">Xerces 또는 Xalan의 이전 버전 사용</h4>
<span id="changed">|</span><div>
<span id="changed">|</span><p>승인된 대체에 따라 이전 버전의 Xerces(2.0 이전) 또는 Xalan(2.3 이전)을 사용 중인 경우,
<span id="changed">|</span>응용프로그램을 시작할 때 NullPointerException이 발생할 수 있습니다. 이 예외는
<span id="changed">|</span>이러한 이전 버전이 jaxp.properties 파일을 올바르게 처리하지 않아서 발생합니다.</p></div>
<span id="changed">|</span><p>
<span id="changed">|</span><p>이러한 예외를 방지하려면 다음 해결책 중 하나를 수행하십시오.
<span id="changed">|</span>
<span id="changed">|</span></p>
<span id="changed">|</span><ul>
<span id="changed">|</span><li>최신 JAXP(Java API
<span id="changed">|</span>for XML Programming) 스펙을 구현하는 응용프로그램의 새 버전으로 업그레이드하십시오(웹 사이트 http://java.sun.com/xml/jaxp/index.html 참조).</li>
<span id="changed">|</span><li>/opt/ibm/java-i386-60/jre/lib에서 jaxp.properties 파일을 제거하십시오.</li>
<span id="changed">|</span><li>/opt/ibm/java-i386-60/jre/lib에서 jaxp.properties 파일의 항목을 주석 해제하십시오.</li>
<span id="changed">|</span><li><strong>-D</strong> 명령행 옵션을 사용하여 <strong>javax.xml.parsers.SAXParserFactory</strong>,
<span id="changed">|</span><strong>javax.xml.parsers.DocumentBuilderFactory</strong> 또는
<span id="changed">|</span><strong>javax.xml.transform.TransformerFactory</strong>의 시스템 특성을 설정하십시오.</li>
<span id="changed">|</span><li>응용프로그램의 코드 내에서 <strong>javax.xml.parsers.SAXParserFactory</strong>, <strong>javax.xml.parsers.DocumentBuilderFactory</strong> 또는 <strong>javax.xml.transform.TransformerFactory</strong>의 시스템 등록 정보를 설정하십시오.
<span id="changed">|</span>예를 들어, JAXP 1.4 스펙을 참조하십시오.</li>
<span id="changed">|</span><li><strong>IBM_JAVA_OPTIONS</strong> 환경 변수를 사용하여
<span id="changed">|</span>SAX 구문 분석기, 문서 빌더 또는 변환기 팩토리를 명시적으로 설정하십시오. 예를 들면 다음과 같습니다.
<span id="changed">|</span>
<span id="changed">|</span><pre class="xmp">export IBM_JAVA_OPTIONS=-Djavax.xml.parsers.SAXParserFactory=
<span id="changed">|</span>    org.apache.xerces.jaxp.SAXParserFactoryImpl </pre>또는
<span id="changed">|</span>
<span id="changed">|</span><pre class="xmp">export IBM_JAVA_OPTIONS=-Djavax.xml.parsers.DocumentBuilderFactory=
<span id="changed">|</span>  org.apache.xerces.jaxp.DocumentBuilderFactoryImpl</pre>또는
<span id="changed">|</span>
<span id="changed">|</span><pre class="xmp">export IBM_JAVA_OPTIONS=-Djavax.xml.transform.TransformerFactory=
<span id="changed">|</span>    org.apache.xalan.processor.TransformerFactoryImpl  </pre></li></ul></p></font>
<a name="debugger"></a>
<h2 id="debugger"><a href="#ToC_62">Java 응용프로그램 디버깅</a></h2>
<div>
<p>Java 프로그램을 디버그하려면
JDB(Java Debugger) 응용프로그램을
사용하거나  SDK for Linux가
제공하는 JPDA(Java Platform Debugger Architecture)를
사용하여 통신하는 다른 디버거를 사용할 수 있습니다.</p></div>
<p>Java를 사용하는
문제점 진단에 대한 자세한 정보는 <a href="http://www.ibm.com/developerworks/java/jdk/diagnosis/60.html" target="_blank">진단 안내서</a>에 있습니다.</p>
<a name="jdb"></a>
<h3 id="jdb"><a href="#ToC_63">JDB(Java Debugger)</a></h3>
<div>
<p>JDB(Java Debugger)는
SDK for Linux에
포함되어 있습니다. 디버거는 jdb 명령으로 호출되며, JPDA를 사용하여 JVM에 첨부됩니다.</p></div>
<p>
<p> Java 응용프로그램을
디버그하려면 다음을 수행하십시오. 
</p>
<ol type="1">
<li id="jdb__jdb_start_jvm">
<a name="jdb__jdb_start_jvm"></a>다음 옵션으로 JVM을 시작하십시오.

<pre class="xmp">java -Xdebug -Xrunjdwp:transport=dt_socket,server=y,address=<em>&lt;port&gt;</em> <em>&lt;class&gt;</em></pre>JVM이 시작되지만 Java 응용프로그램을
시작할 때까지 실행이 일시중단됩니다.</li>
<li>별도의 세션에서 다음과 같이 디버거를 JVM에 첨부할 수 있습니다.

<pre class="xmp">jdb -attach <em>&lt;port&gt;</em></pre>디버거가 JVM에 첨부되며, 이제 다양한 명령을
실행하여 Java 응용프로그램을
시험하고 제어할 수 있습니다. 예를 들어, Java
응용프로그램을 시작하려면 <tt class="xph">run</tt>을 입력하십시오.</li></ol></p>
<p>
<p>JDB 옵션에 대한 자세한 정보를 보려면 다음을 입력하십시오. </p>
<pre class="xmp">jdb -help</pre><p class="indatacontent">JDB 명령에 대한 자세한 정보를 보려면 다음을 수행하십시오. 
</p>
<ol type="1">
<li><tt class="xph">jdb</tt>를 입력하십시오.</li>
<li>jdb 프롬프트에서 <tt class="xph">help</tt>를 입력하십시오.</li></ol></p>
<p>
<p>JDB를 사용하여 원격 시스템에서 실행 중인
Java 응용프로그램을
디버그할 수도 있습니다. JPDA는 TCP/IP 소켓을 사용하여 원격 JVM에 연결합니다. 
</p>
<ol type="1">
<li>다음 옵션으로 JVM을 시작하십시오.

<pre class="xmp">java -Xdebug -Xrunjdwp:transport=dt_socket,server=y,address=<em>&lt;port&gt;</em> <em>&lt;class&gt;</em></pre>JVM이 시작되지만 Java 응용프로그램을
시작할 때까지 실행이 일시중단됩니다.</li>
<li>디버거를 원격 JVM에 첨부하십시오. 
<pre class="xmp">jdb -attach <em>&lt;host&gt;</em>:<em>&lt;port&gt;</em></pre></li></ol></p>
<p>
<p>JVMDI(Java
Virtual Machine Debugging Interface)는 이 릴리스에서 지원되지 않습니다. 대신
JVMTI(Java Virtual Machine
Tool Interface)가 사용됩니다.</p></p>
<p>
<p>JDB와 JPDA 및 이들의 사용법에 대한 자세한 정보는 다음 웹 사이트를 참조하십시오. 
</p>
<ul>
<li><a href="http://java.sun.com/products/jpda/" target="_blank">http://java.sun.com/products/jpda/</a></li>
<li><a href="http://java.sun.com/javase/6/docs/technotes/guides/jpda/" target="_blank">http://java.sun.com/javase/6/docs/technotes/guides/jpda/</a></li>
<li><a href="http://java.sun.com/javase/6/docs/technotes/guides/jpda/jdb.html" target="_blank">http://java.sun.com/javase/6/docs/technotes/guides/jpda/jdb.html</a></li></ul></p>
<a name="bit_check"></a>
<h2 id="bit_check"><a href="#ToC_64">응용프로그램을 실행 중인 JVM이 32-bit인지
64-bit인지 판별</a></h2>
<div>
<p>일부 Java 응용프로그램은
실행 중인 JVM이 32-bit인지 64-bit인지
판별할 수 있어야 합니다. 예를 들어, 응용프로그램에 원시 코드 라이브러리가 있으면 해당 라이브러리는 32-bit 및 64-bit 작업 모드를 모두 지원하는 플랫폼에 대해 32-bit 및 64-bit 형식으로 별도로 컴파일되어야 합니다. 이때, 32-bit 및 64-bit 코드를 혼합할수 없으므로 응용프로그램은 런타임 시 올바른 라이브러리를 로드해야 합니다.</p></div>
<p>
<p>시스템 등록 정보 <strong>com.ibm.vm.bitmode</strong>를 사용하면
응용프로그램에서 JVM이 실행 중인 모드를 판별할 수 있습니다. 응용프로그램은 다음 값을
리턴합니다.

</p>
<ul>
<li>32 - JVM이 32-bit 모드로
실행 중(Linux on System
z에서는 31-bit 모드)</li>
<li>64 - JVM이 64-bit 모드로 실행 중</li></ul><p class="indatacontent">다음 호출을 사용하여 응용프로그램 내에서 <strong>com.ibm.vm.bitmode</strong> 특성을
검사할 수 있습니다. </p>
<pre class="xmp">System.getProperty("com.ibm.vm.bitmode");</pre></p>
<a name="signals"></a>
<h2 id="signals"><a href="#ToC_65">JVM의 신호 처리 방법</a></h2>
<div>
<p>JVM과 관련된 신호가 오면, 신호 핸들러가 호출됩니다. 이 신호 핸들러는
호출한 스레드가 Java인지 비Java인지 판별합니다.</p></div>
<p>Java 스레드에 대한 신호인 경우
JVM은 신호 처리를 제어할 수 있습니다. 이 신호의 응용프로그램 핸들러가 설치되어 있고
<strong>-Xnosigchain</strong> 명령행 옵션을 지정하지 않은 경우,
JVM이 처리를 완료한 후 이 신호에 대한 응용프로그램 핸들러가 호출됩니다.</p>
<p>신호가 Java 이외의 스레드에 대한 것이며
JVM을 설치한 응용프로그램에 신호를 위한 자체 핸들러가 이미 설치되어 있는 경우에는
해당 핸들러가 신호를 제어합니다. 그렇지 않으면 JVM 또는
Java 응용프로그램에서
신호가 요청되는 경우 신호가 무시되거나 기본 조치가 수행됩니다.</p>
<p>예외 및 오류 신호의 경우, JVM은 다음 중 하나를 수행합니다.

</p>
<ul>
<li>조건을 처리하고 복구합니다.</li>
<li>제어된 시스템 종료 순서로 들어갑니다. 

<ol type="1">
<li>실패 시점의 JVM 상태를 설명하는 덤프를 생성합니다.</li>
<li>해당 신호에 대한 응용프로그램의 신호 핸들러를 호출합니다.</li>
<li>모든 응용프로그램의 설치 중단 후크를 호출합니다.</li>
<li>시스템 종료를 위해 필요한 정리를 수행합니다.</li></ol></li></ul>위의
후크를 지정하는 실행기를 작성하는 데 대한 정보는 웹 사이트
<a href="http://www.ibm.com/developerworks/java/library/i-signalhandling/" target="_blank">http://www.ibm.com/developerworks/java/library/i-signalhandling/</a>을
참조하십시오. 이 항목은 Java V1.3.1용으로
작성되었으나 후속 버전에도 적용됩니다. 
<p>인터럽트 신호의 경우 JVM은 제어된 시스템 종료 순서를 수행합니다. 이 때,
다음과 같은 정상 종료로 처리됩니다.

</p>
<ol type="1">
<li>해당 신호에 대해 응용프로그램의 신호 핸들러를 호출합니다.</li>
<li>모든 응용프로그램의 시스템 종료 후크를 실행합니다.</li>
<li>응용프로그램 설치 종료 후크를 호출합니다.</li>
<li>필수 JVM 정리를 수행합니다.</li></ol>
<p>이 시스템 종료는 Java 메소드
<tt class="xph">System.exit()</tt>를 호출하여 시작되는 시스템 종료와 동일합니다.</p>
<p>JVM에서 사용되는 기타 신호는 내부 제어용이며 JVM을 종료시키지 않습니다. 관련된 제어 신호는 SIGQUIT 뿐이며 이는
Javadump를 생성합니다.</p>
<a name="sighand"></a>
<h3 id="sighand"><a href="#ToC_66">JVM에서 사용되는 신호</a></h3>
<div>
<p>신호의 유형은 예외, 오류, 인터럽트 및
제어입니다.</p></div>
<p>
<p>아래의 <a href="#sighand__sig_table">표 7</a>에서는 JVM에서 사용되는 신호를 보여줍니다.
신호는 다음과 같이 유형 또는 용도별로 분류됩니다.

</p>
<dl>
<dt class="bold">예외</dt>
<dd>운영 체제는 심각한 조건이 발생할 때마다
적절한 예외 신호를 발생시킵니다.
</dd>
<dt class="bold">오류</dt>
<dd>JVM은 복구할 수 없는 조건을 발견하는 경우 SIGABRT를 일으킵니다.
</dd>
<dt class="bold">인터럽트</dt>
<dd>인터럽트 신호는 JVM 프로세스 외부에서 비동기적으로 일어나며 시스템 종료를 요청합니다.
</dd>
<dt class="bold">제어</dt>
<dd>제어 목적으로 JVM에서 사용되는 기타 신호입니다.
</dd>
</dl><p class="indatacontent">
</p>
<a name="sighand__sig_table"></a>
<table id="sighand__sig_table" width="100%" summary="" border="1" frame="border" rules="all">
<caption>표 7. JVM에서 사용되는 신호</caption>
<thead valign="bottom">
<tr>
<th id="wq84" width="25%" align="left">신호 이름</th>
<th id="wq85" width="25%" align="left">신호 유형</th>
<th id="wq86" width="25%" align="left">설명</th>
<th id="wq87" width="25%" align="left">-Xrs에 의해 사용 불가능</th>
</tr>
</thead>
<tbody valign="top">
<tr>
<td headers="wq84">SIGBUS(7)</td>
<td headers="wq85">예외</td>
<td headers="wq86">잘못된 메모리 액세스(데이터 지정 오류)</td>
<td align="center" headers="wq87">예</td>
</tr>
<tr>
<td headers="wq84">SIGSEGV(11)</td>
<td headers="wq85">예외</td>
<td headers="wq86">잘못된 메모리 액세스(액세스할 수 없는 메모리에 쓰기)</td>
<td align="center" headers="wq87">예</td>
</tr>
<tr>
<td headers="wq84">SIGILL(4)</td>
<td headers="wq85">예외</td>
<td headers="wq86">잘못된 명령어(알수 없는 시스템 명령을 호출하려는 시도)</td>
<td align="center" headers="wq87">아니오</td>
</tr>
<tr>
<td headers="wq84">SIGFPE(8)</td>
<td headers="wq85">예외</td>
<td headers="wq86">부동 소수점 예외(0으로 나누기)</td>
<td align="center" headers="wq87">예</td>
</tr>
<tr>
<td headers="wq84">SIGABRT(6)</td>
<td headers="wq85">오류</td>
<td headers="wq86">비정상 종료. JVM 결함을 발견할 때마다 JVM이 이 신호를 일으킵니다.</td>
<td align="center" headers="wq87">예</td>
</tr>
<tr>
<td headers="wq84">SIGINT(2)</td>
<td headers="wq85">인터럽트</td>
<td headers="wq86">대화식 주의(CTRL-C). JVM이 정상 종료합니다.</td>
<td align="center" headers="wq87">예</td>
</tr>
<tr>
<td headers="wq84">SIGTERM(15)</td>
<td headers="wq85">인터럽트</td>
<td headers="wq86">종료 요청. JVM이 정상 종료합니다.</td>
<td align="center" headers="wq87">예</td>
</tr>
<tr>
<td headers="wq84">SIGHUP(1)</td>
<td headers="wq85">인터럽트</td>
<td headers="wq86">끊기. JVM이 정상 종료합니다.</td>
<td align="center" headers="wq87">예</td>
</tr>
<tr>
<td headers="wq84">SIGQUIT(3)</td>
<td headers="wq85">제어</td>
<td headers="wq86">단말기에 대한 종료 신호. 기본적으로
Javadump를 트리거합니다.</td>
<td align="center" headers="wq87">예</td>
</tr>
<tr>
<td headers="wq84">SIGTRAP(5)</td>
<td headers="wq85">제어</td>
<td headers="wq86">JIT에서 사용됩니다.</td>
<td align="center" headers="wq87">예</td>
</tr>
<tr>
<td headers="wq84">__SIGRTMAX - 2</td>
<td headers="wq85">제어</td>
<td headers="wq86">SDK에서 사용됩니다.</td>
<td align="center" headers="wq87">아니오</td>
</tr>
<tr>
<td headers="wq84">SIGCHLD(17)</td>
<td headers="wq85">제어</td>
<td headers="wq86">내부 제어 목적으로 SDK에서 사용됩니다.</td>
<td align="center" headers="wq87">아니오</td>
</tr>
</tbody>
</table></p>
<p>
<p>JVM이 대부분의 신호를 처리하지 않도록 하려면 <strong>-Xrs</strong>(신호 사용 단축) 옵션을
사용하십시오. 자세한 정보는
<a href="http://java.sun.com/javase/6/docs/technotes/tools/windows/java.html" target="_blank">Sun의
Java 응용프로그램 실행기 페이지</a>를 참조하십시오.</p></p>
<p>
<p>JVM 스레드의 신호 1(SIGHUP), 2(SIGINT), 4(SIGILL), 7(SIGBUS), 8(SIGFPE), 11(SIGSEGV) 및 15(SIGTERM)를 사용하면 JVM이 종료됩니다. 따라서 응용프로그램 신호 핸들러에 JVM 서비스가 필요한 경우를 제외하고 이를 복구를 시도하지 말아야 합니다.</p></p>
<a name="native_signals"></a>
<h3 id="native_signals"><a href="#ToC_67">신호 체인 라이브러리에 원시 코드 드라이버 링크</a></h3>
<div>
<p>Runtime Environment에는 신호 체인 기능이 포함되어 있습니다. 신호 체인 기능으로 JVM은
자체 신호 핸들러를 설치하는 원시 코드와 보다 효율적으로 공동 조작할 수
있습니다.</p></div>
<p>
<p>신호 체인을 사용하여 응용프로그램에서
공유 라이브러리 libjsig.so를 시스템 라이브러리 전에 링크하고
로드할 수 있습니다.  libjsig.so 라이브러리는
signal(), sigset() 및 sigaction()과 같은 호출을 차단하여
해당 핸들러가 JVM의 신호 핸들러를 대체하지 않도록 합니다. 대신, 이들 호출은 새 신호 핸들러를 저장하거나 이를 JVM이 설치된 핸들러 뒤에 "체인"합니다. 따라서 나중에 이들 신호 중 하나가 발생되고 JVM을 대상으로 하지 않은 경우, 사전 설치된
핸들러가 호출됩니다.</p>
<p>sigaction()을 사용하는 신호 핸들러를 설치할 경우,
JVM이 이 신호를 사용할 때 일부 <strong>sa_flags</strong>가 관찰되지 않습니다. 이들은 다음과 같습니다.

</p>
<ul>
<li>SA_NOCLDSTOP - 항상 설정 해제</li>
<li>SA_NOCLDWAIT - 항상 설정 해제</li>
<li>SA_RESTART - 항상 설정</li></ul>
<p>libjsig.so 라이브러리는
또한 JVM 신호 핸들러를 응용프로그램에서 숨깁니다. 따라서 JVM이 시작된 후에 작성된 signal(), sigset() 및 sigaction()과
같은 호출은 더 이상 JVM 신호 핸들러에 대한 참조를 리턴하지 않지만, 대신 JVM이 시작되기 전에
설치된 모든 핸들러를 리턴합니다.</p>
<p>libjsig.so를 사용하려면 다음과 같이 하십시오.

</p>
<ul>
<li>libjsig.so를 JVM을 작성하거나 임베드하는 응용프로그램과 링크시키십시오.

<pre class="xmp">gcc -L$JAVA_HOME/bin -ljsig -L$JAVA_HOME/bin/j9vm -ljvm java_application.c</pre>또는</li>
<li><strong>LD_PRELOAD</strong> 환경 변수를 사용하십시오.

<pre class="xmp">export LD_PRELOAD=$JAVA_HOME/bin/libjsig.so; java_application (bash and ksh)

setenv LD_PRELOAD=$JAVA_HOME/bin/libjsig.so; java_application (csh)</pre></li></ul>
<p>환경 변수 <strong>JAVA_HOME</strong>은
SDK의 위치로 설정되어야 합니다(예: /opt/ibm/java-i386-60/).</p>
<p>libjsig.a를 사용하려면 다음을 수행하십시오. 
</p>
<ul>
<li>libjsig.so를 JVM을 작성하거나 임베드하는 응용프로그램과 링크시키십시오.

<pre class="xmp">cc_r -q64 &lt;other compile/link parameter&gt; -L/opt/ibm/java-i386-60/jre/bin -ljsig 
-L/opt/ibm/java-i386-60/jre/bin/j9vm -ljvm java_application.c</pre> 
<a name="wq91"></a>
<div class="note-noindent" id="wq91">
<span class="notetitle">주:</span> <span class="notebody">컴파일러나
링커를 정상적으로 호출하는 방법인 경우 <tt class="xph">cc_r</tt> 대신 <tt class="xph">xlc_r</tt> 또는 <tt class="xph">xlC_r</tt>을 사용하십시오.</span></div></li></ul></p>
<a name="usejni"></a>
<h2 id="usejni"><a href="#ToC_68">JNI 응용프로그램 작성</a></h2>
<div>
<p>원시 프로그램에서 JNI_CreateJavaVM() API 호출에 지정할 수 있는 올바른 JNI 버전 번호는
JNI_VERSION_1_2(0x00010002)와 JNI_VERSION_1_4(0x00010004)입니다.</p></div>
<a name="wq92"></a>
<div class="note-noindent" id="wq92">
<span class="notetitle">제한사항:</span> <span class="notebody">JNI(Java Native Interface) 버전 1.1은 지원되지 않습니다.</span></div>
<p>이 버전 번호는 사용할 JNI 원시 인터페이스의 레벨만 결정합니다.
작성되는 JVM의 실제 레벨은 JSE 라이브러리(v6)에 의해 지정됩니다.
JNI 인터페이스 API는 JVM, 클래스 라이브러리 API 또는
JVM 작동의 기타 영역에 의해 구현되는 언어 스펙에 영향을 주지 <em>않습니다</em>.  자세한 정보는 웹 사이트 <a href="http://java.sun.com/javase/6/docs/technotes/guides/jni/" target="_blank">http://java.sun.com/javase/6/docs/technotes/guides/jni/</a>의 내용을 참조하십시오.</p>
<p>응용프로그램에 두 개의 JNI 라이브러리(32비트용으로
빌드된 라이브러리와 64비트용으로 빌드된 다른 라이브러리)가 필요한 경우 <strong>com.ibm.vm.bitmode</strong> 시스템
특성을 사용하여 32 또는 64비트 JVM으로 실행 중인지 판별하고 적절한 라이브러리를 선택하십시오.</p>
<p>SDK를 사용하여
원시 프로그램을 컴파일하고 링크하려면 다음 명령을 사용하십시오. </p>
<pre class="xmp">gcc -I/opt/ibm/java-i386-60/include -L/opt/ibm/java-i386-60/jre/lib/&lt;arch&gt;/j9vm 
-ljvm -ldl -lpthread &lt;JNI program filename&gt;</pre><strong>-ljvm</strong><p class="indatacontent"> 옵션은 libjvm.so가 JVM을 구현하는 공유 라이브러리가 되도록
지정합니다. <strong>-lpthread</strong> 옵션은
원시 pthread 지원을 사용 중임을 표시합니다. pthread 라이브러리와 링크하지 않으면
JNI 프로그램 실행 시 세그먼트화 결함(신호 SIGSEGV)이 발생할 수
있습니다.</p>
<a name="blocked_threads"></a>
<h2 id="blocked_threads"><a href="#ToC_69">블록된 커넥터의 스레드 레벨 복구 지원</a></h2>
<div>
<p>블록된 커넥터의 스레드 레벨 복구를 지원하기 위해 네 개의 새로운 IBM 특정 SDK 클래스가
com.ibm.jvm 패키지에 추가되었습니다. 새 클래스는
core.jar에 패키지화됩니다.</p></div>
<p>이 클래스를 사용하여 네트워킹 또는 동기화 호출에서 블록된 스레드의 블록을 해제할 수 있습니다. 응용프로그램에서 이들 클래스를 사용하지 않으면
블록된 개별 스레드를 인터럽트하는 대신, 전체 프로세스를
종료해야 합니다.</p>
<p>클래스는 다음과 같습니다.</p>
<dl class="parml">
<dt class="bold">public interface InterruptibleContext</dt>
<dd>isBlocked()와 unblock()의 두 메소드를 정의합니다.
다른 세 클래스는
InterruptibleContext를 구현합니다.
</dd>
<dt class="bold">public class InterruptibleLockContext</dt>
<dd>동기화 호출을 인터럽트하는 유틸리티 클래스입니다.
</dd>
<dt class="bold">public class InterruptibleIOContext</dt>
<dd>네트워크 호출을 인터럽트하는 유틸리티 클래스입니다.
</dd>
<dt class="bold">public class InterruptibleThread</dt>
<dd>인터럽트 가능한 메소드를 랩핑할 수 있도록 java.lang.Thread를 확장하는
유틸리티 클래스입니다. InterruptibleLockContext 및 InterruptibleIOContext의 동기화
또는 네트워크 조작이 스레드를 블로킹 중인지 여부에 따라 인스턴스를 사용하여 필요한
isBlocked() 및 unblock() 메소드를 수행합니다.
</dd>
</dl>
<p>InterruptibleLockContext와 InterruptibleIOContext는 모두 현재 스레드를
참조하여 작동합니다. 그러므로 InterruptibleThread를 사용하지 않는 경우
이러한 새 클래스를 사용하려면 자체 클래스를 제공하여 java.lang.Thread를 확장해야 합니다.</p>
<p>이 클래스의 Javadoc이 SDK와 함께 docs/content/apidoc 디렉토리에 제공됩니다.</p>
<a name="alloc_large_page"></a>
<h2 id="alloc_large_page"><a href="#ToC_70">대형 페이지 메모리 할당 구성</a></h2>
<div>
<p>대형 페이지를 지원하는 시스템의 경우 <strong>-Xlp</strong> 옵션으로
Java를 시작하여
대형 페이지 지원을 사용할 수 있습니다.</p></div>
<p>
<p>대형 페이지는 주로 메모리를 대량으로 할당하고 메모리에 자주 액세스하는
응용프로그램의 성능을 향상시키기 위해 사용합니다.
주로 TLB(Translation Lookaside Buffer)의 실패를 줄임으로써 대형 페이지의
성능을 향상시킬 수 있습니다. TLB는 더 큰 가상 메모리 범위를
맵핑하므로 이와 같이 성능이 향상됩니다.</p>
<p>대형 페이지 지원은 커널에서 사용 가능하며,
이를 사용하여 Java에서
대형 페이지를 사용할 수 있습니다.</p>
<p>대형 페이지 메모리 할당을 구성하려면 먼저, 실행 중인 커널이 대형 페이지를 지원하는지
확인하십시오. /proc/meminfo 파일에 다음 행이 있는지 확인하십시오. </p>
<pre class="xmp">HugePages_Total:     &lt;number of pages&gt;
HugePages_Free:      &lt;number of pages&gt;
Hugepagesize:        &lt;page size, in kB&gt;</pre><p class="indatacontent">사용 가능한 페이지 수와 크기는 분배에 따라
다릅니다.</p>
<p>커널에서 대형 페이지 지원을 사용할 수 없는 경우,
/proc/meminfo 파일에 이러한 행이 없습니다. 이 때는 대형 페이지 지원이
포함된 새 커널을 설치해야 합니다.</p>
<p>대형 페이지 지원을 사용할 수 있으나, 사용 가능으로 되어 있지 않은 경우에는 <tt class="xph">HugePages_Total</tt> 값이 0이 됩니다. 이 경우, 관리자가 대형 페이지 지원을 사용 가능하게
해야 합니다. 자세한 지시사항은 운영 체제 안내서를 확인하십시오.</p>
<p>JVM에서 대형 페이지를 사용하려면 사용 가능한 적절한 수의
연속된 대형 페이지가 시스템에 있어야 합니다. 사용 가능한 페이지가 충분한데도 대형 페이지를 할당할 수 없는 경우,
대형 페이지는 연속되지 않습니다. 부팅 시 대형 페이지의 수를 구성하여
연속으로 작성할 수 있습니다. </p>
<p>대형 페이지 할당은 JVM이 루트 액세스 권한을 가지는 경우에만 성공합니다. 대형 페이지를
사용하려면 Java를 루트로 실행하거나
Java 실행기의 SUID 비트를
설정하십시오.</p></p>
<a name="corba"></a>
<h2 id="corba"><a href="#ToC_71">CORBA 지원</a></h2>
<div>
<p>Java,
Standard Edition(JSE)은 최소한 Sun의 준수 문서에서 정의된 스펙을 지원합니다. 일부 경우,
IBM JSE ORB는 해당 스펙의
더 최신 버전을 지원합니다.</p></div>
<p>지원되는 최소 스펙은
<a href="http://java.sun.com/javase/6/docs/api/org/omg/CORBA/doc-files/compliance.html" target="_blank">Java
SE 6의 CORBA 지원을 위한 공식 스펙</a>에서 정의됩니다.</p>
<p>
<a name="corba__corba_giop"></a>
<h3 id="corba__corba_giop">GIOP 1.2 지원</h3>
<p>이 SDK는
OMG 문서 <cite>formal/99-10-07</cite>에서 CORBA 2.3.1 스펙의 제13장 및 제15장에 정의된 모든 GIOP 버전을
지원합니다.</p>
<p><a href="http://www.omg.org/cgi-bin/doc?formal/99-10-07" target="_blank">http://www.omg.org/cgi-bin/doc?formal/99-10-07</a></p>
<p>양방향 GIOP는 지원되지 않습니다.</p></p>
<p>
<a name="corba__corba_support_intercepters"></a>
<h3 id="corba__corba_support_intercepters">휴대용 인터셉터 지원</h3>
<p>이 SDK는 <cite>ptc/01-03-04</cite> 문서에서
OMG가 정의한 대로 휴대용 인터셉터를 지원합니다. 이 문서는 다음 웹 사이트에서 찾아볼 수 있습니다.</p>
<p><a href="http://www.omg.org/cgi-bin/doc?ptc/01-03-04" target="_blank">http://www.omg.org/cgi-bin/doc?ptc/01-03-04</a></p>
<p>휴대용
인터셉터는 ORB 서비스가 ORB의 정상적인 실행 플로우를 인터셉트하는 데 사용할 수 있는 ORB에 연결될 수 있습니다.</p></p>
<p>
<a name="corba__corba_interop_naming"></a>
<h3 id="corba__corba_interop_naming">상호 운용 가능한 이름 지정 서비스
지원</h3>
<p>이 SDK는 <cite>ptc/00-08-07</cite> 문서에서
OMG가 정의한 대로 상호 운용 가능한 이름 지정 서비스를 지원합니다. 이 문서는 다음에서 찾아볼 수 있습니다.</p>
<p><a href="http://www.omg.org/cgi-bin/doc?ptc/00-08-07" target="_blank">http://www.omg.org/cgi-bin/doc?ptc/00-08-07</a></p>
<p><strong>ORBInitialPort</strong> 매개변수가
지정되지 않은 경우 이름 서버(tnameserv 명령)에서 사용되는 기본 포트는
<em>900</em>에서 <em>2809</em>로 변경되었습니다. 이 숫자는 CORBA 이름 지정 서비스에 대한 IANA(Internet Assigned
Number Authority)에 등록된 포트 번호입니다.
이 기본값을 사용하는 프로그램의 경우
이 버전에서 작동하려면 업데이트해야 할 수도 있습니다.</p>
<p>임시 이름 서버에서 리턴된 초기 컨텍스트는 이제
org.omg.CosNaming.NamingContextExt입니다. 참조 범위를
org.omg.CosNaming.NamingContext 컨텍스트로 좁힌 기존 프로그램은 계속해서 작동되므로 다시 컴파일할 필요가 없습니다.</p>
<p>ORB는 상호 운용 가능한 이름 지정 서비스 스펙에서 정의된
<strong>-ORBInitRef</strong> 및 <strong>-ORBDefaultInitRef</strong> 매개변수를 지원하며,
ORB::string_to_object 조작은 상호 운용 가능한 이름 지정 스펙에서 정의된
ObjectURL 문자열 형식(corbaloc: 및 corbaname:)을 지원합니다.</p>
<p>OMG는
상호 운용 가능한 이름 지정 서비스로 서비스를 등록하기 위해 ORB::register_initial_reference 메소드를
지정합니다. 그러나 이 메소드는 버전 6의
Sun Java Core API에서는 사용할 수 없습니다.
현재 버전에서 서비스를 등록해야 하는 프로그램은
IBM 내부 ORB 구현 클래스에서
이 메소드를 호출해야 합니다. 예를 들어, 『MyService』 서비스를 등록하려면 다음을
입력하십시오.</p>
<p> </p>
<pre class="xmp">((com.ibm.CORBA.iiop.ORB)orb).register_initial_reference("MyService",
serviceRef);</pre>
<p>여기서 <tt>orb</tt>는 ORB.init()에서 리턴된
org.omg.CORBA.ORB의 인스턴스이며, <tt>serviceRef</tt>는
ORB에 연결된 CORBA 오브젝트입니다. 이 메커니즘은
임시로 사용되며, 추후 버전과 호환되지 않고 비IBM ORB에 이식할 수 없습니다.</p></p>
<a name="corba_properties"></a>
<h3 id="corba_properties"><a href="#ToC_75">ORB 추적을 위한 시스템 특성</a></h3>
<div>
<p>런타임 디버그 기능은 개선된 서비스 가능성을 제공합니다. 이 기능은 문제점 진단에 유용하며
IBM 서비스 담당자가 요청할 수도 있습니다.</p></div>
<p>
<a name="wq94"></a>
<h4 id="wq94">추적 특성</h4></p>
<dl class="parml">
<dt class="bold"><strong>com.ibm.CORBA.Debug</strong>=<em>true</em></dt>
<dd>ORB 추적을 사용합니다.
</dd>
<dt class="bold"><strong>com.ibm.CORBA.CommTrace</strong>=<em>true</em></dt>
<dd>추적에 GIOP 메시지를 추가합니다(송수신).
</dd>
<dt class="bold"><strong>com.ibm.CORBA.Debug.Output</strong>=<em>&lt;file&gt;</em></dt>
<dd>추적 출력 파일을 지정합니다. 기본 형식은 orbtrc.DDMMYYYY.HHmm.SS.txt입니다.
</dd>
</dl>
<p>
<a name="wq95"></a>
<h4 id="wq95">ORB 추적의 예제</h4>
<p> 예를 들어, 이벤트 및 형식화된 GIOP 메시지를 추적하려면 명령행에서
다음을 입력하십시오.</p></p>
<pre class="xmp"> java -Dcom.ibm.CORBA.Debug=true  
     -Dcom.ibm.CORBA.CommTrace=true <em>&lt;myapp&gt;</em></pre>
<p>
<a name="wq96"></a>
<h4 id="wq96">제한사항</h4>
<p>시스템 성능을 저하시킬 수 있으므로 정상 운영 시에는 추적을
사용하지 마십시오. 추적을 사용하지 않도록 전환해도 FFDC(First Failure Data Capture)는 여전히 작동하므로
심각한 오류가 보고됩니다. 디버그 출력 파일이 생성되면 이를 검토하여 문제점을 확인하십시오. 예를 들어,
서버가 ORB.shutdown()을 수행하지 않고 중지되었을 수 있습니다.</p>
<p>추적 결과물의 내용과 포맷은 버전에 따라 다를 수 있습니다.</p></p>
<p></p>
<a name="corba_tuning"></a>
<h3 id="corba_tuning"><a href="#ToC_79">ORB 조정을 위한 시스템 특성</a></h3>
<div>
<p>특정 네트워크에 대해 잘 작동하도록 ORB를 조정할 수 있습니다. ORB를 조정하는 데 필요한 특성을
여기에서 설명합니다.</p></div>
<p></p>
<dl class="parml">
<dt class="bold"><strong>com.ibm.CORBA.FragmentSize</strong>=<em>&lt;size in bytes&gt;</em></dt>
<dd>GIOP 1.2 단편화를 제어하는 데 사용됩니다. 기본 크기는 1024바이트입니다. 

<p>단편화를 사용하지 않으려면 단편 크기를 0바이트로 설정하십시오. </p>
<pre class="xmp">java -Dcom.ibm.CORBA.FragmentSize=0 <em>&lt;myapp&gt;</em></pre>
</dd>
<dt class="bold"><strong>com.ibm.CORBA.RequestTimeout</strong>=<em>&lt;time in
seconds&gt;</em></dt>
<dd>CORBA Request의 최대 대기 시간을 설정하십시오. 기본적으로 ORB는 무기한
대기합니다. 시간 종료를 너무 짧게 설정하여 불필요한 연결 종료가 발생하지 않도록 하십시오.
</dd>
<dt class="bold"><strong>com.ibm.CORBA.LocateRequestTimeout</strong>=<em>&lt;time
in seconds&gt;</em></dt>
<dd>CORBA LocateRequest의 최대 대기 시간을 설정하십시오. 기본적으로 ORB는 무기한
대기합니다.
</dd>
<dt class="bold"><strong>com.ibm.CORBA.ListenerPort</strong>=<em>&lt;port number&gt;</em></dt>
<dd>ORB가 들어오는 요청을 읽을 포트를 설정하십시오. 이 등록 정보가 설정되면 ORB는 초기화된 후 바로 청취하기 시작합니다.
그렇지 않으면 필요한 경우에만 청취를 시작합니다.
</dd>
</dl>
<a name="corba_security"></a>
<h3 id="corba_security"><a href="#ToC_80">ORM에 대한 Java 보안 권한</a></h3>
<div>
<p>Java SecurityManager로
실행하는 경우 CORBA API 클래스의 일부 메소드를 호출하면 권한을 확인하므로
SecurityException이 발생할 수 있습니다.
프로그램이 이러한 메소드를 사용하는 경우, 필요한 권한을
부여받아야 합니다.</p></div>
<p></p>
<a name="corba_security__corbatable"></a>
<table id="corba_security__corbatable" width="100%" summary="" border="1" frame="border" rules="all">
<caption>표 8. Java SecurityManager로 실행하는 경우 영향을 받는 메소드</caption>
<thead valign="bottom">
<tr>
<th id="wq100" width="32%" align="left">클래스/인터페이스</th>
<th id="wq101" width="32%" align="left">메소드</th>
<th id="wq102" width="34%" align="left">필수 권한</th>
</tr>
</thead>
<tbody valign="top">
<tr>
<td headers="wq100">org.omg.CORBA.ORB</td>
<td headers="wq101">init</td>
<td headers="wq102">java.net.SocketPermission 분석</td>
</tr>
<tr>
<td headers="wq100">org.omg.CORBA.ORB</td>
<td headers="wq101">connect</td>
<td headers="wq102">java.net.SocketPermission 청취</td>
</tr>
<tr>
<td headers="wq100">org.omg.CORBA.ORB</td>
<td headers="wq101">resolve_initial_references</td>
<td headers="wq102">java.net.SocketPermission 연결</td>
</tr>
<tr>
<td headers="wq100">org.omg.CORBA. portable.ObjectImpl</td>
<td headers="wq101">_is_a</td>
<td headers="wq102">java.net.SocketPermission 연결</td>
</tr>
<tr>
<td headers="wq100">org.omg.CORBA. portable.ObjectImpl</td>
<td headers="wq101">_non_existent</td>
<td headers="wq102">java.net.SocketPermission 연결</td>
</tr>
<tr>
<td headers="wq100">org.omg.CORBA. portable.ObjectImpl</td>
<td headers="wq101">OutputStream _request(String, boolean)</td>
<td headers="wq102">java.net.SocketPermission 연결</td>
</tr>
<tr>
<td headers="wq100">org.omg.CORBA. portable.ObjectImpl</td>
<td headers="wq101">_get_interface_def</td>
<td headers="wq102">java.net.SocketPermission 연결</td>
</tr>
<tr>
<td headers="wq100">org.omg.CORBA. Request</td>
<td headers="wq101">invoke</td>
<td headers="wq102">java.net.SocketPermission 연결</td>
</tr>
<tr>
<td headers="wq100">org.omg.CORBA. Request</td>
<td headers="wq101">send_deferred</td>
<td headers="wq102">java.net.SocketPermission 연결</td>
</tr>
<tr>
<td headers="wq100">org.omg.CORBA. Request</td>
<td headers="wq101">send_oneway</td>
<td headers="wq102">java.net.SocketPermission 연결</td>
</tr>
<tr>
<td headers="wq100">javax.rmi. PortableRemoteObject</td>
<td headers="wq101">narrow</td>
<td headers="wq102">java.net.SocketPermission 연결</td>
</tr>
</tbody>
</table>
<a name="corba_classes"></a>
<h3 id="corba_classes"><a href="#ToC_81">ORB 구현 클래스</a></h3>
<div>
<p>ORB 구현 클래스의 목록입니다.</p></div>
<p>
<p>이 릴리스의 ORB 구현 클래스는 다음과 같습니다.

</p>
<ul>
<li>org.omg.CORBA.ORBClass=com.ibm.CORBA.iiop.ORB</li>
<li>org.omg.CORBA.ORBSingletonClass=com.ibm.rmi.corba.ORBSingleton</li>
<li>javax.rmi.CORBA.UtilClass=com.ibm.CORBA.iiop.UtilDelegateImpl</li>
<li>javax.rmi.CORBA.StubClass=com.ibm.rmi.javax.rmi.CORBA.StubDelegateImpl</li>
<li>javax.rmi.CORBA.PortableRemoteObjectClass=com.ibm.rmi.javax.rmi.PortableRemoteObject</li></ul>
<p>이것이 기본값이며, 이러한 등록 정보를 설정하거나
구현 클래스를 직접 참조하지 않는 것이 좋습니다. 이식성의 경우,
구현이 아닌 CORBA API 클래스에 대한 참조만 작성하십시오. 이 값은
추후 릴리스에서 변경될 수 있습니다.</p></p>
<a name="rmi-iiop"></a>
<h2 id="rmi-iiop"><a href="#ToC_82">RMI over IIOP</a></h2>
<div>
<p>Java RMI(Remote Method Invocation)는
분배된 Java 프로그래밍을 위한
단순한 매커니즘을 제공합니다. RMI-IIOP(RMI over IIOP)는 CORBA(Common Object Request Broker Architecture) 표준
IIOP 프로토콜(Internet Inter-ORB Protocol)을 사용하여 통신을 수행하도록 기본
Java RMI를
확장합니다. 이를 사용하면 Java로 구현되었는지 또는
다른 프로그래밍 언어로 구현되었는지에 관계 없이 다른 CORBA ORB(Object Request Broker)와 직접 상호작용할 수 있습니다.</p></div>
<p>다음 문서를 참조하십시오.</p>
<ul>
<li><a href="http://www.ibm.com/developerworks/java/rmi-iiop" target="_blank">RMI-IIOP Programmer's Guide</a>는
RMI-IIOP 프로그램 작성에 대해 설명합니다.</li>
<li><a href="http://www.omg.org/cgi-bin/doc?ptc/00-01-06.pdf" target="_blank">Java Language
to IDL Mapping</a> 문서는 RMI-IIOP의 자세한 기술 스펙입니다.</li></ul>
<a name="rmi"></a>
<h2 id="rmi"><a href="#ToC_83">RMI 연결 핸들러 풀 구현</a></h2>
<div>
<p>기본적으로 RMI 연결 핸들러의 스레드 풀링은 사용할 수
없습니다.</p></div>
<p>
<p>TCPTransport 레벨에서 구현된 연결 풀링을 사용하려면
다음 옵션을 설정하십시오. </p>
<pre class="xmp">-Dsun.rmi.transport.tcp.connectionPool=true</pre>
<p>이 버전의 Runtime Environment에는
연결 풀의 스레드 수를 제한할 수 있는 설정이 없습니다.</p></p>
<a name="bigd"></a>
<h2 id="bigd"><a href="#ToC_84">향상된 BigDecimal</a></h2>
<div>
<p>Java 5.0부터
Sun사가 IBM BigDecimal 클래스를
java.math.BigDecimal로 채택했습니다. com.ibm.math.BigDecimal 클래스는
IBM에서 나중에 사용할 수 있도록 예약되어 있지만 현재 사용할 수 없습니다. java.math.BigDecimal을
사용하려면 기존의 Java 코드를 이주하십시오.</p></div>
<p>새 java.math.BigDecimal은 이전의
java.math.BigDecimal 및 com.ibm.math.BigDecimal 둘 다와 동일한 메소드를 사용합니다.
java.math.BigDecimal을 사용하는 기존 코드는 계속 올바르게 작동합니다. 두 클래스는 직렬화하지 않습니다.</p>
<p>java.math.BigDecimal 클래스를 사용하도록 기존
Java 코드를 이주하려면
.java 파일 맨 위의 import 문을 <tt class="xph">import com.ibm.math.*;</tt>에서
<tt class="xph">import java.math.*;</tt>로 변경하십시오.</p>
<a name="deploying"></a>
<h1 id="deploying"><a href="#ToC_85">Plug-in, 애플릿 뷰어 및
Web Start</a></h1>
<div>
<p>Java Plug-in은 브라우저 내에서 Java 응용프로그램을 실행하는 데 사용됩니다. appletviewer는
브라우저에서 실행되도록 설계된 응용프로그램을 테스트하는 데 사용됩니다. Java Web
Start는 네트워크상의 데스크탑 Java 응용프로그램을 배치하는 데 사용되며
이러한 응용프로그램을 최신으로 유지하는 데 필요한 메커니즘을 제공합니다.</p></div>
<a name="using_plugin"></a>
<h2 id="using_plugin"><a href="#ToC_86"><strong><span class="bold-italic">(Linux IA 32비트 및 PPC32에만 해당) </span></strong>
Java Plug-in 사용</a></h2>
<div>
<p>Java Plug-in은 웹 브라우저 플러그인입니다. Java Plug-in을 사용하여
브라우저에서 애플릿을 실행합니다.</p></div>
<p>브라우저가 정지되지 않게 하려면 애플릿이 로드를 완료할 수 있도록 해야 합니다.
예를 들어, 애플릿이 로드하는 동안 <strong>뒤로</strong> 단추 및 <strong>앞으로</strong> 단추를 사용하면 HTML 페이지가 로드되지 않을 수 있습니다.</p>
<p>Java Plug-in은 <a href="http://java.sun.com/javase/6/docs/technotes/guides/plugin/developer_guide/" target="_blank">http://java.sun.com/javase/6/docs/technotes/guides/plugin/developer_guide/</a>에 있는 Sun에서 문서화되었습니다.</p>
<a name="suppbrowse"></a>
<h3 id="suppbrowse"><a href="#ToC_87">지원되는 브라우저</a></h3>
<div>
<p>Java Plug-in은 SeaMonkey, Mozilla,  및 Mozilla Firefox를 지원합니다.</p></div>
<p></p>
<a name="suppbrowse__plugintable"></a>
<table id="suppbrowse__plugintable" width="100%" summary="" border="1" frame="border" rules="all">
<caption>표 9. Linux IA32용 Java Plug-in에서 지원되는 브라우저</caption>
<thead valign="bottom">
<tr>
<th id="wq106" width="50%" align="left" valign="top">브라우저</th>
<th id="wq107" width="50%" align="left" valign="top">지원되는 버전</th>
</tr>
</thead>
<tbody valign="top">
<tr>
<td headers="wq106">Mozilla</td>
<td headers="wq107">1.7.12, 1.8</td>
</tr>
<tr>
<td headers="wq106">Firefox</td>
<td headers="wq107">1.5, 2.0</td>
</tr>
</tbody>
</table>
<a name="suppbrowse__plugintable-ppc32"></a>
<table id="suppbrowse__plugintable-ppc32" width="100%" summary="" border="1" frame="border" rules="all">
<caption>표 10. Linux PPC32용 Java Plug-in에서 지원되는 브라우저.</caption>
<thead valign="bottom">
<tr>
<th id="wq108" width="50%" align="left" valign="top">브라우저</th>
<th id="wq109" width="50%" align="left" valign="top">지원되는 버전</th>
</tr>
</thead>
<tbody valign="top">
<tr>
<td headers="wq108">Mozilla</td>
<td headers="wq109">1.6</td>
</tr>
<tr>
<td headers="wq108"><font color="RED"><span id="changed">|</span>SeaMonkey</font></td>
<td headers="wq109"><font color="RED"><span id="changed">|</span>1.0.8</font></td>
</tr>
</tbody>
</table>
<p>약간 차후 릴리스의 브라우저만 지원됩니다.</p>
<a name="installing_plugin"></a>
<h3 id="installing_plugin"><a href="#ToC_88">Java Plug-in 설치 및 구성</a></h3>
<div>
<p>Java Plug-in을 설치하려면
기호를 사용하여 Plug-in을 웹 브라우저의 Plug-in 디렉토리에 링크합니다.</p></div>
<p>Java Plug-in은
Mozilla의 <a href="http://www.mozilla.org/oji/" target="_blank">Open JVM
Integration</a> 시작을 기반으로 하며, Firefox를 포함하여 대부분의 Mozilla 제품 및 파생 제품에서 사용됩니다.</p>
<p>일반적인 브라우저에 Plug-in을 설치하는 지시사항은 다음과 같습니다.</p>
<p>Plug-in을 복사하지 말고 기호를 사용하여 링크하면 JVM의 위치를 찾을 수 있습니다.</p>
<a name="mozilla"></a>
<h4 id="mozilla">Mozilla</h4>
<p>
<p>지원되는 Mozilla 버전은 1.4 이상입니다.</p></p>
<ol type="1">
<li>루트로 로그인하십시오.</li>
<li>Mozilla 플러그인 디렉토리로 변경하십시오(일부
Linux 배포판에서는 다를 수 있음). 

<ul>
<li>모든 사용자가 플러그인을 사용할 수 있도록 하려면: 
<pre class="xmp"> cd /usr/local/mozilla/plugins/</pre></li>
<li>현재 사용자만 플러그인을 사용할 수 있도록 하려면: 
<pre class="xmp">cd $HOME/.mozilla/plugins</pre></li></ul></li>
<li>Plug-in에 대한 기호 링크를 작성하십시오. 
<pre class="xmp"> ln -s /opt/ibm/java-i386-60/jre/plugin/&lt;arch&gt;/ns7/libjavaplugin_oji.so.</pre> 여기서 &lt;arch&gt;는 시스템의 아키텍처입니다.</li></ol>
<p>
<p>Java Plug-in이
사용 가능한지 확인하려면 Mozilla에서 <strong>도움말</strong> -&gt; <strong> 플러그인
정보</strong>를 선택하십시오.</p></p>
<p>
<p>Plug-in을 복사하지 말고 기호를 사용하여 링크하면 JVM의 위치를 찾을 수 있습니다.</p></p>
<a name="wq114"></a>
<div class="note-noindent" id="wq114">
<span class="notetitle">제한사항:</span> <span class="notebody">/usr/local/mozilla/plugins/에는
Java Plug-in
공유 디렉토리가 <em>하나</em>만 있을 수 있습니다.
Mozilla는 이 디렉토리(또는 그 아래의 서브디렉토리)에 있는 모든 것을 플러그인으로 로드하려고 시도하며,
두 버전의 Java Plug-in이 로드되는 경우
결과를 예측할 수 없습니다.</span></div>
<a name="lnx_firefox"></a>
<h4 id="lnx_firefox">Firefox</h4>
<p>  이 단계에서는 모든 사용자가 Java Plug-in을 사용할 수 있도록 합니다.</p>
<ol type="1">
<li>루트로 로그인하십시오.</li>
<li>Firefox Plug-in 디렉토리로 변경하십시오(일부
Linux 배포판에서는 다를 수 있음). 
<pre class="xmp">cd /usr/local/mozilla-firefox/plugins/</pre></li>
<li>Plug-in에 대한 기호 링크를 작성하십시오. 
<pre class="xmp"> ln -s /opt/ibm/java-i386-60/jre/plugin/&lt;arch&gt;/ns7/libjavaplugin_oji.so.</pre> 여기서 &lt;arch&gt;는 시스템의 아키텍처입니다.</li></ol>
<p>Plug-in을 복사하지 말고 기호를 사용하여 링크하면 JVM의 위치를 찾을 수 있습니다.</p>
<a name="plugin_dom"></a>
<h3 id="plugin_dom"><a href="#ToC_91">공통 DOM(Document Object Model) 지원</a></h3>
<div>
<p>특정 브라우저의 제한사항 때문에 org.w3c.dom.html 패키지의 모든 기능을 구현하지 못할 수도 있습니다.</p></div>
<p>
<p>다음 중 하나의 오류가 발생할 수 있습니다. 
</p>
<ul>
<li>일부 기능에서는 sun.plugin.dom.exception.InvalidStateException이
발생합니다.</li>
<li>브라우저가 특정 기능을 지원하지 않는 경우 sun.plugin.dom.exception.NotSupportedException이
발생합니다.</li></ul></p>
<a name="plugin_dbcs"></a>
<h3 id="plugin_dbcs"><a href="#ToC_92">DBCS 매개변수 사용</a></h3>
<div>
<p>Java Plug-in은
<tt class="xph">&lt;APPLET&gt;</tt>, <tt class="xph">&lt;OBJECT&gt;</tt> 및
<tt class="xph">&lt;EMBED&gt;</tt> 태그에 대해 2바이트 문자(예: 대만어 BIG-5, 한국어, 일본어를 매개변수로 지원합니다. Java Plug-in이
매개변수를 구문 분석할 수 있도록 HTML 문서에 올바른 문자 인코딩을 선택해야 합니다.</p></div>
<p>
<p>다음과 같이
<tt class="xph">&lt;HEAD&gt;</tt> 섹션에서 <tt class="xph">&lt;META&gt;</tt> 태그를 사용하여 HTML 문서에 문자 인코딩을
지정하십시오. </p>
<pre class="xmp">&lt;meta http-equiv="Content-Type" content="text/html; charset=big5"&gt;</pre><p class="indatacontent">이 예제에서는 중국어 BIG-5 문자 인코딩을 사용하여 HTML 파일을 구문 분석하도록
브라우저에 지시합니다.</p></p>
<a name="applets"></a>
<h2 id="applets"><a href="#ToC_93">애플릿에 대한 작업</a></h2>
<div>
<p>애플릿 뷰어에서 APPLET 태그를 사용하여 웹 페이지(HTML 파일)에서
참조로 호출된 하나 이상의 애플릿을 실행할 수 있습니다.
애플릿 뷰어는 HTML 파일에서 APPLET 태그를 찾아 태그에 지정된 대로 별도의 창에서
애플릿을 실행합니다.</p></div>
<p>애플릿 뷰어는 애플릿을 보기 위한 것이므로 여러 HTML 태그를 포함한
전체 웹 페이지를 표시할 수는 없습니다. 애플릿 뷰어는 APPLET 태그만 구문 분석하며
웹 페이지의 기타 HTML은 분석하지 않습니다.</p>
<a name="applet_viewer"></a>
<h3 id="applet_viewer"><a href="#ToC_94">애플릿 뷰어로 애플릿 실행</a></h3>
<div>
<p>애플릿 뷰어로 애플릿을 실행하려면 다음 명령을 사용하십시오.</p></div>
<p>
<p>쉘 프롬프트에서 다음을
입력하십시오.</p></p>
<pre class="xmp">   appletviewer <em>&lt;name&gt;</em></pre>
<p>여기서, <em>&lt;name&gt;</em>은 다음 중 하나입니다.</p>
<ul>
<li>애플릿을 호출하는 HTML 파일의 이름</li>
<li>애플릿을 호출하는 웹 페이지의 URL</li></ul>
<p>예를 들어, 애플릿을 호출하는 HTML 파일에서 애플릿 뷰어를 호출하려면
쉘 프롬프트에 다음을 입력하십시오.</p>
<pre class="xmp">  appletviewer $HOME/<em>&lt;filename&gt;</em>.html</pre>
<p>여기서
<em>filename</em>은 HTML 파일의 이름입니다.</p>
<p>웹 페이지에서 애플릿 뷰어를 호출하려면
쉘 프롬프트에 다음을 입력하십시오.</p>
<pre class="xmp">appletviewer http://java.sun.com/applets/NervousText/example1.html</pre>
<p>애플릿 뷰어는 &lt;META&gt; 태그의 <strong>charset</strong> 옵션을 인식하지
못합니다. 애플릿 뷰어가 로드한 파일이 시스템 기본값으로 인코드되지 않은 경우 I/O 예외가
발생할 수 있습니다. 이러한 예외가 발생하지 않도록 하려면
appletviewer를 실행할 때 <strong>-encoding</strong> 옵션을 사용하십시오. 예를 들면 다음과 같습니다.
</p>
<pre class="xmp">appletviewer -encoding JISAutoDetect sample.html</pre>
<a name="applet_debugging"></a>
<h3 id="applet_debugging"><a href="#ToC_95">애플릿 뷰어로 애플릿 디버깅</a></h3>
<div>
<p>애플릿 뷰어의 <strong>-debug</strong> 옵션을 사용하여
애플릿을 디버그할 수 있습니다.</p></div>
<p>
<p>예를 들면 다음과 같습니다.</p></p>
<pre class="xmp">cd demo/applets/TicTacToe
../../../bin/appletviewer -debug example1.html</pre>
<p>애플릿 뷰어를 사용하여 애플릿을 디버그하는 방법에 대한 문서는 Sun 웹 사이트(<a href="http://java.sun.com/javase/6/docs/technotes/guides/plugin/developer_guide/debugger.html" target="_blank">http://java.sun.com/javase/6/docs/technotes/guides/plugin/developer_guide/debugger.html</a>)에 있습니다.</p>
<a name="using_webstart"></a>
<h2 id="using_webstart"><a href="#ToC_96"><strong><span class="bold-italic">(Linux IA 32-bit,
PPC32 및 PPC64에만 해당)</span></strong> Web Start 사용</a></h2>
<div>
<p>Java Web Start는
Java 응용프로그램 배치에 사용됩니다.</p></div>
<p>
<p>Web Start를 사용하여 웹에서 응용프로그램을 직접 실행하고 관리할 수 있습니다. 응용프로그램은 설치 시간을
최소화하기 위해 캐시됩니다. 새 버전을 사용할 수 있는 경우 응용프로그램은 자동으로 업그레이드됩니다.</p></p>
<p>
<p>Web Start는 웹 사이트 <a href="http://java.sun.com/javase/6/docs/technotes/guides/javaws/developersguide/syntax.html#resources" target="_blank">http://java.sun.com/javase/6/docs/technotes/guides/javaws/developersguide/syntax.html#resources</a>에 문서화된 다음과 같은 java-vm-args를 지원합니다. 
</p>
<ul>
<li>-verbose</li>
<li>-version</li>
<li>-showversion</li>
<li>-help</li>
<li>-X</li>
<li>-ea</li>
<li>-enableassertions</li>
<li>-da</li>
<li>-disableassertions</li>
<li>-esa</li>
<li>-enablesystemassertions</li>
<li>-dsa</li>
<li>-disablesystemassertions</li>
<li>-Xint</li>
<li>-Xnoclassgc</li>
<li>-Xdebug</li>
<li>-Xfuture</li>
<li>-Xrs</li>
<li>-Xms</li>
<li>-Xmx</li>
<li>-Xss</li></ul></p>
<p>
<p>IBM Web
Start는 또한 가비지 콜렉션 정책을 설정하는 <strong>-Xgcpolicy</strong>를 지원합니다.</p></p>
<p>
<p>Web Start를 지원하는 브라우저에 대한 정보는 <a href="#suppbrowse">지원되는 브라우저</a>를 참조하십시오.</p></p>
<p>
<p>Web Start에 대한 자세한 정보는 다음을 참조하십시오. 
</p>
<ul>
<li><a href="http://java.sun.com/products/javawebstart" target="_blank">http://java.sun.com/products/javawebstart</a> 및</li></ul>
<ul>
<li><a href="http://java.sun.com/javase/6/docs/technotes/guides/javaws/index.html" target="_blank">http://java.sun.com/javase/6/docs/technotes/guides/javaws/index.html</a>.</li></ul><p class="indatacontent"> 응용프로그램을 배치하는 데 대한 자세한 정보는 웹 사이트
</p>
<ul>
<li><a href="http://java.sun.com/javase/6/docs/technotes/guides/deployment/index.html" target="_blank">http://java.sun.com/javase/6/docs/technotes/guides/deployment/index.html</a>을 참조하십시오.</li></ul></p>
<a name="installing_webstart"></a>
<h3 id="installing_webstart"><a href="#ToC_97">Web Start 실행</a></h3>
<div>
<p>Web Start는 웹 페이지 또는 명령행에서 실행할 수 있습니다. Web Start
응용프로그램은 Java 응용프로그램 캐시에 저장됩니다.</p></div>
<p>
<p>Java
Web Start 버전 6은
.rpm 또는 .tgz 패키지를 사용하여
Java를 설치할 때 자동으로 설치됩니다.
.tgz 패키지에서 Java를
추출하는 경우, jre/lib/javaws/updateSettings.sh 쉘 스크립트를 실행하여
시스템에서 .mailcap 및 .mime.types 파일을
업데이트하십시오.</p></p>
<p>
<p>Web Start를 호출하는 방법에는 여러 가지가 있습니다.</p></p>
<ul>
<li>웹 페이지에서 .jnlp 파일을 참조하는 링크를 선택하십시오. </li>
<li>쉘 프롬프트에서 다음을 입력하십시오.  
<pre class="xmp">javaws <em>&lt;URL&gt;</em></pre>여기서 <em>&lt;URL&gt;</em>은
.jnlp 파일의 위치입니다.</li>
<li>이전에 Java Web Start를 사용하여
응용프로그램을 연 경우, Java 응용프로그램 캐시 뷰어를
사용할 수 있습니다.  쉘 프롬프트에서 다음을 입력하십시오. 
<pre class="xmp">/opt/ibm/java-i386-60/jre/bin/javaws<span><font color="RED"><span id="changed">|</span> -viewer</font></span></pre> 

<p>모든 Java Web
Start 응용프로그램은 Java
응용프로그램 캐시에 저장됩니다. 응용프로그램은 최신 버전이 캐시에 없는 경우에만 다운로드됩니다.</p></li></ul>
<a name="webstart_ssv"></a>
<h3 id="webstart_ssv"><a href="#ToC_98"><strong><span class="bold-italic">(Linux IA
32-bit에만 해당) </span></strong>Web Start SSV(Secure Static Versioning)</a></h3>
<div>
<p>SSV를 사용하여 Web Start 응용프로그램에서 실행할 특정 JVM 버전을
요청할 수 있습니다. 또한 이 기능을 사용하면 응용프로그램이 새 JVM으로 업그레이드된 시스템에서
이전의 보안 취약성을 이용하므로, 이제 기본적으로 SSV가 사용됩니다.</p></div>
<p>SSV를 사용하는 경우, 특정 JVM을 사용하도록 요청하는 서명되지 않은 Web Start 응용프로그램을 실행하기 전에
사용자에게 경고가 표시됩니다. 서명된 응용프로그램 및 JVM의 최신 버전을 요청하는 응용프로그램은 정상적으로 실행됩니다.</p>
<p>deployment.properties 파일에서
<strong>deployment.javaws.ssv.enabled</strong> 특성을 false로 설정하여 SSV를 사용하지 않을 수 있습니다.</p>
<a name="shipping"></a>
<h2 id="shipping"><a href="#ToC_99">Java 응용프로그램 운송</a></h2>
<div>
<p>Java 응용프로그램은 일반적으로
클래스, 자원 및 데이터 파일로 구성됩니다.</p></div>
<p>Java 응용프로그램을 운송할 때
소프트웨어 패키지는 다음 파트로 구성됩니다.</p>
<ul>
<li>사용자 자신의 클래스, 자원 및 데이터 파일</li>
<li>설치 프로시저 또는 프로그램</li></ul>
<p>응용프로그램을 실행하려면 사용자에게 Linux용 Runtime Environment가 필요합니다.
Linux용 SDK 소프트웨어에는 Runtime Environment가 포함되어 있습니다. 그러나
사용자에게 SDK for Linux 소프트웨어가
설치되어 있다고 가정할 수 없습니다.</p>
<p>Linux용 SDK 소프트웨어 라이센스에 따라, 귀하는
응용프로그램과 함께 SDK의 파일을 재배포할 수 <strong>없습니다</strong>.
라이센스를 취득한 Linux용 SDK의 버전이 대상 시스템에
설치되어 있는지 확인하십시오.</p>
<a name="classdatasharing"></a>
<h1 id="classdatasharing"><a href="#ToC_100"> JVM 사이에 클래스 데이터 공유</a></h1>
<div>
<p>클래스 데이터를 공유하면 복수의 JVM이 메모리에서 단일 공간을
공유할 수 있습니다.</p></div><a id="idx46" name="idx46"></a>
<p>JVM(Java Virtual Machine)을 사용하여
디스크의 메모리 맵핑된 캐시 파일에
클래스 데이터를 저장하여 JVM 사이에서 이 데이터를 공유할 수 있습니다. 둘 이상의 JVM이 캐시를 공유하는 경우, 데이터를 공유하면
전체 가상 메모리 소비가 줄어듭니다. 또한 데이터를 공유하면 캐시를 작성한 후 JVM의 시작 시간도
단축됩니다. 공유 클래스 캐시는 활성 JVM에 종속되지 않으며 공유 클래스 캐시가 손상될 때까지
 지속됩니다.</p>
<p>공유 캐시에는 다음이 포함될 수 있습니다. 
</p>
<ul>
<li>부트스트랩 클래스</li>
<li>응용프로그램 클래스</li>
<li>클래스를 설명하는 메타데이터</li>
<li><font color="RED"><span id="changed">|</span>AOT(Ahead-of-time) 컴파일된 코드</font></li></ul>
<a name="shc_overview"></a>
<h2 id="shc_overview"><a href="#ToC_101">클래스 데이터 공유 개요</a></h2>
<div>
<p>클래스 데이터 공유는 메모리 풋프린트를 줄이고 JVM 시작 시간을 향상시키는
명백한 메소드를 제공합니다. <span><font color="RED"><span id="changed">|</span>Java 6은
<span id="changed">|</span>캐시 관리, 분리 및 성능에서 새로운 기능 및 향상된 기능을 제공합니다.</font></span></p></div>
<p>
<a name="wq129"></a>
<h3 id="wq129">클래스 데이터 공유 사용</h3>
<p>JVM을 시작할 때 <strong>-Xshareclasses</strong> 옵션을 사용하여
클래스 데이터 공유를 사용하십시오.
JVM은 기존 캐시에 연결하거나, 기존 캐시가 존재하지 않는 경우 새 캐시를 작성합니다.</p>
<p>JVM이 로드한
모든 부트스트랩과 응용프로그램 클래스가 기본적으로 공유됩니다. 사용자 정의 클래스 로더는 응용프로그램 클래스 로더를
확장하는 경우 자동으로 클래스를 공유합니다. 그렇지 않으면 JVM과 함께 제공되는 Java Helper
API를 사용하여 캐시에 액세스해야 합니다. (<a href="#adaptingclassloaders">클래스를 공유하기 위한 사용자 정의 클래스 로더 채택</a> 참조).</p>
<p><font color="RED"><span id="changed">|</span>JVM은 후속 JVM 시작 시간을 향상시키는 데 필요한 특정 메소드의 경우 캐시에
<span id="changed">|</span>AOT(ahead-of-time) 컴파일 코드를 저장할 수도 있습니다. AOT 컴파일 코드는 JVM 사이에서 실제로 공유되지 않으나
<span id="changed">|</span>JVM 시작 시 컴파일 시간을 줄이기 위해 캐시에 넣어집니다. 캐시에 저장된 AOT 코드의 양은
<span id="changed">|</span>스스로 판별됩니다. 캐시에 저장된 메소드를 제어할 수 있으나
<span id="changed">|</span>AOT 코드에 사용된 캐시 공간 크기에 상한 및 하한을 설정하거나 AOT 캐싱을 완전히 사용하지 않도록
<span id="changed">|</span>선택할 수 있습니다. 자세한 정보는 <a href="#sharedclassesxoptions">클래스 데이터 공유 사용 및 구성</a>을 참조하십시오.</font></p></p>
<p>
<a name="wq130"></a>
<h3 id="wq130">캐시 액세스</h3>
<p><span><font color="RED"><span id="changed">|</span>JVM은
<span id="changed">|</span>읽기 쓰기 또는 읽기 전용 액세스로 캐시에 액세스할 수 있습니다.</font></span> 읽기 쓰기 액세스 권한이 있는 캐시에 연결된
모든 JVM은 캐시를 업데이트할 수 있습니다. 다른 JVM이 캐시에 기록하고 있는 중라도 임의의 수의 JVM을 캐시에서 동시에 읽을 수 있습니다.</p>
<p>런타임 바이트 코드 수정이 사용되고 있는지 확인해야 합니다. 자세한 정보는
<a href="#runtimebytecode">런타임 바이트 코드 수정</a>을 참조하십시오.</p></p>
<p>
<a name="wq131"></a>
<h3 id="wq131">캐시의 동적 업데이트</h3>
<p>공유 클래스 캐시는 JVM의 수명보다 오래 지속되므로
캐시는 파일 시스템의 클래스 또는 JAR의 모든 수정사항을
반영하여 동적으로 업데이트됩니다. 동적 업데이트으로 인해
캐시는 캐시를 사용하는 응용프로그램에 대해 투명해질 수 있습니다.</p></p>
<p>
<a name="wq132"></a>
<h3 id="wq132">캐시 보안</h3>
<p>공유 클래스 캐시에 대한 액세스는 운영 체제 권한 및
Java 보안 권한에 따라
제한됩니다. 공유 클래스 캐시는 <strong>groupAccess</strong> 명령행 하위 옵션이
사용되지 않는 한 사용자 액세스로 작성됩니다. 클래스 데이터를 공유하도록 등록된 클래스 로더만 공유 클래스 캐시를
업데이트할 수 있습니다.</p>
<p><font color="RED"><span id="changed">|</span>캐시 메모리는 메모리 페이지 보호를 사용하여
<span id="changed">|</span>우발적 또는 고의적 손상에 대해 보호됩니다. 그러나 JVM이 이 메모리에 기록할 페이지를 보호하지 않으므로
<span id="changed">|</span>손상에 대한 절대적인 보증은 아닙니다. 캐시를 수정할 수 없도록 하는 유일한 방법은
<span id="changed">|</span>읽기 전용으로 여는 것입니다.</font></p>
<p>Java SecurityManager가
설치된 경우 기본 부트스트랩, 응용프로그램 및 확장 클래스 로더를 제외한 클래스 로더는 java.policy 파일에
SharedClassPermission 행을 추가하여 클래스를 공유할 권한을 부여해야
합니다. (<a href="#usingsharedclasspermissions">SharedClassPermission 사용</a> 참조).
RuntimePermission 『createClassLoader』는
새 클래스 로더 작성을 제한하므로 캐시에 대한 액세스도 제한합니다.</p></p>
<p>
<a name="wq133"></a>
<h3 id="wq133">캐시 수명</h3>
<p>시스템에는 여러 개의 캐시가 존재할 수 있으며
<strong>-Xshareclasses</strong> 명령의 하위 옵션 이름별로 지정됩니다. JVM은 동시에 둘 이상의 캐시에
연결할 수 없습니다.</p>
<p><strong>-Xscmx&lt;n&gt;&lt;size&gt;</strong>를 사용하여 시작 시 기본 캐시 크기를
대체할 수 있으며, 이 크기는 캐시 지속 시간 동안 고정됩니다. 캐시는 <strong>-Xshareclasses</strong> 명령의
하위 옵션을 사용하여 명시적으로 파기하거나 캐시 파일을
수동으로 삭제할 때까지 존재합니다.</p></p>
<p>
<a name="wq134"></a>
<h3 id="wq134">캐시 유틸리티</h3>
<p>모든 캐시 유틸리티는 <strong>-Xshareclasses</strong> 명령의 하위 옵션입니다. 사용 가능한 하위 옵션 목록을 보려면 <a href="#sharedclassesxoptions">클래스 데이터 공유 사용 및 구성</a>을
참조하거나 <strong>-Xshareclasses:help</strong>를 사용하십시오.</p></p>
<a name="sharedclassesxoptions"></a>
<h2 id="sharedclassesxoptions"><a href="#ToC_108">클래스 데이터 공유 사용 및 구성</a></h2>
<div>
<p>클래스 데이터 공유 및 캐시 관리 유틸리티는
java 실행기에 대한 명령행 옵션을 사용하여 제어됩니다.</p></div><a id="idx47" name="idx47"></a><a id="idx48" name="idx48"></a>
<p>
<p><em>&lt;size&gt;</em> 매개변수를 사용하는 옵션의 경우,
숫자에 "k" 또는 "K"를 접미부로 사용하여 KB를 표시하거나, "m" 또는 "M"를 사용하여 MB를 표시하거나,
"g" 또는 "G"를 사용하여 GB를 표시합니다.</p></p>
<dl class="parml">
<dt class="bold"><strong>-Xscmaxaot</strong><em>&lt;size&gt;</em></dt>
<dd>캐시에서 AOT 데이터용으로 사용할 수 있는 최대 바이트 수를 설정합니다. 비AOT 데이터에 대해
특정 양의 캐시 공간이 사용되도록 하려면 이 옵션을 사용하십시오. 기본적으로 AOT 데이터의
최대 한계는 캐시의 여유 공간 양입니다. 이 옵션의 값은 <strong>-Xscminaot</strong>의 값보다 작지 않고
<strong>-Xscmx</strong>의 값보다 크지 않아야 합니다.
</dd>
<dt class="bold"><strong>-Xscminaot</strong><em>&lt;size&gt;</em></dt>
<dd>캐시에서 AOT 데이터용으로 예약할 최소 바이트 수를 설정합니다.
AOT 데이터가 캐시에 대해 작성되더라도 캐시가 가득 차거나 <strong>-Xscmaxaot</strong> 한계에 도달할 때까지
기본적으로 AOT 데이터용으로는 공간이 예약되지 않습니다. 이 옵션의 값은
<strong>-Xscmx</strong> 또는 <strong>-Xscmaxaot</strong>의 값을 초과하지 않아야 합니다.
AOT 데이터는 캐시된 클래스에 대해서만 작성될 수 있으므로 <strong>-Xscminaot</strong>의 값은
항상 전체 캐시 크기보다 작아야 합니다. <strong>-Xscminaot</strong> 값이
<strong>-Xscmx</strong> 값과 동일한 경우, AOT 데이터는 캐시의 클래스와 연관되어야 하므로
클래스 데이터 또는 AOT 데이터가 저장되지 않습니다.
</dd>
<dt class="bold"><strong>-Xscmx</strong><em>&lt;size&gt;</em></dt>
<dd>캐시 크기를 지정합니다. 이 옵션은 캐시가 작성되는 중이고 동일한 이름의 캐시가 없는 경우에만
적용됩니다. 기본 캐시 크기는 플랫폼에 따라 다릅니다.
명령행 인수로 <strong>-verbose:sizes</strong>를 추가하여 사용 중인 크기 값을
찾을 수 있습니다. 최소 캐시 크기는 4KB입니다. 최대 캐시 크기도
플랫폼에 따라 다릅니다. (<a href="#cachesizelimits">캐시 크기 한계</a> 참조).
</dd>
<dt class="bold"><strong>-Xshareclasses</strong>:<em>&lt;suboption&gt;</em>[,<em>&lt;suboption&gt;</em>...]</dt>
<dd>클래스 데이터 공유를 사용합니다. 여러 하위 옵션을 선택할 수 있으며 일부는
캐시 유틸리티입니다. 캐시 유틸리티는 VM을 시작하지 않고 지정된 캐시에 대해
필요한 작업을 수행합니다. 여러 하위 옵션을 쉼표로 분리하여 결합할 수 있으나,
캐시 유틸리티는 상호 배타적입니다. 캐시 유틸리티를 사용하는 경우
『JVM(Java Virtual
Machine)을 작성할 수 없습니다.』라는 메시지가 예상됩니다. 캐시 유틸리티는 가상 시스템을
작성하지 않습니다. 

<p>일부 캐시 유틸리티는 이전 Java 버전의 캐시 또는
비트 너비가 다른 JVM에서 작성한 캐시에 대해 작업할 수 있습니다. 이러한 캐시는
『호환 불가능』 캐시로 언급됩니다.</p>

<p><strong>-Xshareclasses</strong> 옵션과 함께 다음 하위 옵션을 사용할 수 있습니다. 
</p>
<dl class="parml">
<dt class="bold"><strong>help</strong></dt>
<dd>모든 명령행 하위 옵션을 나열합니다.
</dd>
<dt class="bold"><strong>name</strong>=<em>&lt;name&gt;</em></dt>
<dd>제공된 이름으로 캐시에 연결합니다. 캐시가 없으면 캐시를
작성합니다. 또한 캐시 유틸리티(예: destroy)에 사용될 캐시를 표시하는 데에도 사용됩니다. 현재 사용 가능한 이름 지정된 캐시를 표시하려면 <strong>listAllCaches</strong> 유틸리티를
사용하십시오. 이름을 지정하지 않으면 기본 이름
『sharedcc_%u』가 사용됩니다. 캐시 이름에서 %u에는 현재 사용자 이름이 삽입됩니다.  캐시 이름에 %g를 지정하여
현재 그룹 이름을 삽입할 수 있습니다. 
</dd>
<dt class="bold"><font color="RED"><span id="changed">|</span><strong>cacheDir=</strong><em>&lt;directory&gt;</em></font></dt>
<dd><font color="RED"><span id="changed">|</span>캐시 데이터를 읽거나 기록한 디렉토리를 설정합니다. 기본적으로 <em>&lt;directory&gt;</em>는 /tmp/javasharedresources입니다. 
<span id="changed">|</span>사용자는 <em>&lt;directory&gt;</em> 내에 충분한 권한을 가지고 있어야만 합니다. 기본적으로 JVM은 지정된 디렉토리에 직접 지속적 캐시 파일을 기록합니다. 지속적 캐시 파일은 파일 시스템에서 안전하게 이동하고 삭제할 수 있습니다. 비지속적
<span id="changed">|</span>캐시는 공유 메모리에 저장되며 메모리 위치를 설명하는
<span id="changed">|</span>제어 파일을 포함하고 있습니다. 제어 파일은
<span id="changed">|</span>지정된 <strong>cacheDir</strong>의 javasharedresources 서브디렉토리에 저장됩니다.
<span id="changed">|</span>이 디렉토리의 제어 파일은 수동으로 이동 또는 삭제해서는 안됩니다. <strong>listAllCaches</strong> 유틸리티,
<span id="changed">|</span><strong>destroyAll</strong> 유틸리티 및 <strong>expire</strong> 하위 옵션은
<span id="changed">|</span>제공된 <strong>cacheDir</strong> 범위 내에서만 작동합니다.</font>
</dd>
<dt class="bold"><font color="RED"><span id="changed">|</span><strong>readonly</strong></font></dt>
<dd><font color="RED"><span id="changed">|</span>읽기 전용 권한이 있는 기존 캐시를 엽니다. JVM은 이 하위 옵션을 사용하여 새 캐시를
<span id="changed">|</span>작성하지 않습니다. 읽기 전용 캐시를 열면 JVM에서 캐시를 업데이트할 수
<span id="changed">|</span>없습니다. 또한, JVM이 쓰기 액세스 권한 없이 다른 사용자 또는 그룹에서
<span id="changed">|</span>작성한 캐시에 연결할 수도 있습니다. 기본적으로 이 하위 옵션은
<span id="changed">|</span>지정되어 있지 않습니다.</font>
</dd>
<dt class="bold"><font color="RED"><span id="changed">|</span><strong>nonpersistent</strong></font></dt>
<dd><font color="RED"><span id="changed">|</span>비지속적 캐시를 사용합니다. 기본적으로 JVM은 운영 체제 재시작 이후
<span id="changed">|</span>지속되는 디스크에 캐시 파일을 작성합니다. <strong>nonpersistent</strong> 하위 옵션을 사용하면 운영 체제 종료 시 유실된 공유 메모리의 캐시가 작성됩니다. 비지속적 및
<span id="changed">|</span>지속적 캐시의 이름은 동일할 수 있으며 <strong>nonpersistent</strong> 하위 옵션은
<span id="changed">|</span>비지속적 캐시에서 유틸리티(예: <strong>destroy</strong>)를 실행할 때 항상 사용해야
<span id="changed">|</span>합니다. 기본적으로 이 하위 옵션은 지정되어 있지 않습니다.</font>
</dd>
<dt class="bold"><strong>groupAccess</strong></dt>
<dd>캐시에 대한 그룹 액세스를 허용하도록 운영 체제 권한을 새 캐시에 설정합니다. 기본값은 사용자 액세스 전용입니다.
</dd>
<dt class="bold"><strong>verbose</strong></dt>
<dd>공유 클래스 캐시의 전체 상태와 더 자세한 오류 메시지를 제공하는
상제 출력을 사용합니다.
</dd>
<dt class="bold"><font color="RED"><span id="changed">|</span><strong>verboseAOT</strong></font></dt>
<dd><font color="RED"><span id="changed">|</span>컴파일된 AOD 코드를 찾는 중이거나 캐시에 저장 중인 경우 상세 출력을 사용합니다. AOT 코드는 발견적으로
<span id="changed">|</span>생성됩니다. 소규모 응용프로그램에서는 생성된 AOT 코드를 전혀 볼 수 없을 수도 있습니다. 
<span id="changed">|</span><strong>noaot</strong> 하위 옵션을 사용하여 AOT 캐싱을 사용할 수 없습니다.</font>
</dd>
<dt class="bold"><strong>verboseIO</strong></dt>
<dd>저장되고 발견되는 클래스에 대한 정보를 나열하면서 캐시 I/O 활동에 대한 자세한 출력을 제공합니다. 각 Classloader에는 고유한 ID(부트스트랩
로더는 항상 0)가 부여되며 출력은 작업 시 Classloader 계층 구조를
표시합니다. 여기서, Classloader가 스스로 클래스를 로드하려면
먼저 해당 클래스를 상위에 요청해야 합니다. 요청이 실패하는 경우는 흔한 일이며 Classloader 계층 구조에서 정상적으로 예상되는 작동입니다.
</dd>
<dt class="bold"><strong>verboseHelper</strong></dt>
<dd>Java Helper API에 대해
상세 출력을 사용합니다. 이 출력은 ClassLoader에서 Helper API가 사용되는 방식을 보여줍니다.
</dd>
<dt class="bold"><strong>silent</strong></dt>
<dd>오류 메시지를 포함하여 모든 공유 클래스 메시지를 표시하지 않습니다.
</dd>
<dt class="bold"><strong>nonfatal</strong></dt>
<dd>클래스 데이터 공유가 실패하는 경우에도 JVM을 시작할 수 있습니다. 클래스 데이터 공유에 실패하는 경우 정상적인 동작은 시작을 거부하는 것입니다.
nonfatal이 선택되고 공유 클래스 캐시가 초기화에 실패하는 경우
JVM은 읽기 전용 모드로 캐시에 연결을 시도합니다. 이 시도가 실패하는 경우
JVM은 클래스 데이터 공유를 사용하지 않고 시작됩니다.
</dd>
<dt class="bold"><strong>none</strong></dt>
<dd>명령행 끝에 추가하여 클래스 데이터 공유를 사용하지 않게 할 수 있습니다.
이 하위 옵션은 명령행에서 이전에 발견된 클래스 공유 인수를
대체합니다.
</dd>
<dt class="bold"><strong>modified=</strong><em>&lt;modified context&gt;</em></dt>
<dd>JVMTI 에이전트가 설치되어 런타임에 바이트 코드를 수정할 수 있는 경우에 사용됩니다.
이 하위 옵션을 지정하지 않고 바이트 코드 수정 에이전트가 설치되어 있는 경우,
클래스는 일시적인 성능 손실과 함께 안전하게 공유됩니다. <em>&lt;modified
context&gt;</em>는 사용자가 선택한 설명자입니다(예: 『myModification1』).
이 옵션은 캐시를 분할하므로 컨텍스트 myModification1을 사용하는 JVM만이
동일한 클래스를 공유할 수 있습니다. 예를 들어, 수정 컨텍스트로 HelloWorld를
실행한 후 다른 수정 컨텍스트로 다시 실행하면
모든 클래스가 캐시에 두 번 저장됩니다. 자세한 정보는
<a href="#runtimebytecode">런타임 바이트 코드 수정</a>을 참조하십시오.
</dd>
<dt class="bold"><font color="RED"><span id="changed">|</span><strong>reset</strong></font></dt>
<dd><font color="RED"><span id="changed">|</span>캐시가 파기된 후 JVM 시작 시 다시 작성됩니다. <strong>-Xshareclasses:reset</strong>으로 명령행 끝에 추가할 수 있습니다.</font>
</dd>
<dt class="bold"><strong>destroy</strong>(유틸리티 옵션)</dt>
<dd><strong>name</strong>, <strong>cacheDir</strong>
및 <strong>nonpersistent</strong> 하위 옵션으로 지정된 캐시를 파기합니다. 캐시를 사용하는 모든 JVM이 종료되고
사용자에게 충분한 권한이 있는 경우에만 캐시를 파기할 수 있습니다.
</dd>
<dt class="bold"><strong>destroyAll</strong>(유틸리티 옵션)</dt>
<dd>지정된 <strong>cacheDir</strong> 및 <strong>nonpersistent</strong> 하위 옵션을 사용하여
사용 가능한 모든 캐시를 파기하려고 합니다.
캐시를 사용하는 모든 JVM이 종료되고
사용자에게 충분한 권한이 있는 경우에만 캐시를 파기할 수 있습니다.
</dd>
<dt class="bold"><strong>expire</strong>=<em>&lt;time in minutes&gt;</em></dt>
<dd>공유 클래스를 로드하기 전에 지정된 시간 동안 사용되지 않은 모든 캐시를
파기합니다. 이 옵션으로 JVM이 종료되지 않으므로
유틸리티 옵션이 아닙니다.
</dd>
<dt class="bold"><strong>listAllCaches</strong>(유틸리티 옵션)</dt>
<dd>지정된 캐시 디렉토리에 있는 모든 호환 가능 및 호환 불가능 캐시를
나열합니다. <strong>cacheDir</strong>가
지정되어 있지 않으면 기본 디렉토리가 사용됩니다. 캐시마다 요약 정보(예: Java 버전
및 현재 사용법)가 표시됩니다.
</dd>
<dt class="bold"><strong>printStats</strong>(유틸리티 옵션)</dt>
<dd><strong>name</strong>, <strong>cacheDir</strong> 및 <strong>nonpersistent</strong>
하위 옵션으로 지정된 캐시에 대한 요약 정보를 표시합니다.
가장 유용한 정보는
캐시가 채워진 정도와 포함된 클래스 수에 대한 것입니다.
Stale 클래스는 파일 시스템에서 업데이트된 클래스이므로 캐시가 "stale"로 표시합니다. Stale 클래스는
캐시에서 제거되지 않으므로 재사용할 수 있습니다. 자세한 정보는 <a href="http://www.ibm.com/developerworks/java/jdk/diagnosis/60.html" target="_blank"> 진단 안내서</a>를 참조하십시오.
</dd>
<dt class="bold"><strong>printAllStats</strong>(유틸리티 옵션)</dt>
<dd>
<p><strong>name</strong>, <strong>cacheDir</strong>
및 <strong>nonpersistent</strong> 하위 옵션으로 지정된 캐시에 대한 자세한 정보를 표시합니다. 각 클래스는 로드된 위치에 대한 참조와 함께 연대순으로
나열됩니다. 클래스 메소드에 대한 AOT 코드도 나열됩니다.</p> 자세한 정보는 

<p>자세한 정보는 <a href="http://www.ibm.com/developerworks/java/jdk/diagnosis/60.html" target="_blank">진단 안내서</a>를 참조하십시오.</p>
</dd>
<dt class="bold"><font color="RED"><span id="changed">|</span><strong>mprotect=</strong>[ all
<span id="changed">|</span>| default | none ]</font></dt>
<dd><font color="RED"><span id="changed">|</span>기본적으로 캐시를 포함하는 메모리 페이지는 지정된 페이지가 업데이트되고 있지 않는 경우
<span id="changed">|</span>항상 보호됩니다. 우발적 또는 고의적 손상으로부터
<span id="changed">|</span>캐시를 보호하는 데 도움이 됩니다. 약간의 성능 손실이 있으므로 기본적으로
<span id="changed">|</span>캐시 헤더는 보호되지 않습니다. 『all』을 지정하면
<span id="changed">|</span>헤더를 포함한 모든 캐시 페이지가 보호됩니다. 『none』을 지정하면
<span id="changed">|</span>페이지 보호를 사용할 수 없습니다.</font>
</dd>
<dt class="bold"><font color="RED"><span id="changed">|</span><strong>noBootclasspath</strong></font></dt>
<dd><font color="RED"><span id="changed">|</span>공유 클래스 캐시의 부트스트랩 클래스 로더가 로드한 클래스의
<span id="changed">|</span>저장영역을 보호합니다. SharedClassURLFilter API에서
<span id="changed">|</span>캐시할 클래스를 정확하게 제어하는 데 사용할 수 있습니다. 공유 클래스 필터링에 대한 자세한 정보는
<span id="changed">|</span><a href="http://www.ibm.com/developerworks/java/jdk/diagnosis/60.html" target="_blank">진단 안내서</a>를 참조하십시오.</font>
</dd>
<dt class="bold"><font color="RED"><span id="changed">|</span><strong>cacheRetransformed</strong></font></dt>
<dd><font color="RED"><span id="changed">|</span>JVMTI RetransformClasses 기능을 사용하여 변환한 클래스의 캐싱을 사용합니다.</font>
</dd>
<dt class="bold"><font color="RED"><span id="changed">|</span><strong>noaot</strong></font></dt>
<dd><font color="RED"><span id="changed">|</span>AOT 코드의 캐싱 및 로딩을 사용할 수 없습니다.</font>
</dd>
</dl>
</dd>
</dl>
<a name="shc_admin"></a>
<h2 id="shc_admin"><a href="#ToC_109">캐시 작성, 채우기, 모니터링 및 삭제</a></h2>
<div>
<p>캐시 관리 유틸리티의 예제를 포함하는 공유 클래스 데이터 캐시의 라이프사이클
개요입니다.</p></div><a id="idx49" name="idx49"></a><a id="idx50" name="idx50"></a><a id="idx51" name="idx51"></a><a id="idx52" name="idx52"></a>
<p>클래스 데이터 공유를 사용하려면 응용프로그램 명령행에
<strong>-Xshareclasses[:name=&lt;name&gt;]</strong>을 추가하십시오.</p>
<p>JVM은 주어진 이름의 기존 캐시에 연결하거나 이 이름의 새 캐시를
작성합니다. 새 캐시가 작성된 경우 해당 캐시가 모두 채워질 때까지 로드 중인 모든 부트스트랩 및 응용프로그램으로 채워집니다. 둘 이상의
JVM이 동시에 시작된 경우 캐시를 동시에 모두 채웁니다.</p>
<p>캐시가 작성되었는지 확인하려면 <tt class="xph">java -Xshareclasses:listAllCaches</tt>를 실행하십시오. 공유 중인 클래스의 수 및 클래스 데이터의 양을
확인하려면 <tt class="xph">java
-Xshareclasses:[name=&lt;name&gt;],printStats</tt>를 실행하십시오. (이러한 유틸리티는 응용프로그램 JVM을 종료한 후
또는 다른 명령 창에서 실행할 수 있습니다.)</p>
<p>JVM을 실행 중인 경우 캐시 사용량에 대한 자세한 피드백을 보려면 <strong>verbose</strong> 하위 옵션을 사용하십시오(예: <tt class="xph">java -Xshareclasses:[name=&lt;name&gt;],verbose</tt>).</p>
<p>캐시에서 로드되거나 캐시에 저장된 클래스를 보려면 응용프로그램 명령행에
<tt class="xph">-Xshareclasses:[name=&lt;name&gt;],verboseIO</tt>를 추가하십시오.</p>
<p>작성한 캐시를 삭제하려면 <tt class="xph">java -Xshareclasses:[name=&lt;name&gt;],destroy</tt>를 실행하십시오.
 캐시에 stale 클래스가 많거나 캐시가 가득 차서
더 큰 캐시를 작성하려는 경우에만 캐시를 삭제해야 합니다.</p>
<p>기본값이 최적의 크기가 아니므로 특정 응용프로그램에 대한 캐시 크기를 조정하는 것이 좋습니다. 최적의 캐시 크기를
판별하는 최선의 방법은 대규모 캐시를 지정(<strong>-Xscmx</strong> 사용)하고 응용프로그램을 실행한 후
printStats를 사용하여 저장된 클래스의 양을 판별하는 것입니다. 만일의 경우에 대비하여 printStats에 표시된 값에 소량씩 추가하십시오. 클래스는
수명 주기 동안 언제든지 로드될 수 있으므로 응용프로그램이 종료된 후 이러한 분석을 수행하는 것이 가장 좋습니다.
그러나 가득 찬 캐시에 연결된 JVM의 성능 또는 기능에 부정적인 영향은 없으므로,
캐시 크기를 필요한 양보다 적게 결정하는 것도 좋습니다.</p>
<p>캐시가 가득 차면, 상세 하위 옵션을 사용하는 JVM의 명령행에 메시지가
출력됩니다. 그러면
가득 찬 캐시를 공유하는 모든 JVM은 자신의 프로세스 메모리로 더 많은 클래스를 로드합니다. 가득 찬 캐시의 클래스는 계속 공유되지만,
가득 찬 캐시는 읽기 전용이므로 새 클래스로 업데이트할 수 없습니다.</p>
<a name="shc_performance"></a>
<h2 id="shc_performance"><a href="#ToC_110">성능 및 메모리 이용</a></h2>
<div>
<p>클래스 데이터 공유는 비슷한 코드를 실행하는 둘 이상의 JVM을 사용하는 시스템에서 특히 유용합니다.
시스템에서 가상 메모리 이용이 줄어드는 이점이 있습니다. 또한 JVM을 자주 시작하고 종료하는 시스템에서도 유용하며,
시작 시간이 개선되는 이점이 있습니다.</p></div><a id="idx53" name="idx53"></a><a id="idx54" name="idx54"></a>
<p>새 캐시를 작성하고 채우는 오버헤드는 소량입니다. JVM 시작의 시간 비용은 클래스 데이터 공유를 사용하지 않는
시스템과 비교할 때 보통 0% - 5% 정도 느려지며, 로드된 클래스의 수에 따라 달라집니다. 클래스 데이터 공유를
사용하지 않는 시스템과 비교할 때 JVM 시작 시간은 캐시가 채워짐에 따라 일반적으로 10% - 40% 정도 빨라지며,
운영 체제 및 로드된 클래스의 수에 따라 달라집니다. 동시에 실행 중인 다중 JVM을 보면
전체적으로 시작 시간이 훨씬 빨라짐을 알 수 있습니다.</p>
<p>중복 클래스는 공유 클래스 캐시 내에서 결합됩니다. 예를 들어,
myClasses.jar에서 로드한 클래스 A와 myOtherClasses.jar에서 로드한
클래스 A(동일한 내용)는 캐시에 한 번만 저장됩니다. <strong>printAllStats</strong> 유틸리티는
중복된 클래스의 다중 항목을 동일한 클래스를 가리키는 각 항목으로 표시합니다.</p>
<p>클래스 데이터 공유로 응용프로그램을 실행하는 경우, 운영 체제 도구를 사용하여 가상 메모리 이용의 감소량을 알 수 있습니다.</p>
<a name="shc_limitations"></a>
<h2 id="shc_limitations"><a href="#ToC_111">클래스 데이터 공유 사용에 대한 고려사항 및 제한사항</a></h2>
<div>
<p>제품에서 클래스 데이터 공유를 배치하고 개발 환경에서 클래스 데이터 공유를
사용할 때 고려할 요소입니다.</p></div><a id="idx55" name="idx55"></a><a id="idx56" name="idx56"></a>
<a name="cachesizelimits"></a>
<h3 id="cachesizelimits"><a href="#ToC_112">캐시 크기 한계</a></h3>
<div>
<p>이론적으로 최대 캐시 크기는 2GB입니다. 지정할 수 있는
캐시 크기는 시스템에서 사용 가능한 실제 메모리 및
페이징 공간의
크기에 따라 제한됩니다.</p></div><a id="idx57" name="idx57"></a>
<p>공유 클래스의 캐시는 System V IPC 공유 메모리 메커니즘을 사용하여 할당됩니다.</p>
<p>프로세스의 가상 주소 공간을 공유 클래스 캐시와
Java 힙이 공유하므로,
Java 힙의 최대 크기를 늘리면 사용자가 작성할 수 있는 공유 클래스
캐시 크기가 줄어들 수 있습니다.</p>
<p>캐시 크기는 <strong>SHMMAX</strong> 설정에 의해 제한되며,
이는 할당 가능한 공유 메모리 용량을 제한합니다. 이러한 설정은
/proc/sys/kernel/shmmax 파일에 있습니다. <strong>SHMMAX</strong>는 일반적으로 30MB로 설정됩니다.</p>
<a name="runtimebytecode"></a>
<h3 id="runtimebytecode"><a href="#ToC_113">런타임 바이트 코드 수정</a></h3>
<div>
<p>바이트 코드 데이터를 수정할 수 있는 JVMTI(JVM Tool Interface) 에이전트를
사용하는 모든 JVM은 수정한 클래스를 다른 JVM과 공유하려는 경우 modified=<em>&lt;modified_context&gt;</em> 하위 옵션을
사용해야 합니다.</p></div><a id="idx58" name="idx58"></a>
<p>수정된 컨텍스트는
수행할 수정 유형을 설명하는, 사용자가 지정된 설명자입니다. 수정된 컨텍스트는 동일한 컨텍스트에서
실행 중인 모든 JVM이 하나의 파티션을 공유하도록 캐시를
파티션으로 분할합니다.</p>
<p>이 파티셔닝을 사용하면 수정된 바이트 코드를 사용하지 않는 JVM이
수정된 바이트 코드를 사용하는 캐시를 안전하게 공유할 수 있습니다. 주어진 수정된 컨텍스트를 사용하는 모든 JVM은
클래스마다 예측 가능하고 반복 가능한 방식으로 바이트 코드를 수정해야만 다른 JVM에서 캐시에 저장된 수정된 클래스를
로드할 때 이 클래스에 예상한 수정사항이 포함됩니다. 공유 클래스 캐시에서
로드한 클래스는 에이전트가 다시 수정할 수 없으므로 수정을 예측할 수 있습니다.</p>
<p>JVMTI 에이전트가 수정 컨텍스트 없이 사용되는 경우,
클래스는 JVM에서 안전하게 공유되지만 성능에는 약간의 영향이 있습니다.
JVMTI 에이전트에 대해 수정 컨텍스트를 사용하면 여분의 확인 작업을 할 필요가 없으므로
성능에 영향을 미치지 않습니다. JVMTI를 자동으로 사용하지 않고 로드할 때 java.net.URLClassLoader를 확장하고
바이트 코드를 수정하는 사용자 정의 ClassLoader는 수정된 바이트 코드를 캐시에 저장하지만
캐시는 바이트 코드를 수정된 것으로 처리하지 않습니다. 해당 캐시를 공유하는 다른 VM은 수정된 클래스를
로드합니다. modified=<em>&lt;modification_context&gt;</em> 하위 옵션은 JVMTI 에이전트가 캐시에서 수정된 바이트 코드를
파티셔닝하는 것과 동일한 방법으로 사용할 수 있습니다. 사용자 정의
ClassLoader가 클래스에 대해 예상할 수 없는 로드 시간 수정을 해야 하는 경우,
ClassLoader는 클래스 데이터 공유를 사용해서는 안됩니다.</p>
<p>이 주제에 대한 자세한 내용은 <a href="http://www.ibm.com/developerworks/java/jdk/diagnosis/60.html" target="_blank">진단 안내서</a>를 참조하십시오.</p>
<a name="shc_os_limitations"></a>
<h3 id="shc_os_limitations"><a href="#ToC_114">운영 체제 제한사항</a></h3>
<div>
<p>32 및 64비트 JVM에서
클래스를 공유할 수 없습니다. 캐시 정보를 보유할 수 있는 임시 디스크
공간이 있어야 합니다. 캐시 권한은 운영 체제에서 수행합니다.</p></div><a id="idx59" name="idx59"></a>
<p>32-bit 및 64-bit 응용프로그램을 둘 다 실행할 수 있는 운영 체제에서도
32-bit와 64-bit JVM 사이의 클래스 데이터 공유는 허용되지 않습니다. <strong>listAllCaches</strong> 하위 옵션은
사용 중인 JVM의 주소 모드에 따라 32-bit 또는 64-bit 캐시를 나열합니다.</p>
<p>공유 클래스 캐시에는 시스템에 있는 캐시의 ID 정보를 저장할
디스크 공간이 필요합니다. 이
정보는 /tmp/javasharedresources에 저장됩니다.  ID 정보 디렉토리가 삭제되는 경우
JVM은 시스템에서 공유 클래스를 식별할 수 없으므로 캐시를 다시
작성해야 합니다.  JVM 또는 응용프로그램에서 사용되는 메모리 세그먼트를 보려면
<tt class="xph">ipcs</tt> 명령을 사용하십시오. </p>
<p>JVM을 실행하는 사용자는 공유 클래스 캐시를 사용하기 위해 동일한 그룹에 있어야 합니다. 공유 클래스 캐시에 액세스하는 데 필요한 권한은
운영 체제에서 수행합니다. 캐시 이름이 지정되지 않으면
기본적으로 동일한 시스템에 있는 여러 사용자가 각자의 캐시를 작성할 수 있도록
사용자 이름이 기본 이름에 첨부됩니다.</p>
<a name="usingsharedclasspermissions"></a>
<h3 id="usingsharedclasspermissions"><a href="#ToC_115">SharedClassPermission 사용</a></h3>
<div>
<p>클래스 데이터 공유에 대해 SecurityManager가 사용되고
실행 중인 응용프로그램이 자체 클래스 로더를 사용하는 경우,
이러한 클래스 로더는 공유 클래스 권한이 부여되어야 클래스를 공유할 수 있습니다.</p></div><a id="idx60" name="idx60"></a>
<p>ClassLoader
클래스 이름(와일드 카드 허용)과 부여할 액세스 권한을 판별하기 위한 『read』, 『write』 또는
『read,write』 중 하나를 사용하여 java.policy 파일에 공유 클래스 권한을 추가하십시오. 예를 들면 다음과 같습니다.
</p>
<pre class="xmp">permission com.ibm.oti.shared.SharedClassPermission "com.abc.customclassloaders.*", "read,write";</pre>ClassLoader<p class="indatacontent">에
올바른 권한이 없는 경우 클래스를 공유할 수 없습니다. 기본 부트스트랩, 응용프로그램 또는 확장 클래스 로더의 권한은
변경할 수 없습니다.</p>
<a name="adaptingclassloaders"></a>
<h2 id="adaptingclassloaders"><a href="#ToC_116">클래스를 공유하기 위한 사용자 정의 클래스 로더 채택</a></h2>
<div>
<p>java.net.URLClassLoader를 확장하는 클래스 로더는
수정하지 않고 클래스를 공유할 수 있습니다. java.net.URLClassLoader를 확장하지 않는 클래스 로더는
클래스 데이터를 공유하도록 채택되어야 합니다.</p></div><a id="idx61" name="idx61"></a>
<p>SecurityManager를 사용 중인 경우 모든 사용자 정의 클래스 로더에는 공유 클래스 권한이
부여되어야 합니다. <a href="#usingsharedclasspermissions">SharedClassPermission 사용</a>을 참조하십시오. IBM은
다양한 유형의 사용자 정의 클래스 로더에 대한 여러 Java 인터페이스를 제공하며,
이 인터페이스를 통해 클래스 로더는 공유 클래스 캐시에서 클래스를 찾고 저장할 수
있습니다. 이 클래스는 com.ibm.oti.shared 패키지에 있습니다.</p>
<p>이 패키지의 Javadoc은 SDK와 함께
docs/content/apidoc 디렉토리에 제공됩니다.</p>
<p>이 인터페이스를
사용하는 방법에 대한 자세한 정보는 <a href="http://www.ibm.com/developerworks/java/jdk/diagnosis/index.html" target="_blank">진단 안내서</a>를 참조하십시오.</p>
<a name="jcommchapter"></a>
<h1 id="jcommchapter"><a href="#ToC_117">Java Communications API(JavaComm) 사용</a></h1>
<div>
<p>Java Communications API 패키지(JavaComm)는 IA32, PPC32/PPC64 및 AMD64/EM64T
플랫폼에서 Runtime Environment for Linux에 사용하도록 제공된 선택적 패키지입니다.
JavaComm은 SDK 또는 Runtime Environment와 독립적으로 설치합니다.</p></div>
<p>JavaComm API는 음성 메일, 팩스 및 스마트 카드 등의 기술에 대해 독립적 플랫폼으로
직렬 및 병렬 포트 통신을 수행하는 방법을
Java
응용프로그램에 제공합니다.</p>
<p>Java Communications API는
EIA(Electronic Industries Association)-232(RS232) 직렬 포트 및 IEEE(Institute of Electrical and Electronics Engineers) 1284
병렬 포트를 지원하며, IBM
버전 6 Runtime Environment가 설치된 시스템에서 지원됩니다.</p>
<p>Java Communications API를
사용하여 다음을 수행할 수 있습니다.</p>
<ul>
<li>시스템에 포트 나열</li>
<li>포트 소유권 개방 및 청구</li>
<li>Java Communications API를
사용하는 응용프로그램들 간의 포트 소유권 경합 해결</li>
<li>이벤트 알림을 사용하여 비동기 및 동기 I/O 포트 모니터링 수행</li>
<li>포트 상태 변경을 설명하는 Bean 스타일 이벤트 수신</li></ul>
<a name="instcomm"></a>
<h2 id="instcomm"><a href="#ToC_118">압축 파일에서 Java Communications API 설치</a></h2>
<div>
<p>Java Communications API를 설치하기 전에
SDK 또는 Runtime Environment가 설치되어 있는지 확인하십시오.</p></div>
<p>
<p>원래 RPM 패키지를 사용하여
Java를 설치한 경우, RPM 파일에서
Java Communications API를
설치하십시오. RPM 패키지에서 Java Communications
API를 설치하려면 <a href="#instcomm_rpm">RPM 파일에서 Java Communications API 설치</a>를 참조하십시오.</p>
<p>압축 파일에서
Java Communications API를 설치하려면
다음을 수행하십시오.</p></p>
<ol type="1">
<li>SDK 또는 Runtime Environment가 설치된 디렉토리에 Java Communications API 압축 파일, <a name="instcomm__install-file"></a><span id="instcomm__install-file">ibm-java-javacomm-3.0-0.0-&lt;plat&gt;-&lt;arch&gt;.tar.gz</span>를
지정하십시오. 기본 디렉토리에
설치한 경우, 이 디렉토리는 /opt/ibm/java-i386-60/입니다.</li>
<li>쉘 프롬프트에서,
압축 파일이 들어 있는 디렉토리에서 컨텐츠를 추출하십시오.  
<pre class="xmp">tar -xvzf ibm-java-javacomm-3.0-0.0-&lt;plat&gt;-&lt;arch&gt;.tar.gz</pre>



<p>여기서 <tt class="xph">&lt;arch&gt;</tt>는 아키텍처(
i386, x86_64, ppc, 또는 ppc64)를 나타냅니다.</p></li>
<li><font color="RED"><span id="changed">|</span>SDK의 적절한 디렉토리에 javacomm 파일을
<span id="changed">|</span>복사하십시오. 
<span id="changed">|</span>
<span id="changed">|</span><ol type="a">
<span id="changed">|</span><li>lib/libLinuxSerialParallel.so를
<span id="changed">|</span>jre/bin/ 디렉토리로 복사하십시오.</li>
<span id="changed">|</span><li>jar/comm.jar을
<span id="changed">|</span>jre/lib/ext/ 디렉토리로 복사하십시오.</li>
<span id="changed">|</span><li>lib/javax.comm.properties를
<span id="changed">|</span>jre/lib/ 디렉토리로 복사하십시오. </li></ol> 기본적으로 SDK는 /opt/ibm/java-i386-60/ 디렉토리에 설치되어 있습니다.</font></li></ol>
<a name="instcomm_rpm"></a>
<h2 id="instcomm_rpm"><a href="#ToC_119">RPM 파일에서 Java Communications API 설치</a></h2>
<div>
<p>Java Communications API를
설치하기 전에 SDK 또는 Runtime Environment의 사본이 설치되어 있는지 확인하십시오.</p></div>
<p>원래 RPM 패키지를 사용하여 Java를
설치한 경우, RTM 파일에서 Java Communications
API를 설치하십시오.</p>
<ol type="1">
<li>쉘 프롬프트를 열고 루트인지 확인하십시오. </li>
<li><tt class="xph">rpm -ivh</tt> 명령을 사용하여 Java
Communications API RPM 파일을 설치하십시오.  예를 들면 다음과 같습니다.


<pre class="xmp">rpm -ivh ibm-javacomm-3.0-0.0.&lt;arch&gt;.rpm</pre> Java Communications API가
/opt/ibm/java-i386-60/ 디렉토리 구조에 설치됩니다.</li>
<li><font color="RED"><span id="changed">|</span>javacomm 파일을 SDK의 적절한 디렉토리로 복사하십시오. 
<span id="changed">|</span>
<span id="changed">|</span><ol type="a">
<span id="changed">|</span><li>lib/libLinuxSerialParallel.so를 jre/bin/ 디렉토리로 복사하십시오.</li>
<span id="changed">|</span><li>jar/comm.jar을
<span id="changed">|</span>jre/lib/ext/ 디렉토리로 복사하십시오.</li>
<span id="changed">|</span><li>lib/javax.comm.properties를
<span id="changed">|</span>jre/lib/ 디렉토리로 복사하십시오.</li></ol> 기본적으로 SDK는 /opt/ibm/java-i386-60/ 디렉토리에 설치되어 있습니다.</font></li></ol>
<a name="fileloc"></a>
<h2 id="fileloc"><a href="#ToC_120">Java Communications API 파일의 위치</a></h2>
<p>
<p>기본적으로 Java
Communications API 파일은 /opt/ibm/java-i386-60/ 디렉토리에 설치됩니다.
파일 및 구조:</p></p>
<ul>
<li>jar/comm.jar</li>
<li>jar/commtest.jar</li>
<li>jar/tools/BlackBox.jar</li>
<li>jar/tools/ParallelBlackBox.jar</li>
<li>lib/javax.comm.properties</li>
<li>lib/libLinuxSerialParallel.so</li></ul>
<a name="javacomm_lnx_serial"></a>
<h2 id="javacomm_lnx_serial"><a href="#ToC_121">직렬 및 병렬 포트의 액세스 모드 변경</a></h2>
<div>
<p>Java Communications API를
설치한 후, 직렬 및 병렬 포트의 액세스 모드를 변경해야 사용자가 이러한 디바이스에 액세스할 수 있습니다.</p></div>
<p>
<p>사용자에게 필수 디바이스에 대한 읽기 및 쓰기 액세스 권한을 부여해야 합니다.
루트로 로그온하고
해당하는 경우에 따라 다음 명령을 사용하십시오.
</p>
<pre class="xmp">    chmod 660/dev/ttyS0(직렬 포트 COM1이라고도 함)
    chmod 660/dev/lp0(병렬 포트 LPT1이라고도 함)
    chmod 660/dev/ttyS1(직렬 포트 COM2라고도 함)
    chmod 660/dev/ttyS2(직렬 포트 COM3라고도 함)
    chmod 660/dev/ttyS3(직렬 포트 COM4라고도 함)</pre>
<p>특정 사용자를 디바이스가 상주하는 그룹에 추가합니다. 예를 들어, SUSE 시스템에서 해당 디바이스는
<tt>uucp</tt> 그룹에 있습니다. 그러므로 사용자를
<tt>uucp</tt> 그룹에 추가하여 디바이스에 대한 액세스 권한을
부여할 수 있습니다.</p>
<p>필요에 따라 기타 모든 포트의 액세스 모드를 변경하십시오.</p></p>
<a name="javacomm_lnx_devices"></a>
<h2 id="javacomm_lnx_devices"><a href="#ToC_122">javax.comm.properties 파일에 디바이스 지정</a></h2>
<div>
<p>javax.comm.properties 파일을 사용하여
Java Communications API에서
사용 가능한 디바이스의 접두부와 병렬 또는 직렬 여부를 지정할 수 있습니다. 모든 디바이스에 포트 번호가 순서대로 할당됩니다.</p></div>
<p>
<p>예를 들어, <tt class="xph">/dev/ttyS=PORT_SERIAL</tt>을 지정하고
<tt class="xph">/dev/ttyS0</tt> 및 <tt class="xph">/dev/ttyS1</tt> 디바이스가 있는 경우,
이들은 COM1 및 COM2에 할당됩니다.</p>
<p><span>USB 직렬 커넥터를 사용하려면
javax.comm.properties 파일의 <tt class="xph">/dev/ttyUSB=PORT_SERIAL</tt> 행에서 주석 표시를 제거하십시오</span>. 
<tt class="xph">/dev/ttyUSB0</tt> 및 <tt class="xph">/dev/ttyUSB1</tt> 디바이스가 존재하고 COM1
및 COM2가 이미 정의된 경우, USB 직렬 디바이스는 그 다음 순서의 포트,
COM3 및 COM4에 할당됩니다.</p></p>
<a name="javacomm_thinkpad"></a>
<h2 id="javacomm_thinkpad"><a href="#ToC_123">IBM ThinkPad에서 직렬 포트 사용</a></h2>
<div>
<p>대부분의 ThinkPad는 BIOS 기본값으로 직렬 포트가 사용 불가능으로 설정되어 있습니다.
현재 Linux에서 해당 포트를
사용할 방법이 없습니다. (BIOS에서 tpctl 패키지를 사용할 수 없는 경우 tpctl 패키지는 포트를 사용할 수 <em>없습니다</em>.)</p></div>
<p>
<p>BIOS에서 포트를 사용하려면 IBM ThinkPad
다운로드 사이트에서 사용 가능한 ThinkPad Configuration Utility의 DOS 버전을 사용해야 합니다. ThinkPad Configuration Utility를 사용하려면
부트 가능한 DOS 디스켓이 필요합니다. ThinkPad Configuration Utility는 설치 옵션에 따라  Windows<sup>(R)</sup>에서 ThinkPad Utilities의 일부로 설치되었을 수 있으며,
Windows의
명령 프롬프트에서 실행할 수 있습니다.</p>
<p>Windows와
함께 제공된 ThinkPad Configuration에는 직렬 및 병렬 포트를 사용 가능 또는 사용 불가능으로 설정할 수 있는 옵션이 있으나
BIOS의 설정까지 변경하지는 <em>않습니다</em>. 그러므로
Windows에서 이 응용프로그램을 사용하는 경우
포트를 사용할 수 있습니다. 그러나 Linux로
시스템을 다시 시동하면 포트를 사용할 수 <em>없게</em> 됩니다.</p></p>
<a name="javacomm_printing"></a>
<h2 id="javacomm_printing"><a href="#ToC_124">Java Communications API의 제한사항 인쇄</a></h2>
<div>
<p>Java Communications API로 인쇄하는 경우,
프린터에서 『용지 넘김』, 『계속』 또는 이와 유사한 옵션을 선택해야 할 수 있습니다.</p></div>
<a name="javacomm_lnx_remove"></a>
<h2 id="javacomm_lnx_remove"><a href="#ToC_125">Java Communications API 설치 제거</a></h2>
<div>
<p>Java Communications API를
설치 제거하는 프로세스는 설치 가능한 RPM(Red Hat Package Manager) 패키지 또는 압축된 TAR(Tape Archive) 패키지의 설치 여부에 따라
달라집니다.</p></div>
<p></p>
<a name="javacomm_redhat_remove"></a>
<h3 id="javacomm_redhat_remove"><a href="#ToC_126">Red Hat Package Manager(RPM) 패키지 설치 제거</a></h3>
<div>
<p>RPM 패키지를 사용하여 Java
Communications API를 설치 제거합니다.</p></div>
<p></p>
<ol type="1">
<li>rpm 도구를 사용하여 패키지를 설치하십시오. 쉘 프롬프트에 다음 명령을 입력하십시오.



<pre class="xmp">rpm -e ibm-javacomm-3.0-0.0</pre> kpackage 또는 yast2와 같은 그래픽 도구를 사용할 수도 있습니다.</li>
<li>Java Communications
API를 설치한 디렉토리에 필요한 다른 도구가 없는 경우, <strong>PATH</strong> 명령문으로 해당 디렉토리를 제거하십시오. </li>
<li><font color="RED"><span id="changed">|</span>javacomm 라이브러리를
<span id="changed">|</span>SDK 디렉토리로 복사한 후 다음 파일을 SDK 디렉토리에서 삭제하십시오.
<span id="changed">|</span>
<span id="changed">|</span><ul>
<span id="changed">|</span><li>jre/bin/libLinuxSerialParallel.so</li>
<span id="changed">|</span><li>jre/lib/ext/comm.jar</li>
<span id="changed">|</span><li>jre/lib/javax.comm.properties</li></ul> 기본적으로 SDK는 /opt/ibm/java-i386-60/ 디렉토리에 설치되어 있습니다.</font></li></ol>
<a name="javacomm_tar_remove"></a>
<h3 id="javacomm_tar_remove"><a href="#ToC_127">압축된 TAR(Tape Archive) 패키지 설치 제거</a></h3>
<div>
<p>압축된 TAR 패키지를 설치한 경우 Java
Communications API 설치 제거</p></div>
<p>
<p> 설치한 디렉토리에서 다음 파일을 제거하십시오.</p></p>
<ul><font color="RED"><span id="changed">|</span>
<span id="changed">|</span><li>jre/bin/libLinuxSerialParallel.so</li>
<span id="changed">|</span><li>jre/lib/ext/comm.jar</li>
<span id="changed">|</span><li>jre/lib/javax.comm.properties</li></font></ul>
<a name="javacomm_apidoc"></a>
<h2 id="javacomm_apidoc"><a href="#ToC_128">Java Communications API 문서</a></h2>
<div>
<p>Sun 웹 사이트에서 Java Communications
API에 대한 API 문서 및 샘플을 찾을 수 있습니다.</p></div>
<p>
<p><a href="http://java.sun.com/products/javacomm/" target="_blank">http://java.sun.com/products/javacomm/</a></p></p>
<a name="support"></a>
<h1 id="support"><a href="#ToC_129">ISV(독립 소프트웨어 벤더)에 대한 서비스 및 지원</a></h1>
<div>
<p>서비스의 연결 지점:</p></div>
<p> 귀하가 IBM
Solutions Developer Program에 의거하여 프로그램 코드에 대한 서비스를
제공받을 수 있는 권한이 있는 경우에는 일반 문의 방법이나
웹 사이트(<a href="http://www.ibm.com/partnerworld/" target="_blank">http://www.ibm.com/partnerworld/</a>)를 통해
IBM Solutions Developer Program에 접속하십시오.</p>
<p>귀하가 서비스 계약(즉, IBM의 개인 시스템 지원 라인 또는 그와 동등한 수준의
국가별 서비스)을 취득한 경우에는 해당 서비스 계약의 조건에 준하여
프로그램에 대한 서비스를 제공받을 수 있습니다.</p>
<a name="accessibility"></a>
<h1 id="accessibility"><a href="#ToC_130">내게 필요한 옵션</a></h1>
<div>
<p>이 SDK 및
Runtime Environment와 함께 제공되는 사용자 안내서는
화면 판독기를 사용하여 테스트되었습니다.</p></div>
<p>사용자 안내서의 글꼴 크기를 변경하려면 일반적으로 브라우저의 <strong>보기</strong>
메뉴 옵션 아래에 있는 기능을 사용하십시오.</p>
<p>키보드 탐색이 필요한 사용자를 위해 웹 사이트 <a href="http://www.ibm.com/developerworks/java/jdk/additional/" target="_blank">http://www.ibm.com/developerworks/java/jdk/additional/</a>의
<cite>Swing 키 바인딩</cite>에서 Swing 응용프로그램의 유용한 키스트로크에 대한 설명을 포함하고 있습니다.</p>
<a name="access_keyboard"></a>
<h2 id="access_keyboard"><a href="#ToC_131">Swing에서 JComboBox 구성요소의 키보드 종단</a></h2>
<div>
<p>커서 키로 JComboBox 구성요소의 드롭 다운 목록을 순회하는 경우,
JComboBox의 단추 또는 편집 가능 필드는 항목을 선택할 때까지 값이
변경되지 않습니다. 이것은 이번 릴리스에서 올바른 작동이며, 키보드 종단 작동을 마우스 종단 작동과 일치시켜
내게 필요한 옵션 및 사용성을 높입니다.</p></div>
<a name="access_webstart"></a>
<h2 id="access_webstart"><a href="#ToC_132">Web Start 내게 필요한 옵션(Linux
IA 32-bit, PPC32 및 PPC64에만 해당)</a></h2>
<div>
<p>Java Web Start의
버전 5.0부터는 화면 판독기에 대한 개선된 지원 및 향상된 키보드 탐색 등 몇 가지 내게 필요한 옵션 및 사용성 개선사항이 있습니다.</p></div>
<p>명령행은 Web Start에서 사용되는 Java 응용프로그램을
실행하기 위해서만 사용할 수 있습니다. 환경 설정 옵션을 변경하려면, 사용자의 홈 디렉토리에서
구성 파일인, .java/.deployment/.deployment.properties를 편집해야 합니다. 이 파일을 편집하기 전에 백업을 수행하십시오.
Java 응용프로그램 캐시 뷰어에서
설정할 수 있는 모든 환경 설정을 구성 파일에서 사용할 수 있는 것은 아닙니다.</p>
<a name="rcf"></a>
<h1 id="rcf"><a href="#ToC_133">이 책에 대한 고객 의견</a></h1>
<div>
<p>사용자 안내서에 대한 귀하의 의견을 아래와 같은 방법으로 보내주십시오.
이는 기술적 질문에 대한 답변을 드리기 위한 것은 아니며 문서에 대한 귀하의 의견을 듣기 위한 것입니다.</p></div>
<p></p>
<head>
<meta http-equiv=Content-Type content="text/html; charset=ks_c_5601-1987">
<meta name=ProgId content=Word.Document>
<meta name=Generator content="Microsoft Word 11">
<meta name=Originator content="Microsoft Word 11">
<link rel=File-List href="IBM%20한글%20지원에%20관한%20설문.files/filelist.xml">
<title>IBM 한글 지원에 관한 설문</title>
<style>
<!--
 /* Font Definitions */
 @font-face
	{font-family:바탕;
	panose-1:2 3 6 0 0 1 1 1 1 1;
	mso-font-alt:Batang;
	mso-font-charset:129;
	mso-generic-font-family:roman;
	mso-font-pitch:variable;
	mso-font-signature:-1342176593 1775729915 48 0 524447 0;}
@font-face
	{font-family:굴림;
	panose-1:2 11 6 0 0 1 1 1 1 1;
	mso-font-alt:Gulim;
	mso-font-charset:129;
	mso-generic-font-family:modern;
	mso-font-pitch:variable;
	mso-font-signature:-1342176593 1775729915 48 0 524447 0;}
@font-face
	{font-family:"\@굴림";
	panose-1:2 11 6 0 0 1 1 1 1 1;
	mso-font-charset:129;
	mso-generic-font-family:modern;
	mso-font-pitch:variable;
	mso-font-signature:-1342176593 1775729915 48 0 524447 0;}
@font-face
	{font-family:"\@바탕";
	panose-1:2 3 6 0 0 1 1 1 1 1;
	mso-font-charset:129;
	mso-generic-font-family:roman;
	mso-font-pitch:variable;
	mso-font-signature:-1342176593 1775729915 48 0 524447 0;}
 /* Style Definitions */
 p.MsoNormal, li.MsoNormal, div.MsoNormal
	{mso-style-parent:"";
	margin:0cm;
	margin-bottom:.0001pt;
	text-align:justify;
	text-justify:inter-ideograph;
	mso-pagination:none;
	text-autospace:none;
	word-break:break-hangul;
	font-size:10.0pt;
	mso-bidi-font-size:12.0pt;
	font-family:바탕;
	mso-hansi-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";
	mso-font-kerning:1.0pt;}
span.SpellE
	{mso-style-name:"";
	mso-spl-e:yes;}
span.GramE
	{mso-style-name:"";
	mso-gram-e:yes;}
 /* Page Definitions */
 @page
	{mso-page-border-surround-header:no;
	mso-page-border-surround-footer:no;}
@page Section1
	{size:595.3pt 841.9pt;
	margin:99.25pt 3.0cm 3.0cm 3.0cm;
	mso-header-margin:42.55pt;
	mso-footer-margin:49.6pt;
	mso-paper-source:0;
	layout-grid:18.0pt;}
div.Section1
	{page:Section1;}
 /* List Definitions */
 @list l0
	{mso-list-id:1063141110;
	mso-list-type:hybrid;
	mso-list-template-ids:-1039495510 -174947900 67698713 67698715 67698703 67698713 67698715 67698703 67698713 67698715;}
@list l0:level1
	{mso-level-tab-stop:38.0pt;
	mso-level-number-position:left;
	margin-left:38.0pt;
	text-indent:-18.0pt;}
ol
	{margin-bottom:0cm;}
ul
	{margin-bottom:0cm;}
-->
</style>
<!--[if gte mso 10]>
<style>
 /* Style Definitions */
 table.MsoNormalTable
	{mso-style-name:"표준 표";
	mso-tstyle-rowband-size:0;
	mso-tstyle-colband-size:0;
	mso-style-noshow:yes;
	mso-style-parent:"";
	mso-padding-alt:0cm 5.4pt 0cm 5.4pt;
	mso-para-margin:0cm;
	mso-para-margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:"Times New Roman";
	mso-ansi-language:#0400;
	mso-fareast-language:#0400;
	mso-bidi-language:#0400;}
table.MsoTableGrid
	{mso-style-name:"표 구분선";
	mso-tstyle-rowband-size:0;
	mso-tstyle-colband-size:0;
	border:solid windowtext 1.0pt;
	mso-border-alt:solid windowtext .5pt;
	mso-padding-alt:0cm 5.4pt 0cm 5.4pt;
	mso-border-insideh:.5pt solid windowtext;
	mso-border-insidev:.5pt solid windowtext;
	mso-para-margin:0cm;
	mso-para-margin-bottom:.0001pt;
	text-align:justify;
	text-justify:inter-ideograph;
	mso-pagination:none;
	text-autospace:none;
	word-break:break-hangul;
	font-size:10.0pt;
	font-family:"Times New Roman";
	mso-ansi-language:#0400;
	mso-fareast-language:#0400;
	mso-bidi-language:#0400;}
</style>
<![endif]-->
</head>

<body lang=KO style='tab-interval:40.0pt'>

<div class=Section1 style='layout-grid:18.0pt'>

<p class=MsoNormal><b style='mso-bidi-font-weight:normal'><span lang=EN-US
style='font-size:12.0pt;font-family:굴림'>IBM </span></b><b style='mso-bidi-font-weight:
normal'><span style='font-size:12.0pt;font-family:굴림'>한글 지원에 관한 설문<span
lang=EN-US><o:p></o:p></span></span></b></p>

<p class=MsoNormal><span lang=EN-US style='font-family:굴림'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span lang=EN-US style='font-size:11.0pt;font-family:굴림'>FAX:
(02) 3787-0123<o:p></o:p></span></p>

<p class=MsoNormal><span style='font-size:11.0pt;font-family:굴림'>보내 주시는 의견은 더 나은
고객 지원 체제를 위한 귀중한 자료가 됩니다<span lang=EN-US>. </span>독자 여러분의 좋은 의견을 기다립니다<span
lang=EN-US>. <o:p></o:p></span></span></p>

<p class=MsoNormal><span lang=EN-US style='font-size:11.0pt;font-family:굴림'><o:p>&nbsp;</o:p></span></p>

<table class=MsoTableGrid border=1 cellspacing=0 cellpadding=0
 style='border-collapse:collapse;border:none;mso-border-alt:solid windowtext .5pt;
 mso-yfti-tbllook:191;mso-padding-alt:0cm 5.4pt 0cm 5.4pt;mso-border-insideh:
 .5pt solid windowtext;mso-border-insidev:.5pt solid windowtext'>
 <tr style='mso-yfti-irow:0;mso-yfti-firstrow:yes'>
  <td width=103 valign=top style='width:77.4pt;border:solid windowtext 1.0pt;
  mso-border-alt:solid windowtext .5pt;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal align=center style='text-align:center'><span
  style='font-size:11.0pt;font-family:굴림'>성명<span lang=EN-US><o:p></o:p></span></span></p>
  </td>
  <td width=187 colspan=2 valign=top style='width:140.1pt;border:solid windowtext 1.0pt;
  border-left:none;mso-border-left-alt:solid windowtext .5pt;mso-border-alt:
  solid windowtext .5pt;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:11.0pt;font-family:굴림'><o:p>&nbsp;</o:p></span></p>
  </td>
  <td width=113 valign=top style='width:84.9pt;border:solid windowtext 1.0pt;
  border-left:none;mso-border-left-alt:solid windowtext .5pt;mso-border-alt:
  solid windowtext .5pt;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span style='font-size:11.0pt;font-family:굴림'>직위<span
  lang=EN-US>/</span>담당 업무<span lang=EN-US><o:p></o:p></span></span></p>
  </td>
  <td width=177 valign=top style='width:132.7pt;border:solid windowtext 1.0pt;
  border-left:none;mso-border-left-alt:solid windowtext .5pt;mso-border-alt:
  solid windowtext .5pt;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:11.0pt;font-family:굴림'><o:p>&nbsp;</o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:1'>
  <td width=103 valign=top style='width:77.4pt;border:solid windowtext 1.0pt;
  border-top:none;mso-border-top-alt:solid windowtext .5pt;mso-border-alt:solid windowtext .5pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal align=center style='text-align:center'><span
  style='font-size:11.0pt;font-family:굴림'>회사명<span lang=EN-US><o:p></o:p></span></span></p>
  </td>
  <td width=187 colspan=2 valign=top style='width:140.1pt;border-top:none;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:solid windowtext 1.0pt;
  mso-border-top-alt:solid windowtext .5pt;mso-border-left-alt:solid windowtext .5pt;
  mso-border-alt:solid windowtext .5pt;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:11.0pt;font-family:굴림'><o:p>&nbsp;</o:p></span></p>
  </td>
  <td width=113 valign=top style='width:84.9pt;border-top:none;border-left:
  none;border-bottom:solid windowtext 1.0pt;border-right:solid windowtext 1.0pt;
  mso-border-top-alt:solid windowtext .5pt;mso-border-left-alt:solid windowtext .5pt;
  mso-border-alt:solid windowtext .5pt;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal align=center style='text-align:center'><span
  style='font-size:11.0pt;font-family:굴림'>부서명<span lang=EN-US><o:p></o:p></span></span></p>
  </td>
  <td width=177 valign=top style='width:132.7pt;border-top:none;border-left:
  none;border-bottom:solid windowtext 1.0pt;border-right:solid windowtext 1.0pt;
  mso-border-top-alt:solid windowtext .5pt;mso-border-left-alt:solid windowtext .5pt;
  mso-border-alt:solid windowtext .5pt;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:11.0pt;font-family:굴림'><o:p>&nbsp;</o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:2'>
  <td width=103 valign=top style='width:77.4pt;border:solid windowtext 1.0pt;
  border-top:none;mso-border-top-alt:solid windowtext .5pt;mso-border-alt:solid windowtext .5pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal align=center style='text-align:center'><span
  style='font-size:11.0pt;font-family:굴림'>주소<span lang=EN-US><o:p></o:p></span></span></p>
  </td>
  <td width=477 colspan=4 valign=top style='width:357.7pt;border-top:none;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:solid windowtext 1.0pt;
  mso-border-top-alt:solid windowtext .5pt;mso-border-left-alt:solid windowtext .5pt;
  mso-border-alt:solid windowtext .5pt;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:11.0pt;font-family:굴림'><o:p>&nbsp;</o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:3'>
  <td width=145 colspan=2 valign=top style='width:108.75pt;border:solid windowtext 1.0pt;
  border-top:none;mso-border-top-alt:solid windowtext .5pt;mso-border-alt:solid windowtext .5pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal align=center style='text-align:center'><span
  style='font-size:11.0pt;font-family:굴림'>전화번호<span lang=EN-US><o:p></o:p></span></span></p>
  </td>
  <td width=145 valign=top style='width:108.75pt;border-top:none;border-left:
  none;border-bottom:solid windowtext 1.0pt;border-right:solid windowtext 1.0pt;
  mso-border-top-alt:solid windowtext .5pt;mso-border-left-alt:solid windowtext .5pt;
  mso-border-alt:solid windowtext .5pt;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:11.0pt;font-family:굴림'><o:p>&nbsp;</o:p></span></p>
  </td>
  <td width=113 valign=top style='width:84.9pt;border-top:none;border-left:
  none;border-bottom:solid windowtext 1.0pt;border-right:solid windowtext 1.0pt;
  mso-border-top-alt:solid windowtext .5pt;mso-border-left-alt:solid windowtext .5pt;
  mso-border-alt:solid windowtext .5pt;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal align=center style='text-align:center'><span class=SpellE><span
  style='font-size:11.0pt;font-family:굴림'>팩스번호</span></span><span lang=EN-US
  style='font-size:11.0pt;font-family:굴림'><o:p></o:p></span></p>
  </td>
  <td width=177 valign=top style='width:132.7pt;border-top:none;border-left:
  none;border-bottom:solid windowtext 1.0pt;border-right:solid windowtext 1.0pt;
  mso-border-top-alt:solid windowtext .5pt;mso-border-left-alt:solid windowtext .5pt;
  mso-border-alt:solid windowtext .5pt;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:11.0pt;font-family:굴림'><o:p>&nbsp;</o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:4'>
  <td width=145 colspan=2 valign=top style='width:108.75pt;border:solid windowtext 1.0pt;
  border-top:none;mso-border-top-alt:solid windowtext .5pt;mso-border-alt:solid windowtext .5pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal align=center style='text-align:center'><span class=SpellE><span
  style='font-size:11.0pt;font-family:굴림'>전자우편</span></span><span
  style='font-size:11.0pt;font-family:굴림'> 주소<span lang=EN-US><o:p></o:p></span></span></p>
  </td>
  <td width=435 colspan=3 valign=top style='width:326.35pt;border-top:none;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:solid windowtext 1.0pt;
  mso-border-top-alt:solid windowtext .5pt;mso-border-left-alt:solid windowtext .5pt;
  mso-border-alt:solid windowtext .5pt;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:11.0pt;font-family:굴림'><o:p>&nbsp;</o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:5;mso-yfti-lastrow:yes'>
  <td width=145 colspan=2 valign=top style='width:108.75pt;border:solid windowtext 1.0pt;
  border-top:none;mso-border-top-alt:solid windowtext .5pt;mso-border-alt:solid windowtext .5pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal align=center style='text-align:center'><span
  style='font-size:11.0pt;font-family:굴림'>사용 중인 시스템<span lang=EN-US><o:p></o:p></span></span></p>
  </td>
  <td width=435 colspan=3 valign=top style='width:326.35pt;border-top:none;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:solid windowtext 1.0pt;
  mso-border-top-alt:solid windowtext .5pt;mso-border-left-alt:solid windowtext .5pt;
  mso-border-alt:solid windowtext .5pt;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:11.0pt;font-family:굴림'><o:p>&nbsp;</o:p></span></p>
  </td>
 </tr>
 <![if !supportMisalignedColumns]>
 <tr height=0>
  <td width=103 style='border:none'></td>
  <td width=42 style='border:none'></td>
  <td width=145 style='border:none'></td>
  <td width=113 style='border:none'></td>
  <td width=177 style='border:none'></td>
 </tr>
 <![endif]>
</table>

<p class=MsoNormal><span lang=EN-US style='font-size:11.0pt;font-family:굴림'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='margin-left:38.0pt;text-indent:-18.0pt;mso-list:l0 level1 lfo1;
tab-stops:list 38.0pt'><![if !supportLists]><span lang=EN-US style='font-size:
11.0pt;font-family:굴림;mso-bidi-font-family:굴림'><span style='mso-list:Ignore'>1.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><![endif]><span
lang=EN-US style='font-size:11.0pt;font-family:굴림'>IBM</span><span
style='font-size:11.0pt;font-family:굴림'>에서 제공하는 한글 책자와 영문 책자 중 어느 것을 더 좋아하십니까<span
lang=EN-US>? </span>그 이유는 무엇입니까<span lang=EN-US>?<o:p></o:p></span></span></p>

<p class=MsoNormal style='text-indent:40.0pt'><span style='font-size:11.0pt;
font-family:굴림'>□ 한글 책자<span lang=EN-US><span style='mso-tab-count:3'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
style='mso-spacerun:yes'>&nbsp;&nbsp;&nbsp;&nbsp; </span></span>□ 영문 책자<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal style='margin-left:38.0pt'><span lang=EN-US
style='font-size:11.0pt;font-family:굴림'>(</span><span style='font-size:11.0pt;
font-family:굴림'>이유<span class=GramE><span lang=EN-US>: <span
style='mso-spacerun:yes'>&nbsp;</span><span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
style='mso-tab-count:7'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>)</span></span><span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal style='margin-left:38.0pt;text-indent:-18.0pt;mso-list:l0 level1 lfo1;
tab-stops:list 38.0pt'><![if !supportLists]><span lang=EN-US style='font-size:
11.0pt;font-family:굴림;mso-bidi-font-family:굴림'><span style='mso-list:Ignore'>2.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><![endif]><span
style='font-size:11.0pt;font-family:굴림'>본 책자와 해당 소프트웨어에서 사용된 한글 용어에 대한 귀하의 평가 점수는<span
lang=EN-US>?<o:p></o:p></span></span></p>

<p class=MsoNormal style='margin-left:20.0pt;text-indent:20.0pt'><span
style='font-size:11.0pt;font-family:굴림'>□ 수<span lang=EN-US><span
style='mso-spacerun:yes'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>□ 우<span lang=EN-US><span
style='mso-spacerun:yes'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>□ 미<span lang=EN-US><span
style='mso-spacerun:yes'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>□ 양<span lang=EN-US><span
style='mso-spacerun:yes'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>□ 가 <span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal style='margin-left:38.0pt;text-indent:-18.0pt;mso-list:l0 level1 lfo1;
tab-stops:list 38.0pt'><![if !supportLists]><span lang=EN-US style='font-size:
11.0pt;font-family:굴림;mso-bidi-font-family:굴림'><span style='mso-list:Ignore'>3.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><![endif]><span
style='font-size:11.0pt;font-family:굴림'>본 책자와 해당 소프트웨어에서 번역 품질에 대한 귀하의 평가 점수는<span
lang=EN-US>?<o:p></o:p></span></span></p>

<p class=MsoNormal style='margin-left:20.0pt;text-indent:20.0pt'><span
style='font-size:11.0pt;font-family:굴림'>□ 수<span lang=EN-US><span
style='mso-spacerun:yes'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>□ 우<span lang=EN-US><span
style='mso-spacerun:yes'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>□ 미<span lang=EN-US><span
style='mso-spacerun:yes'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>□ 양<span lang=EN-US><span
style='mso-spacerun:yes'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>□ 가 <span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal style='margin-left:38.0pt;text-indent:-18.0pt;mso-list:l0 level1 lfo1;
tab-stops:list 38.0pt'><![if !supportLists]><span lang=EN-US style='font-size:
11.0pt;font-family:굴림;mso-bidi-font-family:굴림'><span style='mso-list:Ignore'>4.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><![endif]><span
style='font-size:11.0pt;font-family:굴림'>본 책자의 인쇄 상태에 대한 귀하의 평가 점수는<span
lang=EN-US>?<o:p></o:p></span></span></p>

<p class=MsoNormal style='margin-left:20.0pt;text-indent:20.0pt'><span
style='font-size:11.0pt;font-family:굴림'>□ 수<span lang=EN-US><span
style='mso-spacerun:yes'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>□ 우<span lang=EN-US><span
style='mso-spacerun:yes'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>□ 미<span lang=EN-US><span
style='mso-spacerun:yes'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>□ 양<span lang=EN-US><span
style='mso-spacerun:yes'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>□ 가 <span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal style='margin-left:38.0pt;text-indent:-18.0pt;mso-list:l0 level1 lfo1;
tab-stops:list 38.0pt'><![if !supportLists]><span lang=EN-US style='font-size:
11.0pt;font-family:굴림;mso-bidi-font-family:굴림'><span style='mso-list:Ignore'>5.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><![endif]><span
style='font-size:11.0pt;font-family:굴림'>한글 소프트웨어 및 책자가 지원되는 분야에 대해 <span
class=GramE>귀하는 어떻게 생각하십니까</span><span lang=EN-US>? <o:p></o:p></span></span></p>

<p class=MsoNormal style='margin-left:20.0pt;text-indent:20.0pt'><span
style='font-size:11.0pt;font-family:굴림'>□ 한글 책자를 늘려야 함<span lang=EN-US><span
style='mso-spacerun:yes'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>□ 현재 수준으로 만족<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal style='margin-left:20.0pt;text-indent:20.0pt'><span
style='font-size:11.0pt;font-family:굴림'>□ 그다지 필요성을 느끼지 않음<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal style='margin-left:38.0pt;text-indent:-18.0pt;mso-list:l0 level1 lfo1;
tab-stops:list 38.0pt'><![if !supportLists]><span lang=EN-US style='font-size:
11.0pt;font-family:굴림;mso-bidi-font-family:굴림'><span style='mso-list:Ignore'>6.<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><![endif]><span
lang=EN-US style='font-size:11.0pt;font-family:굴림'>IBM</span><span
style='font-size:11.0pt;font-family:굴림'>은 인쇄물 형식<span lang=EN-US>(hardcopy)</span>과
화면 형식<span lang=EN-US>(softcopy)</span>의 두 종류로 책자를 제공합니다<span lang=EN-US>. </span>어느
형식을 더 좋아하십니까<span lang=EN-US>?<o:p></o:p></span></span></p>

<p class=MsoNormal style='text-indent:40.0pt'><span style='font-size:11.0pt;
font-family:굴림'>□ 인쇄물 형식<span lang=EN-US>(hardcopy<span class=GramE>)<span
style='mso-spacerun:yes'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
lang=EN-US><span lang=EN-US>□</span></span></span></span> 화면 형식<span
lang=EN-US>(softcopy)<span
style='mso-spacerun:yes'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span>□ 둘
다<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal style='margin-left:20.0pt'><span lang=EN-US
style='font-size:11.0pt;font-family:굴림'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='margin-left:20.0pt'><span lang=EN-US
style='font-size:11.0pt;font-family:굴림'>IBM </span><span style='font-size:11.0pt;
font-family:굴림'>한글 지원 서비스에 대해 기타 <span class=SpellE>제안사항이</span> 있으시면 적어주십시오<span
lang=EN-US>. <o:p></o:p></span></span></p>

<p class=MsoNormal style='margin-left:20.0pt'><span lang=EN-US
style='font-size:11.0pt;font-family:굴림'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='margin-left:20.0pt'><span lang=EN-US
style='font-size:11.0pt;font-family:굴림'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal style='margin-left:20.0pt'><span style='font-size:11.0pt;
font-family:굴림'>설문에 답해주셔서 감사합니다<span lang=EN-US>.<o:p></o:p></span></span></p>

<p class=MsoNormal style='margin-left:20.0pt'><span style='font-size:11.0pt;
font-family:굴림'>귀하의 의견은 저희에게 매우 소중한 것이며<span lang=EN-US>, </span>고객 여러분들께 보다 좋은
제품을 제공해 드리기 위해 최선을 다하겠습니다<span lang=EN-US>. <o:p></o:p></span></span></p>

</div>

</body>

<p>IBM<sup>®</sup>에 의견을 보내는 경우,
IBM은 질문, 의견, 제안 등과 같은
귀하의 의견에 포함된 모든 정보를
기밀이 아닌 것으로 간주하여 이러한 정보와 관련하여서는 아무 책임을 지지 않으며
이 정보를 제한 없이 복제, 사용, 발표 및 타인에게 배포할 수 있습니다. 나아가
IBM은 본 정보와
연관된 제품의 개발, 제조, 마케팅을 포함하여(단, 이에 한하지 않음)
어떠한 목적으로도 본 정보에 포함된 아이디어, 개념, 노하우 또는 기술을 제한없이 사용할 수 있습니다. </p>
</div>
<div></div>	  
</body>

<a name="xoptions"></a>
<h1 id="xoptions"><a href="#ToC_134">부록A. 비표준 옵션</a></h1>
<div>
<p>아래의 <strong>-X</strong> 옵션은 비표준 옵션이며 별도의 통지없이
변경될 수 있습니다.</p></div>
<p>
<p><em>&lt;size&gt;</em> 매개변수를 사용하는 옵션의 경우,
숫자에 "k" 또는 "K"를 접미부로 사용하여 KB를 표시하거나, "m" 또는 "M"를 사용하여 MB를 표시하거나,
"g" 또는 "G"를 사용하여 GB를 표시합니다.</p>
<p><em>&lt;percentage&gt;</em> 매개변수를 사용하는 옵션의 경우,
0 -1 범위의 숫자를 사용하십시오. (예: 50%는 0.5입니다.)</p></p>
<dl class="parml">
<dt class="bold"><strong>-Xargencoding</strong></dt>
<dd> Unicode 이스케이프 문자열을 인수 목록에 둘 수 있습니다. 이 옵션은 기본적으로 off로 설정됩니다.
</dd>
<dt class="bold"><strong>-Xbootclasspath</strong>:<em>&lt;:으로 구분되는 디렉토리 및 zip 또는 jar 파일&gt;</em></dt>
<dd> 부트스트랩 클래스 및 자원의 탐색 경로를 설정합니다. 기본값은
내부 VM 디렉토리 및 .jar 파일에서 부트스트랩 클래스 및 자원을 검색하는 것입니다.
</dd>
<dt class="bold"><strong>-Xbootclasspath/a</strong>:<em>&lt;:으로 구분되는 디렉토리 및 zip 또는 jar 파일&gt;</em></dt>
<dd> 지정한 디렉토리, zip 또는 jar 파일을 부트스트랩 클래스 경로 끝에
추가합니다. 기본값은
내부 VM 디렉토리 및 .jar 파일에서 부트스트랩 클래스 및 자원을 검색하는 것입니다.
</dd>
<dt class="bold"><strong>-Xbootclasspath/p</strong>:<em>&lt;:으로 구분되는 디렉토리 및 zip 또는 jar 파일&gt;</em></dt>
<dd> 지정한 디렉토리, zip 또는 jar 파일을
부트스트랩 클래스 경로 앞에 추가합니다. <strong>-Xbootclasspath:</strong> 또는 <strong>-Xbootclasspath/p:</strong> 옵션을 사용하여
표준 API의 클래스를 대체하는 응용프로그램은 배치하지 마십시오. 이러한 배치는
Java Runtime Environment 2진 코드 라이센스를 위반합니다.
기본값은 내부 VM 디렉토리 및 .jar 파일에서 부트스트랩 클래스 및 자원을 검색하는 것입니다.
</dd>
<dt class="bold"><font color="RED"><span id="changed">|</span><strong>-Xcheck:classpath</strong></font></dt>
<dd><font color="RED"><span id="changed">|</span>클래스 경로에서 감지된 오류가 경고 메시지인지 표시합니다(예: 디렉토리 또는 JAR 파일 누락).</font>
</dd>
<dt class="bold"><span class="synph"><span class="kwd">-Xcheck:gc</span><span class="delim">[</span><span class="delim">:</span><span class="var">&lt;scan
options&gt;</span><span class="delim">]</span><span class="delim">[</span><span class="delim">:</span><span class="var">&lt;verify
options&gt;</span><span class="delim">]</span><span class="delim">[</span><span class="delim">:</span><span class="var">&lt;misc
options&gt;</span><span class="delim">]</span></span></dt>
<dd> 가비지 콜렉션을 추가로 확인합니다. 기본값은 확인하지 않는 것입니다. 자세한 정보는
<strong>-Xcheck:gc:help</strong>의 출력을 확인하십시오.
</dd>
<dt class="bold"><a id="xoptions__xcheckjni" name="xoptions__xcheckjni"></a><strong>-Xcheck:jni</strong></dt>
<dd>JNI 기능의 추가 점검을 수행합니다. 기본값은 점검을 수행하지 않는 것입니다.
</dd>
<dt class="bold"><font color="RED"><span id="changed">|</span><span class="synph"><span class="kwd">-Xcheck:memory</span><span class="delim">[</span><span class="delim">:</span><span class="var">&lt;option&gt;</span><span class="delim">]</span></span></font></dt>
<dd><a id="idx62" name="idx62"></a><a id="idx63" name="idx63"></a>엄격하게 확인하여
JVM 내에서 장애 시 JVM 종료의 원인이 되는 메모리 누수를 식별합니다. 옵션을 지정하지 않으면 기본적으로
<strong>all</strong>이 사용됩니다. 자세한 정보는 <strong>-Xcheck:memory:help</strong>의 출력 또는
<a href="http://www.ibm.com/developerworks/java/jdk/diagnosis/60.html" target="_blank">진단 안내서</a>를
확인하십시오.
</dd>
<dt class="bold"><a id="xoptions__xchecknabounds" name="xoptions__xchecknabounds"></a><strong>-Xcheck:nabounds</strong></dt>
<dd> JNI 기능의 추가 점검을 수행합니다. 기본값은 점검을 수행하지 않는 것입니다.
</dd>
<dt class="bold"><a id="xoptions__classgc" name="xoptions__classgc"></a><strong>-Xclassgc</strong></dt>
<dd> 모든 가비지 콜렉션에서 클래스 오브젝트의 콜렉션을 사용합니다. <a href="#xoptions__noclassgc"><strong>-Xnoclassgc</strong></a>도
참조하십시오.
이 옵션은 기본적으로
사용됩니다.
</dd>
<dt class="bold"><strong>-Xcodecache</strong><em>&lt;size&gt;</em></dt>
<dd> 컴파일된 Java 메소드의
원시 코드를 저장하기 위해 할당할 메모리 블록의 단위 크기를 설정합니다. 적절한 크기는 실행 중인 응용프로그램에 대해
선택할 수 있습니다. 기본적으로 이 옵션은 CPU 아키텍처 및 시스템 성능에 따라 내부적으로 선택됩니다.
</dd>
<dt class="bold"><a id="xoptions__compactexplicitgc" name="xoptions__compactexplicitgc"></a><strong>-Xcompactexplicitgc</strong></dt>
<dd><tt class="xph">System.gc()</tt>에 대한 모든 호출을 압축합니다.
<a href="#xoptions__nocompactexplicitgc"><strong>-Xnocompactexplicitgc</strong></a>도 참조하십시오. 기본적으로 내부로 트리거된 경우에만 압축이 발생합니다.
</dd>
<dt class="bold"><a id="xoptions__compactgc" name="xoptions__compactgc"></a><strong>-Xcompactgc</strong></dt>
<dd>모든 가비지 콜렉션을 압축합니다. <a href="#xoptions__nocompactgc"><strong>-Xnocompactgc</strong></a>도 참조하십시오. 기본적으로
내부로 트리거된 경우에만 압축이 수행됩니다.
</dd>
<dt class="bold"><strong>-Xconcurrentbackground</strong><em>&lt;number&gt;</em></dt>
<dd>동시 표시로 뮤테이터 스레드를 지원하기 위해 첨부된
낮은 우선순위 배경 스레드의 수를 지정합니다. 기본값은 1입니다.
</dd>
<dt class="bold"><strong>-Xconcurrentlevel</strong><em>&lt;number&gt;</em></dt>
<dd> 할당 "부담" 비율을 지정합니다. 할당된 힙 용량과
표시된 힙 용량 간의 비율을 표시합니다. 기본값은
8입니다.
</dd>
<dt class="bold"><span class="synph"><span class="kwd">-Xconmeter</span><span class="sep">:</span><span class="var">&lt;</span><span class="var">soa</span><span class="delim">|</span><span class="var">loa</span><span class="delim">|</span><span class="var">dynamic</span><span class="var">&gt;</span></span></dt>
<dd>LOA(Large Object Area) 또는 SOA(Small Object
Area) 중 어느 영역 사용법이 사용되었는지 판별하여 이에 따라 동시 표시 중 할당이
부담됩니다. 선택된 영역에 할당 부담이 적용됩니다. <strong>-Xconmeter:dynamic</strong>이 지정된 경우,
콜렉터는 어느 영역이 먼저 소모되었는지에 따라 측정할 영역을 동적으로 판별합니다.  기본적으로 이 옵션은 <strong>-Xconmeter:soa</strong>로 설정되어 있습니다.
</dd>
<dt class="bold"><a id="xoptions__xdbg" name="xoptions__xdbg"></a><strong>-Xdbg</strong>:<em>&lt;options&gt;</em></dt>
<dd>응용프로그램의 원격 디버깅을 지원하기 위해 디버깅 라이브러리를 로드합니다.

자세한 정보는 <a href="#debugger">Java 응용프로그램 디버깅</a>을 참조하십시오. <a href="#xoptions__runjdwp"><strong>-Xrunjdwp</strong></a>를 지정하면 동일한 지원이 제공됩니다.
</dd>
<dt class="bold"><strong>-Xdebug</strong></dt>
<dd>디버거를 사용 가능하게 하여 JVM을 시작합니다. 기본적으로 디버거는
사용할 수 없습니다.
</dd>
<dt class="bold"><strong>-Xdisableexcessivegc</strong></dt>
<dd>GC에 과도한 시간이 소비되는 경우 OutOfMemoryError가 발생하지 않도록 합니다. 이 옵션의 기본값은 off입니다.
</dd>
<dt class="bold"><strong>-Xdisableexplicitgc</strong></dt>
<dd>System.gc()에 대한 호출이 작동되지 않음을
VM에 신호합니다. 기본적으로 System.gc()에 대한 호출은 가비지 콜렉션을 트리거합니다.
</dd>
<dt class="bold"><strong>-Xdisablestringconstantgc</strong></dt>
<dd>문자열 인턴 테이블의 문자열이 수집되지 않도록 합니다. 이 옵션은 기본적으로 사용되지 않습니다.
</dd>
<dt class="bold"><strong>-Xdisablejavadump</strong></dt>
<dd>오류 및 신호에 대한 Javadump 생성을 끕니다. 기본적으로 Javadump 생성이 사용됩니다.
</dd>
<dt class="bold"><strong>-Xenableexcessivegc</strong></dt>
<dd>GC에 과도한 시간이 소비되는 경우 이 옵션은 할당 요청에 대해 NULL을 리턴하여 OutOfMemoryError가
발생하도록 합니다. 이 조치는 힙이 완전히 확장되고 GC가 사용 가능한 시간의 95%를 소비했을 때만 발생합니다. 기본값은 이 조치를 수행하는 것입니다.
</dd>
<dt class="bold"><strong>-Xenableexplicitgc</strong></dt>
<dd>VM에 System.gc()에 대한 호출이 가비지 콜렉션을 트리거해야 한다는
신호를 보냅니다. 기본값입니다.
</dd>
<dt class="bold"><strong>-Xenablestringconstantgc</strong></dt>
<dd>문자열 인턴 테이블의 문자열이 수집되도록 합니다. 이 옵션은 기본적으로
사용됩니다.
</dd>
<dt class="bold"><strong>-Xfuture</strong></dt>
<dd>엄격한 클래스 파일 포맷 점검을 사용합니다. 후속 릴리스에서는
더 엄격한 점검이 기본값이 되므로 새 코드를 개발 중인 경우 이 플래그를 사용하십시오.
기본적으로 엄격한 포맷 점검은 사용 불가능합니다.
</dd>
<dt class="bold"><span class="synph"><span class="kwd">-Xgcpolicy</span><span class="sep">:</span><span class="var">&lt;</span><span class="var">optthruput</span><span class="delim">|</span><span class="var">optavgpause</span><span class="delim">|</span><span class="var">gencon</span><span class="delim">|</span><span class="var">subpool</span><span class="var">&gt;</span></span>(PPC 및 zSeries의 하위 풀)</dt>
<dd>가비지 콜렉터의 작동을 제어합니다. 자세한 정보는
<a href="#garbage_options">가비지 콜렉션 옵션</a>을 참조하십시오.
</dd>
<dt class="bold"><strong>-Xgcthreads</strong><em>&lt;number of threads&gt;</em></dt>
<dd> 가비지 콜렉션 중의 병렬 조작에 사용되는 헬퍼 스레드의 수를
설정합니다. 기본적으로 스레드 수는 현재의 실제 CPU 수에서
1을 뺀 수로 설정합니다(최소값은 1).
</dd>
<dt class="bold"><strong>-Xgcworkpackets</strong><em>&lt;number&gt;</em></dt>
<dd> 글로벌 콜렉터에서 사용 가능한 총 작업 패킷 수를 지정합니다.
이 옵션을 지정하지 않으면 콜렉터는 최대 힙 크기에 따라
패킷 수를 할당합니다.
</dd>
<dt class="bold"><strong>-Xint</strong></dt>
<dd>JVM에서 해석기만 사용하고 JIT(just-in-time) 컴파일러는 사용하지 않도록 합니다. 기본적으로 JIT 컴파일러는 사용 가능합니다.
</dd>
<dt class="bold"><strong>-Xiss</strong><em>&lt;size&gt;</em></dt>
<dd>초기 Java
스레드 스택 크기를 설정합니다. 기본값은 2KB입니다.
VM이 사용 중인 값을 출력하려면 <a href="#standard_options__verbose"><strong>-verbose:sizes</strong></a> 옵션을
사용하십시오.
</dd>
<dt class="bold"><font color="RED"><span id="changed">|</span><strong>-Xjarversion</strong></font></dt>
<dd><font color="RED"><span id="changed">|</span><a href="#build_number">버전 정보 얻기</a>를 참조하십시오.</font>
</dd>
<dt class="bold"><a id="xoptions__xjit" name="xoptions__xjit"></a><span class="synph"><span class="kwd">-Xjit</span><span class="sep">[</span><span class="delim">:</span><span class="var">&lt;suboption&gt;</span><span class="delim">,</span><span class="var">&lt;suboption&gt;</span><span class="sep">...</span><span class="sep">]</span></span></dt>
<dd>JIT를 사용 가능하게 합니다. 하위 옵션에 대한 자세한 내용은 <a href="http://www.ibm.com/developerworks/java/jdk/diagnosis/60.html" target="_blank">진단 안내서</a>를 참조하십시오. <a href="#xoptions__xnojit"><strong>-Xnojit</strong></a>도 참조하십시오.
기본적으로 JIT는 사용 가능합니다.
</dd>
<dt class="bold"><a id="xoptions__xlinenumbers" name="xoptions__xlinenumbers"></a><strong>-Xlinenumbers</strong></dt>
<dd>디버깅을 위해 스택 추적에 행 번호를 표시합니다. <a href="#xoptions__xnolinenumbers"><strong>-Xnolinenumbers</strong></a>도 참조하십시오. 기본적으로 행 번호를 표시합니다.
</dd>
<dt class="bold"><a id="xoptions__loa" name="xoptions__loa"></a><strong>-Xloa</strong></dt>
<dd>LOA(Large Object Area)를 할당합니다. 오브젝트는 SOA가 아닌 이 LOA에서 할당됩니다. 기본적으로 LOA는 LOA를 사용할 수 없는 하위 풀을 제외한 모든 GC 정책에 사용할 수 있습니다. <a href="#xoptions__noloa"><strong>-Xnoloa</strong></a>도 참조하십시오.
</dd>
<dt class="bold"><strong>-Xloainitial</strong><em>&lt;percentage&gt;</em></dt>
<dd><em>&lt;percentage&gt;</em>의 범위는 0 - 0.95이며,
LOA(Large Object Area)에 할당된 현재 보유 공간의 초기 백분율을 지정합니다. 기본값은 0.05 또는 5%입니다.
</dd>
<dt class="bold"><strong>-Xloamaximum</strong><em>&lt;percentage&gt;</em></dt>
<dd><em>&lt;percentage&gt;</em>의 범위는 0 - 0.95이며,
LOA(Large Object Area)에 할당된 현재 보유 공간의 최대 백분율을 지정합니다. 기본값은 0.5 또는 50%입니다.
</dd>
<dt class="bold"><a id="xoptions__xlp" name="xoptions__xlp"></a><strong>-Xlp</strong></dt>
<dd>대형 페이지로 Java 힙을 할당하도록
JVM에 요청합니다. 대형 페이지를 사용할 수 없는 경우 JVM이 시작되지 않으며, 오류 페이지 <tt class="xph">GC:
system configuration does not support option --&gt; '-Xlp'</tt>가 표시됩니다. JVM은 shmget()을 사용하여 힙을 대형 페이지로
할당합니다. 대형 페이지는 Linux 커널 v2.6 이상
또는 분배에 의해 대형 페이지 지원이 백포트된 이전 커널을 실행하는 시스템에서 지원됩니다. 기본적으로
대형 페이지를 사용하지 않습니다. <a href="#alloc_large_page">대형 페이지 메모리 할당 구성</a>을 참조하십시오.
</dd>
<dt class="bold"><strong>-Xmaxe</strong><em>&lt;size&gt;</em></dt>
<dd>가비지 콜렉터가 힙을 확장하는 최대 용량을 설정합니다.
일반적으로 가비지 콜렉터는 여유 공간의 용량이 30%(또는
<strong>-Xminf</strong>를 사용하여 지정한 용량) 아래로 떨어졌을 때,
여유 공간을 30%로 복원하는 데 필요한 용량만큼 힙을 확장합니다. <strong>-Xmaxe</strong> 옵션은 지정된 값의 확장을 제한합니다.
예를 들어, <tt class="xph">-Xmaxe10M</tt>은 확장을 10MB로 제한합니다. 기본적으로
최대 확장 크기는 없습니다.
</dd>
<dt class="bold"><strong>-Xmaxf</strong><em>&lt;percentage&gt;</em></dt>
<dd>가비지 콜렉션 후에 여유 공간으로 남아야 하는 힙의 최대 백분율을
지정합니다. 여유 공간이 이 용량을 초과하면 JVM은 힙을
줄입니다. 기본값은 0.6(60%)입니다.
</dd>
<dt class="bold"><strong>-Xmca</strong><em>&lt;size&gt;</em></dt>
<dd>로드된 클래스의 RAM 부분을 저장하는 데 할당된 메모리의
확장 단계를 설정합니다. RAM에 있는 클래스를 저장하는 데 더 많은 메모리가
필요할 때마다, 할당된 메모리는 이 용량까지 늘어납니다. 기본적으로 확장 단계는
32KB입니다. VM이 사용 중인 값을 출력하려면 <a href="#standard_options__verbose"><strong>-verbose:sizes</strong></a> 옵션을
사용하십시오.
</dd>
<dt class="bold"><strong>-Xmco</strong><em>&lt;size&gt;</em></dt>
<dd>로드된 클래스의 ROM 부분을 저장하는 데 할당된 메모리의
확장 단계를 설정합니다. ROM에 있는 클래스를 저장하는 데 더 많은
메모리가 필요할 때마다, 할당된 메모리는 이 용량까지
늘어납니다. 기본적으로 확장 단계는 128KB입니다. VM이 사용 중인 값을 출력하려면 <a href="#standard_options__verbose"><strong>-verbose:sizes</strong></a> 옵션을
사용하십시오.
</dd>
<dt class="bold"><strong>-Xmine</strong><em>&lt;size&gt;</em></dt>
<dd>가비지 콜렉터가 힙을 확장하는 최소 용량을 설정합니다.
일반적으로 가비지 콜렉터는 여유 공간을 30%(또는 <strong>-Xminf</strong>를 사용하여 지정한 용량)로 복원하는 데 필요한 용량만큼
힙을 확장합니다. <strong>-Xmine</strong> 옵션은 확장을 지정된 값 이상으로 설정합니다.
예를 들어, <tt class="xph">-Xmine50M</tt>는 확장 크기를 최소 50MB로 설정합니다. 기본적으로 최소 확장 크기는
1MB입니다.
</dd>
<dt class="bold"><strong>-Xminf</strong><em>&lt;percentage&gt;</em></dt>
<dd>가비지 콜렉션 후에 여유 공간으로 남아야 하는
힙의 최소 백분율을 지정합니다. 여유 공간이 이 용량 미만으로 떨어지면
JVM은 힙을 늘립니다. 기본적으로 최소값은 0.3(30%)입니다.
</dd>
<dt class="bold"><strong>-Xmn</strong><em>&lt;size&gt;</em></dt>
<dd><strong>-Xgcpolicy:gencon</strong>을 사용할 때 새(nursery) 힙의 초기 크기 및 최대 크기를 지정한 값으로 설정합니다. <strong>-Xmn</strong> 설정은
<strong>-Xmns</strong> 및 <strong>-Xmnx</strong> 설정과 동일합니다.
 <span><strong>-Xmns</strong> 또는
<strong>-Xmnx</strong>를 설정한 경우에는 <strong>-Xmn</strong>을 설정할 수 없습니다. 
<strong>-Xmns</strong> 또는 <strong>-Xmnx</strong>와 함께 <strong>-Xmn</strong>를 설정하면
VM이 시작되지 않으며 오류를 리턴합니다.</span> 기본적으로 시스템 성능에 따라 <strong>-Xmn</strong>이
내부적으로 선택됩니다. VM이 사용 중인 값을 출력하려면 <a href="#standard_options__verbose"><strong>-verbose:sizes</strong></a> 옵션을
사용하십시오.
</dd>
<dt class="bold"><strong>-Xmns</strong><em>&lt;size&gt;</em></dt>
<dd><strong>-Xgcpolicy:gencon</strong>을 사용할 때 새(nursery) 힙의 초기 크기를 지정한 값으로 설정합니다. 기본적으로 이 옵션은 시스템 성능에 따라 내부적으로
선택됩니다. <span><strong>-Xmn</strong>과 함께 사용하면 이 옵션은 오류를 리턴합니다. </span> VM이 사용 중인 값을 출력하려면 <a href="#standard_options__verbose"><strong>-verbose:sizes</strong></a> 옵션을
사용하십시오.
</dd>
<dt class="bold"><strong>-Xmnx</strong><em>&lt;size&gt;</em></dt>
<dd><strong>-Xgcpolicy:gencon</strong>을 사용할 때 새(nursery) 힙의 최대 크기를 지정한 값으로 설정합니다. 기본적으로 이 옵션은 시스템 성능에 따라 내부적으로
선택됩니다. <span><strong>-Xmn</strong>과 함께 사용하면 이 옵션은 오류를 리턴합니다. </span> VM이 사용 중인 값을 출력하려면 <a href="#standard_options__verbose"><strong>-verbose:sizes</strong></a> 옵션을
사용하십시오.
</dd>
<dt class="bold"><a id="xoptions__xmo" name="xoptions__xmo"></a><strong>-Xmo</strong><em>&lt;size&gt;</em></dt>
<dd><strong>-Xgcpolicy:gencon</strong>을 사용할 때 이전(tenure) 힙의 초기 크기 및 최대 크기를 지정한 값으로 설정합니다. <strong>-Xmos</strong> 및 <strong>-Xmox</strong> 설정과 동일합니다. <span><strong>-Xmos</strong>
또는 <strong>-Xmox</strong>를 설정한 경우에는 <strong>-Xmo</strong>를 설정할 수 없습니다. 
<strong>-Xmos</strong> 또는 <strong>-Xmox</strong>와 함께
<strong>-Xmo</strong>를 설정하면 VM이 시작되지 않으며 오류를
리턴합니다.</span> 기본적으로 <strong>-Xmo</strong>는 시스템 성능에 따라
내부적으로 선택됩니다. VM이 사용 중인 값을 출력하려면 <a href="#standard_options__verbose"><strong>-verbose:sizes</strong></a> 옵션을
사용하십시오.
</dd>
<dt class="bold"><strong>-Xmoi</strong><em>&lt;size&gt;</em></dt>
<dd><strong>-Xgcpolicy:gencon</strong>을 사용하는 경우 Java
힙의 증분량을 설정합니다.
0으로 설정하면 확장이 허용되지
않습니다. 기본적으로 증분 크기는 확장 크기,
<strong>-Xmine</strong> 및 <strong>-Xminf</strong>에 따라 계산됩니다.
</dd>
<dt class="bold"><strong>-Xmos</strong><em>&lt;size&gt;</em></dt>
<dd><strong>-Xgcpolicy:gencon</strong>을 사용할 때 이전(tenure) 힙의 초기 크기를 지정한 값으로 설정합니다. 기본적으로 이 옵션은 시스템 성능에 따라 내부적으로
선택됩니다. <span><strong>-Xmo</strong>와 함께 사용하면 이 옵션은 오류를 리턴합니다. </span> VM이 사용 중인 값을 출력하려면 <a href="#standard_options__verbose"><strong>-verbose:sizes</strong></a> 옵션을
사용하십시오.
</dd>
<dt class="bold"><strong>-Xmox</strong><em>&lt;size&gt;</em></dt>
<dd><strong>-Xgcpolicy:gencon</strong>을 사용할 때 이전(tenure) 힙의 최대 크기를 지정한 값으로 설정합니다. 기본적으로 이 옵션은 시스템 성능에 따라 내부적으로
선택됩니다. <span><strong>-Xmo</strong>와 함께 사용하면 이 옵션은 오류를 리턴합니다. </span> VM이 사용 중인 값을 출력하려면 <a href="#standard_options__verbose"><strong>-verbose:sizes</strong></a> 옵션을
사용하십시오.
</dd>
<dt class="bold"><strong>-Xmr</strong><em>&lt;size&gt;</em></dt>
<dd><strong>-Xgcpolicy:gencon</strong>을 사용하여 가비지 콜렉션 "기억된 세트"의 크기를 설정합니다. 이것은
새(nursery) 힙에 있는 오브젝트에 대한 참조를 갖는 이전(tenure) 힙의
오브젝트 목록입니다. 기본값은 16KB입니다. VM이 사용 중인 값을 출력하려면 <a href="#standard_options__verbose"><strong>-verbose:sizes</strong></a> 옵션을
사용하십시오.
</dd>
<dt class="bold"><strong>-Xmrx</strong><em>&lt;size&gt;</em></dt>
<dd>기억되는 최대 크기를 설정합니다.
</dd>
<dt class="bold"><a id="xoptions__xms" name="xoptions__xms"></a><strong>-Xms</strong><em>&lt;size&gt;</em></dt>
<dd>초기 Java 힙 크기를 설정합니다.  <a href="#xoptions__xmo"><strong>-Xmo</strong></a>를 사용할 수도 있습니다. 기본값은 시스템 성능에 따라 내부적으로 설정됩니다.  VM이 사용 중인 값을 출력하려면 <a href="#standard_options__verbose"><strong>-verbose:sizes</strong></a> 옵션을
사용하십시오.
</dd>
<dt class="bold"><strong>-Xmso</strong><em>&lt;size&gt;</em></dt>
<dd>포크된 Java
스레드의 C 스택 크기를 설정합니다. 기본적으로 이 옵션은 32-bit 플랫폼에서는 32KB,
64-bit 플랫폼에서는 256KB로 설정됩니다. VM이 사용 중인 값을 출력하려면 <a href="#standard_options__verbose"><strong>-verbose:sizes</strong></a> 옵션을
사용하십시오.
</dd>
<dt class="bold"><strong>-Xmx</strong><em>&lt;size&gt;</em></dt>
<dd>Java 힙의
최대 크기를 설정합니다. 기본적으로
이 옵션은 시스템 성능에 따라 내부적으로 설정됩니다.  VM이 사용 중인 값을 출력하려면 <a href="#standard_options__verbose"><strong>-verbose:sizes</strong></a> 옵션을
사용하십시오.
</dd>
<dt class="bold"><a id="xoptions__noclassgc" name="xoptions__noclassgc"></a><strong>-Xnoclassgc</strong></dt>
<dd>클래스 가비지 콜렉션을 사용 불가능하게 합니다. 이 옵션은
JVM에서 더 이상 사용되지 않는 Java 클래스와
연관된 저장영역의 가비지 콜렉션이 사용되지 않도록 합니다. <a href="#xoptions__classgc"><strong>-Xclassgc</strong></a>도 참조하십시오.
기본적으로 클래스 가비지 콜렉션이 수행됩니다.
</dd>
<dt class="bold"><a id="xoptions__nocompactexplicitgc" name="xoptions__nocompactexplicitgc"></a><strong>-Xnocompactexplicitgc</strong></dt>
<dd><tt class="xph">System.gc()</tt>에 대한 호출의 압축을 사용 불가능하게 합니다. <a href="#xoptions__compactexplicitgc"><strong>-Xcompactexplicitgc</strong></a>도 참조하십시오. 기본적으로
<tt class="xph">System.gc()</tt>에 대한 압축은 사용 가능합니다.
</dd>
<dt class="bold"><a id="xoptions__nocompactgc" name="xoptions__nocompactgc"></a><strong>-Xnocompactgc</strong></dt>
<dd>가비지 콜렉션 압축을 사용 불가능하게 합니다. <a href="#xoptions__compactgc"><strong>-Xcompactgc</strong></a>도 참조하십시오. 기본적으로 압축은 사용 가능합니다.
</dd>
<dt class="bold"><a id="xoptions__xnojit" name="xoptions__xnojit"></a><strong>-Xnojit</strong></dt>
<dd>JIT 컴파일러를 사용 불가능하게 합니다. <a href="#xoptions__xjit"><strong>-Xjit</strong></a>도 참조하십시오. 기본적으로 JIT 컴파일러는 사용 가능합니다.
</dd>
<dt class="bold"><a id="xoptions__xnolinenumbers" name="xoptions__xnolinenumbers"></a><strong>-Xnolinenumbers</strong></dt>
<dd>디버깅을 위한 행 번호를 사용 불가능하게 합니다. <a href="#xoptions__xlinenumbers"><strong>-Xlinenumbers</strong></a>도 참조하십시오. 기본적으로 행 번호를 표시합니다.
</dd>
<dt class="bold"><a id="xoptions__noloa" name="xoptions__noloa"></a><strong>-Xnoloa</strong></dt>
<dd>LOA(Large Object Area)가 할당되지 않도록 합니다. 모든 오브젝트는 SOA에 할당됩니다. 기본적으로 LOA는 LOA를 사용할 수 없는 하위 풀을 제외한 모든 GC 정책에 사용할 수 있습니다. <a href="#xoptions__loa"><strong>-Xloa</strong></a>도 참조하십시오.
</dd>
<dt class="bold"><a id="xoptions__nopartialcompactgc" name="xoptions__nopartialcompactgc"></a><strong>-Xnopartialcompactgc</strong></dt>
<dd>증분 압축을 사용 불가능하게 합니다. <a href="#xoptions__partialcompactgc"><strong>-Xpartialcompactgc</strong></a>도 참조하십시오.
</dd>
<dt class="bold"><a id="xoptions__nosigcatch" name="xoptions__nosigcatch"></a><strong>-Xnosigcatch</strong></dt>
<dd>JVM 신호 처리 코드를 사용 불가능하게 합니다. <a href="#xoptions__sigcatch"><strong>-Xsigcatch</strong></a>도 참조하십시오. 기본적으로 신호 처리는 사용 가능합니다.
</dd>
<dt class="bold"><a id="xoptions__nosigchain" name="xoptions__nosigchain"></a><strong>-Xnosigchain</strong></dt>
<dd>신호 핸들러 체인을 사용 불가능하게 합니다. <a href="#xoptions__sigchain"><strong>-Xsigchain</strong></a>도 참조하십시오. 기본적으로 신호 핸들러 체인은 사용 가능합니다.
</dd>
<dt class="bold"><strong>-Xoptionsfile</strong>=<em>&lt;file&gt;</em></dt>
<dd>JVM 옵션이 포함된 파일을 지정하고 정의합니다. 기본적으로 옵션 파일을
사용하지 않습니다.
</dd>
<dt class="bold"><strong>-Xoss</strong><em>&lt;size&gt;</em></dt>
<dd>임의의 스레드에 대한 Java 스택 크기와
C 스택 크기를 설정합니다. 이 옵션을 호환성을 위해 제공되며
<strong>-Xss</strong> 및 <strong>-Xmso</strong>를 모두 지정된 값으로 설정하는 것과
동일합니다.
</dd>
<dt class="bold"><a id="xoptions__partialcompactgc" name="xoptions__partialcompactgc"></a><strong>-Xpartialcompactgc</strong></dt>
<dd>부분 압축을 사용 가능하게 합니다. 기본적으로 이 옵션이 설정되지 않으므로
모든 압축은 전체 압축입니다. <a href="#xoptions__nopartialcompactgc"><strong>-Xnopartialcompactgc</strong></a>도 참조하십시오.
</dd>
<dt class="bold"><strong>-Xquickstart</strong></dt>
<dd>JIT 컴파일 및 최적화를 지연하여 시작 시간을 개선합니다. 기본적으로 빠른 시작은 사용 불가능하며 JIT 컴파일은 지연되지 않습니다.
</dd>
<dt class="bold"><strong>-Xrdbginfo</strong>:<em>&lt;host&gt;</em>:<em>&lt;port&gt;</em></dt>
<dd>옵션을 원격 디버그 정보 서버로 로드하고 전달합니다. 기본적으로
원격 디버그 정보 서버는 사용 불가능합니다.
</dd>
<dt class="bold"><strong>-Xrs</strong></dt>
<dd>운영 체제 신호의 사용을 줄입니다. 기본적으로 VM은
운영 체제 신호를 전부 사용합니다. <a href="#sighand">JVM에서 사용되는 신호</a>의 내용을 참조하십시오.
</dd>
<dt class="bold"><strong>-Xrun</strong><em>&lt;library name&gt;</em>[:<em>&lt;options&gt;</em>]</dt>
<dd>도움말 라이브러리를 로드합니다. 여러 개의 라이브러리를 로드하려면 명령행에서 두 번 이상
지정하십시오. 이러한 라이브러리의 예로 다음이 있습니다.


<dl class="parml">
<dt class="bold"><strong>-Xrunhprof</strong>[:help] | [:<em>&lt;option&gt;</em>=<em>&lt;value&gt;</em>,
...]</dt>
<dd>힙, CPU 또는 모니터 프로파일을 수행합니다. 자세한 정보는 <a href="http://www.ibm.com/developerworks/java/jdk/diagnosis/60.html" target="_blank"> 진단 안내서</a>를 참조하십시오.
</dd>
<dt class="bold"><a id="xoptions__runjdwp" name="xoptions__runjdwp"></a><strong>-Xrunjdwp</strong>[:help] | [:&lt;<em>option</em>&gt;=&lt; <em>value</em>&gt;,
...]</dt>
<dd>응용프로그램의 원격 디버깅을 지원하기 위해 디버깅 라이브러리를 로드합니다.
자세한 정보는
<a href="#xoptions__xdbg"><strong>-Xdbg</strong></a>를 참조하십시오.
</dd>
<dt class="bold"><a name="xoptions__xrunjnichk"></a><strong id="xoptions__xrunjnichk">-Xrunjnichk</strong>[:help] | [:&lt;<em>option</em>&gt;=&lt;<em>value</em>&gt;,
...]</dt>
<dd>이제 사용되지 않습니다. <strong>-Xcheck:jni</strong>를 사용하십시오.
</dd>
</dl>
</dd>
<dt class="bold"><strong>-Xscmx</strong><em>&lt;size&gt;</em></dt>
<dd><strong>-Xscmx</strong>에 대한 자세한 정보는 <a href="#sharedclassesxoptions">클래스 데이터 공유 사용 및 구성</a>의 내용을 참조하십시오.
</dd>
<dt class="bold"><strong>-Xshareclasses</strong>:<em>&lt;options&gt;</em></dt>
<dd><strong>-Xshareclasses</strong> 옵션에 대한 세부사항은
<a href="#sharedclassesxoptions">클래스 데이터 공유 사용 및 구성</a>을 참조하십시오.
</dd>
<dt class="bold"><a id="xoptions__sigcatch" name="xoptions__sigcatch"></a><strong>-Xsigcatch</strong></dt>
<dd>VM 신호 처리 코드를 사용 가능하게 합니다. <a href="#xoptions__nosigcatch"><strong>-Xnosigcatch</strong></a>도 참조하십시오. 기본적으로 신호 처리는 사용 가능합니다.
</dd>
<dt class="bold"><a id="xoptions__sigchain" name="xoptions__sigchain"></a><strong>-Xsigchain</strong></dt>
<dd> 신호 핸들러 체인을 사용 가능하게 합니다. <a href="#xoptions__nosigchain"><strong>-Xnosigchain</strong></a>도 참조하십시오. 기본적으로
신호 핸들러 체인이 사용됩니다.
</dd>
<dt class="bold"><strong>-Xsoftrefthreshold</strong><em>&lt;number&gt;</em></dt>
<dd>참조가 표시되지 않은 경우 지정된 수 다음의 소프트 참조가 지워지는 GC 수를 설정합니다. 기본값은 3입니다. 이는 참조가 표시되지 않은
세 번째 GC부터 소프트 참조가 지워진다는 것을 의미입니다.
</dd>
<dt class="bold"><strong>-Xss</strong><em>&lt;size&gt;</em></dt>
<dd>임의의 스레드에 대한 Java 스택의
최대 크기를 설정합니다. 기본적으로 이 옵션은 256KB로
설정됩니다.  VM이 사용 중인 값을 출력하려면 <a href="#standard_options__verbose"><strong>-verbose:sizes</strong></a> 옵션을
사용하십시오.
</dd>
<dt class="bold"><strong>-Xthr</strong>:<em>&lt;options&gt;</em></dt>
<dd>스레딩 옵션을 설정합니다.
</dd>
<dt class="bold"><a id="xoptions__xverbosegclog" name="xoptions__xverbosegclog"></a><strong>-Xverbosegclog</strong>:<em>&lt;path to file&gt;</em>[<em>X</em>,<em>Y</em>]</dt>
<dd>
<p>상세 가비지 콜렉션(GC) 결과물이 지정된 파일에 작성됩니다. 이미 파일이 있는 경우 해당 파일에 겹쳐씁니다. 기존 파일을 열 수 없거나 새 파일을 작성할 수 없는 경우, 결과물을 stderr로 방향 재지정합니다. 인수 X 및 Y(모두 정수)를
지정하는 경우 상세 GC 결과물은 파일의 X 수로 방향이 재지정되며, 각각에는 상세 GC 결과물의 GC 사이클 만큼의 Y 수가 들어 있습니다. 이들 파일은 <em>filename1,
filename2</em> 등의 형식이 있습니다.
기본적으로 상세 GC 로깅은 발생하지 않습니다.</p>

<p>상세 GC 결과물에 대한 자세한 정보는
<a href="http://www.ibm.com/developerworks/java/jdk/diagnosis/60.html" target="_blank">진단 안내서</a>를 참조하십시오.</p>
</dd>
<dt class="bold"><strong>-Xverify</strong></dt>
<dd>로드된 모든 클래스에 대해 엄격한 점검을 수행하도록 합니다. 기본적으로
엄격한 클래스 점검을 수행하지 않습니다.
</dd>
<dt class="bold"><strong>-Xverify:none</strong></dt>
<dd>엄격한 클래스 점검을 사용 불가능하게 합니다. 기본적으로
엄격한 클래스 점검을 수행하지 않습니다.
</dd>
</dl>
<a name="limitations"></a>
<h1 id="limitations"><a href="#ToC_135">부록B. 알려진 제한사항</a></h1>
<div>
<p>SDK 및 Runtime Environment for Linux에 대해 알려진 제한사항입니다.</p></div>
<p>
<p><a href="http://www.ibm.com/developerworks/java/jdk/diagnosis/60.html" target="_blank">http://www.ibm.com/developerworks/java/jdk/diagnosis/60.html</a>의 <cite>진단 안내서</cite>에서는
문제점 진단에 대한 추가 도움말을 찾을 수 있습니다.</p></p>
<p>
<a name="wq153"></a>
<h2 id="wq153">AMD64 SMP 시스템에 대한
BIOS 설정</h2>
<p><strong>노드 메모리 상호 배치</strong> BIOS 설정은
<tt class="xph">사용 불가능</tt>으로 설정해야 합니다. 그렇지 않으면
Java 충돌 및 정지 등
예상하지 못한 결과가 발생할 수 있습니다. 이 지시사항은
AMD의 권장사항을 준수합니다.</p></p>
<p>
<a name="wq154"></a>
<h2 id="wq154">JConsole 모니터링 도구
로컬 탭</h2>
<p>IBM의
JConsole 도구에서, 동일한 시스템의 다른 가상 시스템에 연결할 수 있는 <strong>로컬</strong> 탭을 사용할 수 없습니다.
또한 해당 명령행 <strong>pid</strong> 옵션이 지원되지 않습니다. 대신 JConsole의 <strong>Remote</strong> 탭을
사용하면 모니터링하려는 가상 시스템에 연결할 수 있습니다. 대신 <strong>connection</strong> 명령행 옵션을 사용하여
<tt class="xph">localhost</tt>의 호스트 및 포트 번호를 지정하십시오. 모니터링할 응용프로그램을 실행할 때 다음 명령행 옵션을 설정하십시오.
</p>
<dl class="parml">
<dt class="bold"><strong>-Dcom.sun.management.jmxremote.port</strong>=<em>&lt;value&gt;</em></dt>
<dd>관리 에이전트가 청취해야 하는 포트를 지정합니다.
</dd>
<dt class="bold"><strong>-Dcom.sun.management.jmxremote.authenticate=false</strong></dt>
<dd>사용자 이름 파일을 작성하지 않은 경우 인증을 사용하지 않습니다.
</dd>
<dt class="bold"><strong>-Dcom.sun.management.jmxremote.ssl=false</strong></dt>
<dd>SSL 암호화를 사용하지 않습니다.
</dd>
</dl></p>
<p>
<a name="wq155"></a>
<h2 id="wq155">Rhino Javascript 엔진을 사용할 수 없음</h2>
<p>Mozilla Rhino Javascript 엔진은 라이센스 부여 문제로 인해 IBM SDK for Java에
포함되지 않습니다. IBM SDK for Java에서
Rhino Javascript 엔진을 사용하려면 <a href="https://scripting.dev.java.net/" target="_blank">https://scripting.dev.java.net/</a>에서 jsr223 스크립팅 엔진을, Mozilla 웹 사이트(<a href="http://www.mozilla.org/rhino/" target="_blank">http://www.mozilla.org/rhino/</a>)에서
Rhino Javascript 엔진을 다운로드하십시오.</p></p>
<p>
<a name="wq156"></a>
<h2 id="wq156">느린 DSA 키 쌍 생성</h2>
<p>보통이 아닌 길이의 DSA 키 쌍을 작성하면 느린 시스템에서
상당한 시간이 걸릴 수 있습니다. 충분한 시간이 있으면 프로세스가 완료되므로 이러한 지연을 정지로 해석하지 마십시오. DSA 키 생성 알고리즘은
다른 알고리즘보다 빠른 표준 키 길이(예: 512, 1024)를 생성하도록 최적화되었습니다.</p></p>
<p>
<a name="wq157"></a>
<h2 id="wq157">JNI를 사용하여 JVM 작성</h2>
<p>원시
프로그램은 JNI_VERSION_1_1(0x00010001) 인터페이스로 VM을 작성할 수 없습니다. JNI_CreateJavaVM()을 호출하여
JNI_VERSION_1_1(0x00010001)의 버전을 전달할 수 없습니다. 전달할 수 있는 버전은 다음과 같습니다.</p></p>
<ul>
<li>JNI_VERSION_1_2(0x00010002)</li>
<li>JNI_VERSION_1_4(0x00010004)</li></ul>
<p>작성한 VM은 전달된 JNI 인터페이스 버전이 의미하는 라이브러리가 아니라 존재하는
Java 라이브러리(즉 1.2.2,
1.3.x, 1.4.x, 5.x, 6.x)로 판별합니다.</p>
<p>인터페이스 버전은 원시 코드에 사용 가능한 기능을 제외한 기타 VM
작동 영역에는 영향을 주지 않습니다.</p>
<p>
<a name="wq158"></a>
<h2 id="wq158">창 관리자 및 키보드 바로 가기</h2>
<p>창 관리자는 일부
Java 키보드 바로 가기를
대체할 수 있습니다. 대체된 Java
키보드 바로 가기를 사용해야 하는 경우, 운영 체제 매뉴얼을 참조하여 창 관리자 키보드 바로 가기를 변경하십시오.</p></p>
<p>
<a name="wq159"></a>
<h2 id="wq159">X 윈도우 시스템 파일 설명자</h2>
<p>X 윈도우 시스템에서는 255개를 초과하는 파일 설명자를 사용할 수 없습니다. 이는 JVM에서 열린 jar 파일의 파일 설명자 보유로 인해
X Windows 시스템에서 파일 설명자를 모두 사용하기 때문입니다. 이에 대한 해결 방법으로, JVM에서 jar 파일에서 더 많은 파일 설명자를
사용하도록 <strong>JAVA_HIGH_ZIPFDS</strong> 환경 변수를 설정할 수 있습니다.</p>
<p><strong>JAVA_HIGH_ZIPFDS</strong> 환경 변수를 사용하려면 값을 0에서 512 사이로 설정하십시오. JVM은
파일 설명자를 최대 1024개까지 사용하여 첫번째 jar 파일을 열게 됩니다. 예를 들어
사용자의 프로그램이 jar 파일을 300개 로드하려는 경우에는 다음을 입력하십시오.</p>
<p><tt class="xph">export JAVA_HIGH_ZIPFDS=300</tt></p>
<p>첫 번째 300 jar 파일은 724개에서 1023개 사이의 파일 설명자를 사용하여 로드됩니다.
이후에 열린 jar 파일은 모두 정상 범위에서 열립니다.</p></p>
<p>
<a name="wq160"></a>
<h2 id="wq160">DBCS 및 KDE 클립보드</h2>
<p>KDE(K Desktop Environment)를
실행 중인 경우, 2바이트 문자 세트(DBCS)의 시스템 클립보드를 사용하여
Linux 응용프로그램과
Java 응용프로그램 사이에
정보를 복사할 수 없을 수도 있습니다.</p></p>
<p>
<a name="wq161"></a>
<h2 id="wq161">LinuxThreads 라이브러리를 사용하는 경우
스레드 한계</h2>
<p>SLES9 및 최신 분배에서
기본 스레딩 라이브러리는 Java 스레드를
원시 스레드로 구현하는 NPTL입니다. 이전 배포판에서는
기본 스레딩 라이브러리가 LinuxThreads이며 새로운 프로세스로 스레드를
구현합니다. Java 스레드의 수가
허용되는 최대 프로세스 수를 초과하는 경우 프로그램이 정지할 수 있습니다.</p>
<p> 사용 가능한 스레드의 최대 수는
다음의 최소값에 의해 결정됩니다.</p></p>
<ul>
<li>/etc/security/limits.conf에서 사용자 프로세스 설정(ulimit -u)</li>
<li>/proc/sys/kernel/threads_max에 정의된 한계</li>
<li>libpthreads.so에 정의된 한계 <strong>PTHREAD_THREADS_MAX</strong>(이 값이 변경되는 경우 glibc를 다시 컴파일해야 함)</li></ul>
<p>그러나 최대 스레드 수에 도달하기 전에 가상 저장영역을 모두 사용할 수 있습니다.</p>
<p>
<a name="wq162"></a>
<h2 id="wq162">ThreadMXBean 스레드 사용자 CPU 시간 제한사항</h2>
<p>이 플랫폼에서는 사용자 모드 CPU 시간과
시스템 모드 CPU 시간을 구분할 방법이 없습니다. ThreadMXBean.getThreadUserTime(), ThreadMXBean.getThreadCpuTime(), ThreadMXBean.getCurrentThreadUserTime() 및 ThreadMXBean.getCurrentThreadCpuTime()은 모두
필수 스레드의 총 CPU 시간을 리턴합니다.</p></p>
<p>
<a name="wq163"></a>
<h2 id="wq163">KeyEvent 및 창 관리자</h2>
<p><strong>Alt</strong> 키를 포함하는
KeyEvent 결과는 Linux에서
사용하는 창 관리자에 따라 다를 수 있습니다.
또한 운영 체제에 따라 결과도 다르게 됩니다.
기본 설정을 사용하는 경우, KWin 창 관리자에서 <strong>Ctrl+Alt+A</strong>를 누르면
KeyEvent가 생성되지만 Metacity 창 관리자에서 <strong>Ctrl+Alt+A</strong>를 누르면
키 이벤트가 생성되지 않습니다.</p></p>
<p>
<a name="wq164"></a>
<h2 id="wq164">X 윈도우 시스템 및 메타 키</h2>
<p>Linux X
윈도우 시스템에서 키맵은 64 0xffe9(Alt_L) 0xffe7(Meta_L) 및 113 0xffea(Alt_R) 0xffe8(Meta_R)로 설정됩니다. 쉘 프롬프트에서 다음을
입력하여 이를 점검할 수 있습니다.</p></p>
<pre class="xmp">xmodmap -pk  </pre>
<p>따라서 SDK는 Meta와 Alt를 함께 누르는 것으로
간주합니다. 이에 대한 해결책으로 쉘 프롬프트에서 다음을 입력하여 Meta_x 맵핑을
제거할 수 있습니다.</p>
<pre class="xmp">xmodmap -e "keysym Alt_L = Alt_L" -e "keysym Alt_R = Alt_R"     </pre>
<p>이 해결책은 제거된 Meta 키를 사용할 경우 같은 표시장치에서 실행되는
다른 X-Windows 응용프로그램에 영향을 줄 수 있습니다.</p>
<p>
<a name="wq165"></a>
<h2 id="wq165">JNI를 사용하여 JVM을 작성하는 경우 SIGSEGV</h2>
<p>JNI 응용프로그램에서
JNI_CreateJavaVM()을 호출하면 세그먼테이션 결함(신호 SIGSEGV)이 발생할 수 있습니다.
이를 방지하려면 <strong>-lpthread</strong> 옵션을 지정하여 JNI 프로그램을 다시 빌드하십시오.</p></p>
<p>
<a name="wq166"></a>
<h2 id="wq166">고도로 스레드된 응용프로그램에서 자원 부족</h2>
<p>많은 스레드를 동시에 실행하는 경우,
경고 메시지가 표시될 수 있습니다.</p></p>
<pre class="xmp">java.lang.OutOfMemoryError</pre>
<p>이는
사용자 시스템의 시스템 자원이 부족하다는 표시이며, 메시지의 원인은 다음과 같은
이유 때문일 수 있습니다.</p>
<ul>
<li>작성된 프로세스 수가 사용자 한계를 초과합니다(Linux 설치에서
NPTL이 아니라 LinuxThreads를 사용하는 경우).</li>
<li>새 스레드를 작성하는 데 충분한 시스템 자원이 사용 가능하지 않습니다. 이 경우,
실행 중인 응용프로그램에 따라 다른 Java 예외가
발생할 수도 있습니다.</li>
<li>커널 메모리가 부족하거나 단편화되었습니다.  종료된 프로세스 ID의
/var/log/messages에서 해당 메모리 부족 커널 메시지가
표시될 수 있습니다.</li></ul>
<p>해당 시스템 자원을 늘리려면 시스템을 조정하십시오.</p>
<p>
<a name="wq167"></a>
<h2 id="wq167">X 서버 및 클라이언트 글꼴 문제점</h2>
<p>Linux
시스템에서 Java AWT 또는
Swing 응용프로그램을 실행하여 디스플레이를 2차 시스템으로 내보내는 경우,
X 클라이언트 시스템에 로드된 글꼴 세트가 X 서버 시스템에 로드된 세트와 다르면 일부 대화 상자를
표시하는 데 문제점이 있을 수 있습니다.  이 문제점을 방지하려면 두 시스템에 동일한 글꼴을 설치하십시오.</p></p>
<p>
<a name="wq168"></a>
<h2 id="wq168">UTF-8 인코딩 및 MalformedInputExceptions</h2>
<p>시스템 로케일에서
UTF-8 인코딩을 사용하는 경우 일부 SDK 도구에서 sun.io.MalformedInputException이 발생할 수 있습니다.
시스템이 UTF-8 인코딩을 사용하는지 여부를 알려면 로케일 특정 환경 변수(예: <strong>LANG</strong> 또는 <strong>LC_ALL</strong>)가
접미부 『.UTF-8』로 끝나는지 조사하십시오. sun.io.MalformedInputException이 발생하는 경우
7-bit ASCII 범위(0x00 - 0x7f) 내에 없으면서 Java
Unicode 문자 리터럴로 표시되지 않는 문자를 Java Unicode
문자 리터럴(예: '\u0080')로 변경하십시오. 또한 로케일 특정 환경 변수에서 『.UTF-8』 접미부를 제거하여 이 문제점을
회피할 수도 있습니다. 예를 들어, 시스템의 기본 로케일이 『en_US.UTF-8』인 경우 <strong>LANG</strong>을
『en_US』로 설정하십시오.</p></p>
<p>
<a name="wq169"></a>
<h2 id="wq169">디스플레이를 내보낼 때 AMI
및 xcin 문제점</h2>
<p>AMI 및 xcin을 교차 플랫폼 환경에서 사용하는 경우(예를 들어, 32-bit 시스템과 64-bit 시스템 간이나
빅 엔디안 시스템과 리틀 엔디안 시스템 간에 디스플레이를 내보내려는 경우), 문제점이 발생할 수
있습니다. 이러한 유형의 문제점이 발생하는 경우에는
AMI 및 xcin의 최신 버전으로 업그레이드하십시오.</p></p>
<p>
<a name="wq170"></a>
<h2 id="wq170">RHEL4 및 XIM</h2>
<p><strong>RHEL4의 중국어, 한국어 및
일본어 사용자에게만 해당합니다.</strong></p>
<p>XIM 서버는 기본적으로 설치되지
않습니다. Java 응용프로그램에
DBCS 문자를 입력하려면 XIM 서버 패키지(예: iiimf-x 또는 kinput2)를 입력하십시오.</p></p>
<p>
<a name="wq171"></a>
<h2 id="wq171">RHEL4 및 IIIMF</h2>
<p><strong>RHEL4의 중국어,
한국어 및 일본어 사용자에게만 해당합니다.</strong></p>
<p>IIIMF(Internet/Intranet Input Method Framework)를 사용 중인 경우
Red Hat Enterprise Linux 4 업데이트 2 이상에 포함된 IIIMF 패키지를 사용하십시오. Red Hat(<a href="http://www.redhat.com" target="_blank">http://www.redhat.com</a>)을 참조하십시오.</p>
<p><strong>(zSeries 64비트에만
해당)</strong> IIIMF 실패 또는 시작 실패가 발생할 수 있습니다. 문제점을 해결하려면
최신 IIIMF 패키지로 업그레이드하십시오.</p>
<p><strong>(PPC, s390 또는 s390x의 중국어에만 해당)</strong> IIIMF가
작동하지 않을 수 있습니다. 문제점을 해결하려면
iiimf-le-xcin-0.1.7-13.EL4 이상을 사용하십시오.</p>
<p><strong>(PPC, s390 또는 s390x의 중국어에만 해당)</strong> IIIMF가
올바로 작동하지 않을 수 있습니다. 문제점을 해결하려면
RHEL4 업데이트 5 이상에 포함된 IIMF 패키지를 사용하십시오.</p></p>
<p>
<a name="wq172"></a>
<h2 id="wq172">RHEL4 및 zh_CN.GB18030 로케일</h2>
<p><strong>RHEL4의
중국어 사용자에게만 해당합니다.</strong></p>
<p>zh_CN.GB18030 로케일은 RHEL4의 xlib에서 지원되지 않습니다. xterm은 메소드 서버를 활성화할 수 없으므로
GB18030 문자를 입력할 수 없습니다. 대신 zh_CN.UTF8 로케일을 사용하십시오. GB2312, GBK 또는 GB18030으로 인코드한 데이터 또는
레거시 프로그램이 있고 이를 RHEL4로 이주하려는 경우, iconv로 사전 처리하여 UTF-8 인코딩으로 변환해야
프로그램을 실행할 수 있고 데이터를 zh_CN.UTF8 로케일로 RHEL4에 적절하게 표시할 수 있습니다.</p>
<p>이 제한사항은
RHEL4 U3에서 해결되었습니다.</p></p>
<p>
<a name="wq173"></a>
<h2 id="wq173">RHEL4 및 xcin</h2>
<p>RHEL4의 xcin에서
정지될 수 있습니다. 문제점을 해결하려면 /etc/chinese/xcin/xcinrc 파일에서 <strong>ICCHECK_DISABLE</strong>을
YES로 설정하십시오.</p>
<p><strong>64-bit 환경에만 해당</strong></p>
<p>xcin(대만어 XIM 서버)를 사용하는
RHEL4의 경우, 64-bit 환경(예: AMD64 또는 zSeries 64-bit 플랫폼)의
Java에서 세그먼테이션 결함 등
예상하지 못한 동작이 발생할 수 있습니다. 문제점을 해결하려면
최신 xcin 패키지로 업그레이드하십시오.</p></p>
<p>
<a name="wq174"></a>
<h2 id="wq174">RHEL4 및 IIIMF 초점 변경 문제점</h2>
<p><strong>RHEL4에만 해당합니다.</strong></p>
<p>IIIMF(Internet Intranet
Input Method Framework)를 사용하여 DBCS 문자를 입력할 때 초점 변경 문제점이 발생할 수
있습니다. 이 문제점은 활성 입력 구성요소를 최소화할 때 발생합니다.
구성요소를 복원한 후 입력 메소드는 다시 SBCS로 전환됩니다.
그런 다음 수동으로 DBCS를 다시 활성화해야 합니다.</p>
<p>이러한 초점 변경 문제점이 있는 구성요소는 다음과 같습니다. 
</p>
<ul>
<li>java.awt.Canvas</li>
<li>java.awt.Button</li>
<li>javax.swing.JButton</li>
<li>javax.swing.JSplitPane</li>
<li>javax.swing.JComboBox</li>
<li>javax.swing.JList</li></ul></p>
<p>
<a name="wq175"></a>
<h2 id="wq175">XIM 및
Java Plug-in</h2>
<p><strong>RHEL4 및 SLES9에만 해당</strong></p>
<p>일본어, 중국어 및
한국어 사용자의 경우, XIM을 사용하여 웹 브라우저에서
Java 애플릿의
텍스트 구성요소에 자국어 문자를 입력할 수 없습니다. XEmbed에 X11 라이브러리 파일의
수정사항이 필요하므로 이 제한사항이 발생합니다. 이러한 상황을 피하려면
XEmbed를 사용하지 않도록 <strong>-Dsun.awt.noxembed=true</strong> 시스템 매개변수를
지정하십시오. 다음과 같이 제어판을 사용하여 이 옵션을 설정할 수 있습니다.

</p>
<ol type="1">
<li>Java Plug-in 제어판을 열고
<strong>Java</strong> 탭으로 이동하십시오.</li>
<li>Java
애플릿 런타임 설정에서 <strong>보기</strong> 단추를 클릭하십시오.</li>
<li>Java 런타임
매개변수에 <strong>-Dsun.awt.noxembed=true</strong>를 입력하고 <strong>확인</strong>을 클릭하십시오.</li>
<li><strong>적용</strong>을 클릭하십시오.</li>
<li>브라우저를 시작하십시오.</li></ol>
<p>이 제한사항은
RHEL4 U3 및 SLES9 SP3에서
해결되었습니다.</p></p>
<p>
<a name="wq177"></a>
<h2 id="wq177">아랍어 문자 및
Matrox 비디오 카드</h2>
<p><strong>Intel 32-bit
플랫폼에만 해당</strong></p>
<p>아랍어 사용자는 Matrox 비디오 카드로
Linux를 사용 중이고 가속이 사용되는 경우,
drawString을 사용하여 큰 글꼴을 표시할 때 문자가 왜곡되어 나타날 수 있습니다. 이는 해당 카드의 드라이버로 인해 발생합니다. 해당 문제점을 해결하려면
디바이스에서 acceleration을 사용 불가능하게 하십시오.</p></p>
<p>
<a name="wq178"></a>
<h2 id="wq178">SLES9 NPTL 및 병렬 포트 드라이버</h2>
<p><strong>Intel 32-bit
플랫폼에만 해당</strong></p>
<p>SLES 9 NPTL에서 병렬 포트 드라이버 때문에 커널 크래시가 발생하고
Java 스레드가
중단될 수 있습니다. JVM은 가비지 콜렉션의 스레드를 일시중단하려할 때 이 크래시를 발견하며,
크래시는 코어 파일과 『JVMLH030: 모든 스레드를 일시중단하는 중 스레드가 사라집니다.』라는 메시지를 생성합니다.</p>
<p>SUSE Bugzilla 보고서 47947에 이 문제점에 대해 보고되어 있습니다. 이 버그는 SLES 9 Service Pack 1에서 수정되었습니다.</p></p>
<p>
<a name="wq179"></a>
<h2 id="wq179">PPC 플랫폼에서 9개 이상의 매개변수가 있는
JNI 호출</h2>
<p><strong>PPC 플랫폼에만 해당</strong></p>
<p>Java
코드에서 JNI 호출을 사용하며 특정 호출에 9개 이상의 float 또는 double 매개변수가 있는 경우, C 코드는
GCC(GNU C Complier)의 gcc-2.95.3 FSF(Free Software Foundation) 레벨로 컴파일해야 합니다.</p></p>
<p>
<a name="wq180"></a>
<h2 id="wq180">SP2 전의 SLES9에서
병렬 포트 조작</h2>
<p><strong>PPC 플랫폼에만 해당</strong></p>
<p>JavaComm 패키지는 SLES 9 GA 및 SP1 커널에서
병렬 포트 조작을 지원하지 않습니다. 이 제한사항은 SP2 커널에서 해소되었습니다.
SUSE Bugzilla 번호는 50028입니다.</p></p>
<p>
<a name="wq181"></a>
<h2 id="wq181">PPC 64-bit 플랫폼에서 libFileStat.so 컴파일</h2>
<p><strong>PPC 64-bit
플랫폼에만 해당</strong></p>
<p>기본 gcc 교차 컴파일러(버전 3.2-49)로 인해 몇 가지 오류가 발생합니다.
공유 라이브러리 libFileStat.so를 생성하려면 다음을 실행하십시오.</p></p>
<pre class="xmp">/opt/cross/bin/powerpc64-linux-gcc -shared -o libFileStat.so -I<em>&lt;SDK_PATH&gt;</em>/include FileStat.c</pre>
<p> 여기서
<em>&lt;SDK_PATH&gt;</em>는 설치된 SDK 디렉토리의 경로입니다.</p>
<p>
<a name="wq182"></a>
<h2 id="wq182">zSeries
플랫폼에서 IPv6</h2>
<p><strong>zSeries 플랫폼에만 해당</strong></p>
<p>현재
분배에서 Linux 커널이 IPv6(Internet Protocol 버전 6)을
지원하더라도 사용하는 데 문제점이 있을 수 있습니다. Java에서
IPv6에 대한 지원은 이 릴리스에 포함되지만, java 명령에 <strong>-Djava.net.preferIPv4Stack=true</strong> 옵션을 지정하여
이 지원을 해제하는 것이 좋습니다. IPv6을 완전히 지원하는 커널을 설치하는 경우에는 이 옵션이 필요하지 않습니다.</p></p>
<p>
<a name="wq183"></a>
<h2 id="wq183">64-bit zSeries
플랫폼에서 xcin</h2>
<p><strong>zSeries 64-bit
플랫폼에만 해당</strong></p>
<p>중국어 및 대만어 입력 메소드 서버(xcin)는 테스트하지 않았습니다.</p></p>
<p>
<a name="wq184"></a>
<h2 id="wq184">Java 데스크탑
API</h2>
<p>Java 데스크탑 API는
하나 이상의 GNOME 라이브러리를 사용할 수 없으므로 작동하지 않을 수도 있습니다.</p></p>
<p>
<a name="wq185"></a>
<h2 id="wq185">GTK 룩앤필의 NullPointerException</h2>
<p><strong>DBCS 환경에만 해당</strong></p>
<p>GTK 룩앤필을 사용하는
응용프로그램이 NullPointerException로 실패하면, <strong>GNOME_DESKTOP_SESSION_ID</strong> 환경 변수
설정을 해제하십시오.</p></p>
<p>
<a name="wq186"></a>
<h2 id="wq186">Unicode Shift_JIS 코드 페이지 별명</h2>
<p><strong>일본어 사용자에만 해당</strong></p>
<p>Shift_JIS의 Unicode 코드 페이지 별명 『\u30b7\u30d5\u30c8\u7b26\u53f7\u5316\u8868\u73fe』가
제거되었습니다. 응용프로그램에서 이 코드 페이지를 사용하려면 Shift_JIS로 바꾸십시오.</p></p>
<a name="notices"></a>
<h1 id="notices"><a href="#ToC_169">주의사항</a></h1>
<div>
<p>이 정보는 미국에서 제공되는 제품 및 서비스용으로 작성된 것입니다.   IBM은
다른 국가에서 이 책에 기술된 제품, 서비스 또는 기능을 제공하지 않을 수도 있습니다. 현재 사용할 수 있는 제품 및 서비스에 대한 정보는 한국
IBM
담당자에게 문의하십시오.</p></div>
<p>이 책에서 IBM 제품, 프로그램 또는
서비스를 언급했다고 해서 해당 IBM 제품, 프로그램 또는
서비스만을 사용할 수 있다는 것을 의미하지는 않습니다. IBM의
지적 재산권을 침해하지 않는 한, 기능상으로 동등한 제품, 프로그램 또는 서비스를 대신 사용할 수도 있습니다.
그러나 비IBM 제품, 프로그램 또는 서비스의
운용에 대한 평가 및 검증은 사용자의 책임입니다.</p>
<p>IBM은 이 책에서
다루고 있는 특정 내용에 대해 특허를 보유하고 있거나 현재 특허 출원 중일 수 있습니다. 이 책을 제공한다고 해서 특허에 대한 라이센스까지 부여하는 것은
아닙니다. 라이센스에 대한 의문사항은 다음으로
문의하십시오.</p>
<ul class="simple">
<li>135-270</li>
<li>서울특별시 강남구 도곡동 467-12
군인공제회관빌딩</li>
<li>한국 아이.비.엠 주식회사
고객만족센터</li>
<li>전화번호: 080-023-8080</li></ul>
<p>2바이트(DBCS) 정보에 관한 라이센스 문의는 한국
IBM 고객만족센터에 문의하거나
다음 주소로 서면 문의하시기 바랍니다.</p>
<ul class="simple">
<li>IBM World
Trade Asia Corporation Licensing</li>
<li>2-31 Roppongi 3-chome, Minato-ku</li>
<li>Tokyo 106-0032, Japan</li></ul>
<p>다음 단락은 현지법과 상충하는 영국이나 기타 국가에서는 적용되지 않습니다.</p>
<p>IBM은 타인의 권리 비침해, 상품성 및 특정 목적에의 적합성에 대한 묵시적
보증을 포함하여(단, 이에 한하지 않음) 묵시적이든 명시적이든 어떠한 종류의
보증없이 이 책을 "현상태대로" 제공합니다. 일부 국가에서는 특정 거래에서
명시적 또는 묵시적 보증의 면책사항을 허용하지 않으므로, 이 사항이 적용되지 않을 수도 있습니다.</p>
<p>이 정보에는 기술적으로 부정확한 내용이나 인쇄상의 오류가 있을 수 있습니다. 이 정보는
주기적으로 변경되며, 변경사항은 최신판에 통합됩니다. IBM은
이 책에서 설명한 제품 및/또는 프로그램을 사전 통지 없이 언제든지 개선 및/또는 변경할 수 있습니다.</p>
<p>이 정보에서 언급되는 비IBM의 웹 사이트는 단지 편의상 제공된
것으로, 어떤 방식으로든 이들 웹 사이트를 옹호하고자 하는 것은 아닙니다. 해당 웹 사이트의 자료는 본
IBM 제품 자료의 일부가 아니므로
해당 웹 사이트 사용으로 인한 위험은 사용자 본인이 감수해야 합니다.</p>
<p>IBM은
귀하의 권리를 침해하지 않는 범위 내에서 적절하다고 생각하는 방식으로 귀하가 제공한 정보를
사용하거나 배포할 수 있습니다.</p>
<p>(i) 독립적으로 작성된 프로그램과 기타 프로그램(본 프로그램 포함)간의 정보 교환 및
(ii) 교환된 정보의 상호 이용을 목적으로 정보를
원하는 프로그램 라이센스 사용자는 다음 주소로 문의하십시오.</p>
<ul class="simple">
<li>135-270
서울특별시 강남구 도곡동 467-12
군인공제회관빌딩</li>
<li>한국 아이.비.엠 주식회사
고객만족센터</li></ul>
<p>이러한 정보는 해당 조건(예를 들어, 사용료 지불 등)에 따라 사용할 수 있습니다.</p>
<p>이 정보에 기술된 라이센스가 있는 프로그램 및 이 프로그램에 대해 사용 가능한 모든 라이센스가 있는
자료는 IBM이
IBM 기본 계약,
IBM 프로그램 라이센스 계약(IPLA) 또는
이와 동등한 계약에 따라 제공한 것입니다.</p>
<p>본 문서에 포함된 모든 성능 데이터는 제한된 환경에서 산출된 것입니다.
따라서
다른 운영 환경에서 얻어진 결과는 상당히 다를 수 있습니다.
일부 성능은 개발 레벨
상태의 시스템에서 측정되었을 수 있으므로 이러한 측정치가 일반적으로 사용되고 있는
시스템에서도 동일하게 나타날 것이라고는 보증할 수 없습니다. 또한,
일부 성능은 추정을 통해 추측되었을 수도 있으므로
실제 결과는 다를 수 있습니다. 이 책의 사용자는 해당
데이터를 사용자의 특정 환경에서 검증해야 합니다.</p>
<p>비IBM 제품에 관한 정보는 해당 제품의 공급업체, 공개 자료 또는 다른 기타 범용 소스로부터
얻은 것입니다. IBM에서는
이러한 제품들을 테스트하지 않았으므로, 비IBM 제품과 관련된 성능의 정확성, 호환성 또는 기타 청구에
대해서는 확신할 수 없습니다. 비IBM 제품의 성능에 대한 의문사항은 해당 제품의 공급업체에 문의하십시오.</p>
<a name="trademarks"></a>
<h2 id="trademarks"><a href="#ToC_170">상표</a></h2>
<p>IBM, iSeries, pSeries 및 zSeries는
미국 또는 기타 국가에서 사용되는 International Business Machines Corporation의 상표 또는
등록상표입니다.</p>
<p>Intel은 미국 또는 기타 국가에서 사용되는 International Business Machines Corporation의
상표입니다.</p>
<p>Java 및 모든 Java 기반 상표와 로고는 미국 또는 기타 국가에서 Sun Microsystems, Inc.의 상표 또는
등록상표입니다.</p>
<p>Linux는 미국 또는 기타 국가에서 사용되는 Linus Torvalds의 상표입니다.</p>
<p>기타 회사, 제품 및 서비스 이름은 타사의 상표 또는 서비스표입니다.</p>
<a id="Bot_Of_Page" name="Bot_Of_Page"></a>
</body>
</html>
