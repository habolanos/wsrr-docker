<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="de-DE" xml:lang="de-de">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
<meta name="dc.language" scheme="rfc1766" content="de-de" />
<meta name="dc.date" scheme="iso8601" content="2007-09-25" />
<meta name="copyright" content="(C) Copyright IBM Corp. 2003, 2007" />
<meta name="security" content="public" />
<meta name="Robots" content="index,follow"/>
<meta http-equiv="PICS-Label" content='(PICS-1.1 "http://www.icra.org/ratingsv02.html" l gen true r (cz 1 lz 1 nz 1 oz 1 vz 1) "http://www.rsac.org/ratingsv01.html" l gen true r (n 0 s 0 v 0 l 0) "http://www.classify.org/safesurf/" l gen true r (SS~~000 1))' />
<meta name="type" content="concept, reference, reference, task, task, task, task, task, task, task, task, task, task, task, task, reference, task, task, reference, task, task, task, reference, task, reference, task, reference, reference, task, reference, task, reference, task, task, reference, reference, reference, reference, task, reference, task, task, reference, task, task, task, reference, task, reference, task, task, reference, task, task, task, task, task, task, task, reference, reference, reference" />
<meta name="keywords" content="Red Hat Enterprise Linux (RHEL) 4, Installation, Red Hat Enterprise Linux (RHEL) 5, SELinux, Deinstallation" />
<meta name="keywords" content="Red Hat Enterprise Linux (RHEL) 4Ii, Bandarchiv, -agentlib:, -agentpath:, -assert, -cp, -classpath, -D, -help, -?, -javaagent:, -jre-restrict-search" />
<meta name="keywords" content="-no-jre-restrict-search, -showversion, -verbose:, -version:, -X, Just-In-Time, Compiler, Just-In-Time-Kompilierung, -Xinit, Optionen, -Xnojit, testen" />
<meta name="keywords" content="JIT, angeben, Garbage-Collection, -Xgcpolicy, Pausezeit, Verringerung der Pausezeit, volle Freispeicher, Umgebungen, XML, XSL" />
<meta name="keywords" content="Gemeinsame Nutzung von Klassendaten, -Xshareclasses, Optionen f&uuml;r die gemeinsame Nutzung von Klassen, -Xscmx, Cache erstellen, Cache f&uuml;llen" />
<meta name="keywords" content="Cache &uuml;berwachen, Cache l&ouml;schen, Leistung, Speicherbelegung, Einschr&auml;nkungen, Gemeinsame Nutzung von Klassen, Aspekte" />
<meta name="keywords" content="Grenzwerte f&uuml;r die Cachegr&ouml;&szlig;e, &Auml;nderungen bei Laufzeitbytecodes, Betriebssystemeinschr&auml;nkungen, verwenden" />
<meta name="keywords" content="SharedClassPermission, anpassen, Klassenladeprogramme, -Xcheck:memory" />
<title>SDK und Runtime</title>
<link rel="stylesheet" type="text/css" href="../ibmidwb.css" />
<link rel="stylesheet" type="text/css" href="../swg_info_common.css" />
</head>
<body class="revised">
<a id="Top_Of_Page" name="Top_Of_Page"></a><h1>IBM SDK for Linux platforms, Java Technology Edition,&nbsp;Version 6</h1>
<h1>SDK und Runtime</h1>
<br />
<span class="ibmdocnum"></span><br />
<a name="notices_link"></a>
<div id="notices_link">
<div class="pblklblbox">
<span class="pblktitle">Hinweis</span>
<p>Vor Verwendung dieser Informationen und des darin beschriebenen Produkts sollten die Informationen unter <a href="#notices">Bemerkungen</a> gelesen werden.</p></div></div>
<a name="copyright"></a>
<div id="copyright">
<span class="ednoticestitle">Copyrightvermerk</span>
<p>Diese Ausgabe des Benutzerhandbuchs bezieht sich auf IBM SDK and Runtime Environment for Linux auf mehreren Plattformen.</p>
<p>Dieses Handbuch bezieht sich auf folgende Plattformen: 
</p>
<ul>
<li>IBM 32-bit SDK and Runtime Environment for Linux on Intel architecture, Java Technology Edition, Version 6</li>
<li>IBM 64-bit SDK and Runtime Environment for Linux on AMD64/EM64T
architecture, Java Technology Edition, Version 6</li>
<li>IBM 32-bit SDK and Runtime Environment for Linux on System
i and System p architecture, Java Technology Edition, Version 6</li>
<li>IBM 64-bit SDK and Runtime Environment for Linux on System
i and System p architecture, Java Technology Edition, Version 6</li>
<li>IBM 31-bit SDK and Runtime Environment for Linux on System
z architecture, Java Technology
Edition, Version 6</li>
<li>IBM 64-bit SDK and Runtime Environment for Linux on System
z architecture, Java Technology
Edition, Version 6</li></ul><p class="indatacontent"> Weiterhin bezieht sich diese Ausgabe des Benutzerhandbuchs auf alle nachfolgenden Releases und &Auml;nderungen bis zur Herausgabe neuer Dateiversionen.</p>
<p>(C) Copyright Sun Microsystems, Inc. 1997, 2007, 901 San Antonio Rd., Palo Alto, CA 94303 USA. Alle Rechte vorbehalten.</p></div><div><strong>Copyright International Business Machines Corporation 2003, 2007. Alle Rechte vorbehalten.</strong></div>

<a name="wq2"></a>
<div id="wq2">
<h1>Inhaltsverzeichnis</h1>
<div class="head1"><a id="ToC_1" name="ToC_1" href="#preface" class="toclink">Vorwort</a></div>
<div class="head1"><a id="ToC_2" name="ToC_2" href="#overview" class="toclink">&Uuml;bersicht</a></div>
<div class="head2"><a id="ToC_3" name="ToC_3" href="#lnx_conventions" class="toclink">Konventionen</a></div>
<div class="head2"><a id="ToC_4" name="ToC_4" href="#compatibility" class="toclink">Versionskompatibilit&auml;t</a></div>
<div class="head2"><a id="ToC_5" name="ToC_5" href="#migrating" class="toclink">Migrieren von weiteren IBM JVMs</a></div>
<div class="head2"><a id="ToC_6" name="ToC_6" href="#zhardware" class="toclink">Unterst&uuml;tzte Hardware f&uuml;r System z</a></div>
<div class="head1"><a id="ToC_7" name="ToC_7" href="#contents_sdk" class="toclink">Inhalt von SDK und Runtime Environment</a></div>
<div class="head2"><a id="ToC_8" name="ToC_8" href="#jretools" class="toclink">Runtime Environment-Klassen und -Tools</a></div>
<div class="head2"><a id="ToC_9" name="ToC_9" href="#sdktools" class="toclink">SDK-Tools und -Referenzinformationen</a></div>
<div class="head1"><a id="ToC_10" name="ToC_10" href="#lin_install_config" class="toclink">Installieren und Konfigurieren von SDK und Runtime Environment</a></div>
<div class="head2"><a id="ToC_11" name="ToC_11" href="#upgrading" class="toclink">Ausf&uuml;hren eines Upgrades f&uuml;r SDK</a></div>
<div class="head2"><a id="ToC_12" name="ToC_12" href="#installredhat4" class="toclink">Installieren unter Red Hat Enterprise Linux (RHEL) 4</a></div>
<div class="head2"><a id="ToC_13" name="ToC_13" href="#installredhat5" class="toclink">Installieren unter Red Hat Enterprise Linux (RHEL) 5</a></div>
<div class="head3"><a id="ToC_14" name="ToC_14" href="#lin_redhat_selinux" class="toclink">Ausf&uuml;hren von Java mit SELinux unter RHEL 5</a></div>
<div class="head2"><a id="ToC_15" name="ToC_15" href="#lin_install" class="toclink">Installieren eines 32-Bit-SDK auf einer 64-Bit-Architektur</a></div>
<div class="head2"><a id="ToC_16" name="ToC_16" href="#lin_rpm_install" class="toclink">Installieren aus einer RPM-Datei</a></div>
<div class="head2"><a id="ToC_17" name="ToC_17" href="#lin_tgz_install" class="toclink">Installieren aus einer .tgz-Datei</a></div>
<div class="head2"><a id="ToC_18" name="ToC_18" href="#lin_jpackage_install" class="toclink">Verwenden eines JPackage-kompatiblen Formats</a></div>
<div class="head2"><a id="ToC_19" name="ToC_19" href="#lin_config" class="toclink">Konfigurieren von SDK und Runtime Environment f&uuml;r Linux</a></div>
<div class="head3"><a id="ToC_20" name="ToC_20" href="#pathcons" class="toclink">Festlegen des Pfads</a></div>
<div class="head3"><a id="ToC_21" name="ToC_21" href="#classpath" class="toclink">Festlegen des Klassenpfades</a></div>
<div class="head2"><a id="ToC_22" name="ToC_22" href="#lin_uninstall" class="toclink">Deinstallieren von SDK und Runtime Environment for Linux</a></div>
<div class="head3"><a id="ToC_23" name="ToC_23" href="#uninstrpm" class="toclink">Deinstallieren des RPM-Pakets (Red Hat Package Manager)</a></div>
<div class="head3"><a id="ToC_24" name="ToC_24" href="#uninsttar" class="toclink">Deinstallieren des komprimierten TAR-Pakets (Tape Archive)</a></div>
<div class="head1"><a id="ToC_25" name="ToC_25" href="#running_applications" class="toclink">Ausf&uuml;hren von Java-Anwendungen</a></div>
<div class="head2"><a id="ToC_26" name="ToC_26" href="#invint" class="toclink">Die Befehle java und javaw</a></div>
<div class="head3"><a id="ToC_30" name="ToC_30" href="#build_number" class="toclink">Erhalten von Versionsinformationen</a></div>
<div class="head3"><a id="ToC_31" name="ToC_31" href="#specifying_options" class="toclink">Angeben von Java-Optionen und Systemmerkmalen</a></div>
<div class="head3"><a id="ToC_32" name="ToC_32" href="#standard_options" class="toclink">Standardoptionen</a></div>
<div class="head3"><a id="ToC_33" name="ToC_33" href="#globalization" class="toclink">Globalisierung des Befehls java</a></div>
<div class="head2"><a id="ToC_34" name="ToC_34" href="#jit" class="toclink">JIT-Compiler (Just-In-Time)</a></div>
<div class="head3"><a id="ToC_35" name="ToC_35" href="#disjit" class="toclink">Inaktivieren des JIT-Compilers</a></div>
<div class="head3"><a id="ToC_36" name="ToC_36" href="#enajit" class="toclink">Aktivieren des JIT-Compilers</a></div>
<div class="head3"><a id="ToC_37" name="ToC_37" href="#detjit" class="toclink">Pr&uuml;fen, ob der JIT-Compiler aktiviert ist</a></div>
<div class="head2"><a id="ToC_38" name="ToC_38" href="#garbage" class="toclink">Angeben der Garbage-Collection-Richtlinie</a></div>
<div class="head3"><a id="ToC_39" name="ToC_39" href="#garbage_options" class="toclink">Optionen der Garbage-Collection</a></div>
<div class="head3"><a id="ToC_40" name="ToC_40" href="#garbage_pause" class="toclink">Pausezeit</a></div>
<div class="head3"><a id="ToC_41" name="ToC_41" href="#pausetimereduction" class="toclink">Verringerung der Pausezeit</a></div>
<div class="head3"><a id="ToC_42" name="ToC_42" href="#garbage_full_heap" class="toclink">Umgebungen mit sehr vollen Freispeichern</a></div>
<div class="head2"><a id="ToC_43" name="ToC_43" href="#euro_symbol" class="toclink">Unterst&uuml;tzung des Euro-Symbols</a></div>
<div class="head2"><a id="ToC_44" name="ToC_44" href="#fallback_font" class="toclink">Schriftartkonfigurationsdateien zur Zur&uuml;cksetzung</a></div><span id="changed">|</span>
<span id="changed">|</span><div class="head2"><a id="ToC_45" name="ToC_45" href="#input_method_extensions" class="toclink">Verwenden von Eingabemethoden f&uuml;r Indisch und Thail&auml;ndisch</a></div>
<div class="head1"><a id="ToC_46" name="ToC_46" href="#developing" class="toclink">Verwenden von SDK zur Entwicklung von Java-Anwendungen</a></div><span id="changed">|</span>
<span id="changed">|</span><div class="head2"><a id="ToC_47" name="ToC_47" href="#xml_using" class="toclink">Verwenden von XML</a></div><span id="changed">|</span>
<span id="changed">|</span><div class="head3"><a id="ToC_50" name="ToC_50" href="#xslt_migration_steps" class="toclink">Migrieren auf den XL-TXE-J-Compiler</a></div><span id="changed">|</span>
<span id="changed">|</span><div class="head3"><a id="ToC_51" name="ToC_51" href="#xml_reference" class="toclink">XML-Referenzinformationen</a></div>
<div class="head2"><a id="ToC_62" name="ToC_62" href="#debugger" class="toclink">Debugging in Java-Anwendungen</a></div>
<div class="head3"><a id="ToC_63" name="ToC_63" href="#jdb" class="toclink">Java-Debugger (JDB)</a></div>
<div class="head2"><a id="ToC_64" name="ToC_64" href="#bit_check" class="toclink">Ermitteln, ob eine Anwendung auf JVM im 32-Bit- oder 64-Bit-Modus ausgef&uuml;hrt wird</a></div>
<div class="head2"><a id="ToC_65" name="ToC_65" href="#signals" class="toclink">Signalverarbeitung durch JVM</a></div>
<div class="head3"><a id="ToC_66" name="ToC_66" href="#sighand" class="toclink">Von JVM verwendete Signale</a></div>
<div class="head3"><a id="ToC_67" name="ToC_67" href="#native_signals" class="toclink">Verbinden eines nativen Codetreibers mit der Signalverkettungsbibliothek</a></div>
<div class="head2"><a id="ToC_68" name="ToC_68" href="#usejni" class="toclink">Schreiben von JNI-Anwendungen</a></div>
<div class="head2"><a id="ToC_69" name="ToC_69" href="#blocked_threads" class="toclink">Unterst&uuml;tzung f&uuml;r die Wiederherstellung von blockierten Verbindungen auf Threadebene</a></div>
<div class="head2"><a id="ToC_70" name="ToC_70" href="#alloc_large_page" class="toclink">Konfigurieren einer Speicherzuordnung von gro&szlig;en Seiten</a></div>
<div class="head2"><a id="ToC_71" name="ToC_71" href="#corba" class="toclink">CORBA-Unterst&uuml;tzung</a></div>
<div class="head3"><a id="ToC_75" name="ToC_75" href="#corba_properties" class="toclink">Systemmerkmale f&uuml;r die ORB-Tracefunktion</a></div>
<div class="head3"><a id="ToC_79" name="ToC_79" href="#corba_tuning" class="toclink">Systemmerkmale zur Optimierung des ORB</a></div>
<div class="head3"><a id="ToC_80" name="ToC_80" href="#corba_security" class="toclink">Java-Sicherheitsberechtigungen f&uuml;r den ORB</a></div>
<div class="head3"><a id="ToC_81" name="ToC_81" href="#corba_classes" class="toclink">ORB-Implementierungsklassen</a></div>
<div class="head2"><a id="ToC_82" name="ToC_82" href="#rmi-iiop" class="toclink">RMI-IIOP</a></div>
<div class="head2"><a id="ToC_83" name="ToC_83" href="#rmi" class="toclink">Implementieren des Steuerroutinenpools f&uuml;r RMI-Verbindungen</a></div>
<div class="head2"><a id="ToC_84" name="ToC_84" href="#bigd" class="toclink">Funktionale Erweiterungen f&uuml;r BigDecimal</a></div>
<div class="head1"><a id="ToC_85" name="ToC_85" href="#deploying" class="toclink">Plug-in, Applet Viewer und Web Start</a></div>
<div class="head2"><a id="ToC_86" name="ToC_86" href="#using_plugin" class="toclink"><strong><span class="bold-italic">(Nur Linux IA 32 Bit und PPC32) </span></strong>Verwenden des Java Plug-ins</a></div>
<div class="head3"><a id="ToC_87" name="ToC_87" href="#suppbrowse" class="toclink">Unterst&uuml;tzte Browser</a></div>
<div class="head3"><a id="ToC_88" name="ToC_88" href="#installing_plugin" class="toclink">Installieren und Konfigurieren des Java Plug-ins</a></div>
<div class="head3"><a id="ToC_91" name="ToC_91" href="#plugin_dom" class="toclink">Allgemeine Dokumentobjektmodellunterst&uuml;tzung (Document Object Model, DOM)</a></div>
<div class="head3"><a id="ToC_92" name="ToC_92" href="#plugin_dbcs" class="toclink">Verwenden von DBCS-Parametern</a></div>
<div class="head2"><a id="ToC_93" name="ToC_93" href="#applets" class="toclink">Arbeiten mit Applets</a></div>
<div class="head3"><a id="ToC_94" name="ToC_94" href="#applet_viewer" class="toclink">Ausf&uuml;hren von Applets mit Applet Viewer</a></div>
<div class="head3"><a id="ToC_95" name="ToC_95" href="#applet_debugging" class="toclink">Debugging von Applets mit Applet Viewer</a></div>
<div class="head2"><a id="ToC_96" name="ToC_96" href="#using_webstart" class="toclink"><strong><span class="bold-italic">(Nur Linux IA 32 Bit, PPC32 und PPC64)</span></strong> Verwenden von Web Start</a></div>
<div class="head3"><a id="ToC_97" name="ToC_97" href="#installing_webstart" class="toclink">Ausf&uuml;hren von Java Web Start</a></div>
<div class="head3"><a id="ToC_98" name="ToC_98" href="#webstart_ssv" class="toclink"><strong><span class="bold-italic">(Nur Linux IA 32 Bit) </span></strong>Sichere statische Versionssteuerung f&uuml;r WebStart</a></div>
<div class="head2"><a id="ToC_99" name="ToC_99" href="#shipping" class="toclink">Ausliefern von Java-Anwendungen</a></div>
<div class="head1"><a id="ToC_100" name="ToC_100" href="#classdatasharing" class="toclink">Gemeinsame Nutzung von Klassendaten auf verschiedenen JVMs</a></div>
<div class="head2"><a id="ToC_101" name="ToC_101" href="#shc_overview" class="toclink">&Uuml;bersicht &uuml;ber die gemeinsame Nutzung von Klassendaten</a></div>
<div class="head2"><a id="ToC_108" name="ToC_108" href="#sharedclassesxoptions" class="toclink">Aktivieren und Konfigurieren der gemeinsamen Nutzung von Klassendaten</a></div>
<div class="head2"><a id="ToC_109" name="ToC_109" href="#shc_admin" class="toclink">Erstellen, Belegen, &Uuml;berwachen und L&ouml;schen eines Caches</a></div>
<div class="head2"><a id="ToC_110" name="ToC_110" href="#shc_performance" class="toclink">Leistung und Speicherbelegung</a></div>
<div class="head2"><a id="ToC_111" name="ToC_111" href="#shc_limitations" class="toclink">Besondere Aspekte und Einschr&auml;nkungen bei der gemeinsamen Nutzung von Klassendaten</a></div>
<div class="head3"><a id="ToC_112" name="ToC_112" href="#cachesizelimits" class="toclink">Grenzwerte f&uuml;r die Cachegr&ouml;&szlig;e</a></div>
<div class="head3"><a id="ToC_113" name="ToC_113" href="#runtimebytecode" class="toclink">&Auml;nderungen bei Laufzeitbytecodes</a></div>
<div class="head3"><a id="ToC_114" name="ToC_114" href="#shc_os_limitations" class="toclink">Betriebssystemeinschr&auml;nkungen</a></div>
<div class="head3"><a id="ToC_115" name="ToC_115" href="#usingsharedclasspermissions" class="toclink">Verwenden von 'SharedClassPermissions'</a></div>
<div class="head2"><a id="ToC_116" name="ToC_116" href="#adaptingclassloaders" class="toclink">Anpassen benutzerdefinierter Klassenladeprogramme an gemeinsam genutzte Klassen</a></div>
<div class="head1"><a id="ToC_117" name="ToC_117" href="#jcommchapter" class="toclink">Verwenden der Java Communications API (JavaComm)</a></div>
<div class="head2"><a id="ToC_118" name="ToC_118" href="#instcomm" class="toclink">Installieren der Java Communications API aus einer komprimierten Datei</a></div>
<div class="head2"><a id="ToC_119" name="ToC_119" href="#instcomm_rpm" class="toclink">Installieren der Java Communications API &uuml;ber eine RPM-Datei</a></div>
<div class="head2"><a id="ToC_120" name="ToC_120" href="#fileloc" class="toclink">Speicherposition der Java Communications API-Dateien</a></div>
<div class="head2"><a id="ToC_121" name="ToC_121" href="#javacomm_configure" class="toclink">Konfigurieren der Java Communications API</a></div>
<div class="head3"><a id="ToC_122" name="ToC_122" href="#javacomm_lnx_serial" class="toclink">&Auml;ndern des Zugriffsmodus f&uuml;r den seriellen Anschluss und den Parallelanschluss</a></div>
<div class="head3"><a id="ToC_123" name="ToC_123" href="#javacomm_lnx_devices" class="toclink">Angeben von Einheiten in der Datei javax.comm.properties</a></div>
<div class="head2"><a id="ToC_124" name="ToC_124" href="#javacomm_thinkpad" class="toclink">Aktivieren von seriellen Anschl&uuml;ssen auf IBM ThinkPads</a></div>
<div class="head2"><a id="ToC_125" name="ToC_125" href="#javacomm_printing" class="toclink">Einschr&auml;nkung beim Drucken mit der Java Communications API</a></div>
<div class="head2"><a id="ToC_126" name="ToC_126" href="#javacomm_lnx_remove" class="toclink">Deinstallieren der Java Communications API</a></div>
<div class="head3"><a id="ToC_127" name="ToC_127" href="#javacomm_redhat_remove" class="toclink">Deinstallieren des RPM-Pakets (Red Hat Package Manager)</a></div>
<div class="head3"><a id="ToC_128" name="ToC_128" href="#javacomm_tar_remove" class="toclink">Deinstallieren des komprimierten TAR-Pakets (Tape Archive)</a></div>
<div class="head2"><a id="ToC_129" name="ToC_129" href="#javacomm_apidoc" class="toclink">Dokumentation zur Java Communications API</a></div>
<div class="head1"><a id="ToC_130" name="ToC_130" href="#support" class="toclink">Service und Unterst&uuml;tzung f&uuml;r unabh&auml;ngige Softwareanbieter</a></div>
<div class="head1"><a id="ToC_131" name="ToC_131" href="#accessibility" class="toclink">Eingabehilfen</a></div>
<div class="head2"><a id="ToC_132" name="ToC_132" href="#access_keyboard" class="toclink">Verschieben des Eingabefokus von JComboBox-Komponenten in Swing per Tastatur</a></div>
<div class="head2"><a id="ToC_133" name="ToC_133" href="#access_webstart" class="toclink">Web Start-Eingabehilfen (nur Linux IA 32 Bit, PPC32 und PPC64)</a></div>
<div class="head1"><a id="ToC_134" name="ToC_134" href="#rcf" class="toclink">Kommentare zu diesem Handbuch</a></div>
<div class="head1"><a id="ToC_135" name="ToC_135" href="#xoptions" class="toclink">Anhang A. Vom Standard abweichende Optionen</a></div>
<div class="head1"><a id="ToC_136" name="ToC_136" href="#limitations" class="toclink">Anhang B. Bekannte Einschr&auml;nkungen</a></div>
<div class="head1"><a id="ToC_170" name="ToC_170" href="#notices" class="toclink">Bemerkungen</a></div>
<div class="head2"><a id="ToC_171" name="ToC_171" href="#trademarks" class="toclink">Marken</a></div>
</div>
<a name="preface"></a>
<h1 id="preface"><a href="#ToC_1">Vorwort</a></h1>
<div>
<p>In diesem Benutzerhandbuch erhalten Sie allgemeine Informationen zu IBM SDK and Runtime Environment for Linux platforms, Java Technology
Edition, Version 6 sowie spezielle Informationen zu allen Unterschieden zwischen der IBM Implementierung und der Sun-Implementierung.</p></div>
<p>Lesen Sie dieses Benutzerhandbuch zusammen mit der ausf&uuml;hrlicheren Dokumentation auf der folgenden
Website von Sun Microsystems: <a href="http://java.sun.com" target="_blank">http://java.sun.com</a>.</p>
<p>Unter der folgenden Adresse finden Sie eine Liste der Distributionen, unter denen SDK und Runtime Environment for Linux getestet wurden: <a href="http://www.ibm.com/developerworks/java/jdk/linux/tested.html" target="_blank">http://www-106.ibm.com/developerworks/java/jdk/linux/tested.html</a></p>
<p><strong>(Nur Intel-32-Bit-Plattformen) </strong>Diese virtualisierten Umgebungen werden unterst&uuml;tzt:
</p>
<ul>
<li>VMWare</li>
<li>Xen</li>
<li>Microsoft Virtual
Server</li></ul>
<p>Das Handbuch <a href="http://www.ibm.com/developerworks/java/jdk/diagnosis/60.html" target="_blank">Diagnostics
Guide</a> enth&auml;lt weitere Informationen zu
IBM Virtual Machine f&uuml;r Java.</p>
<p>Dieses Handbuch ist Teil eines Releases und ist nur auf dieses bestimmte Release anwendbar. Stellen Sie sicher, dass Sie das f&uuml;r das Release entsprechende Handbuch verwenden.</p>
<p>Die Begriffe "Runtime Environment" und "Java Virtual Machine" sind in diesem Handbuch gleichbedeutend.</p>
<p><font color="RED"><span id="changed">|</span>Technische &Auml;nderungen, die f&uuml;r diese Version des Benutzerhandbuchs vorgenommen wurden, sind mit Ausnahme von unwichtigen oder offensichtlichen &Auml;nderungen mit blauen Winkeln gekennzeichnet, wenn sie in einem Information Center angezeigt werden, oder rot mit vertikalen Balken links neben den &Auml;nderungen, wenn sie als HTML-Datei angezeigt oder als Farbkopie ausgedruckt werden. Werden sie im PDF-Format angezeigt, wird mit vertikalen Balken am linken Rand auf die &Auml;nderungen hingewiesen.</font></p>
<p>Der Programmcode wurde nicht f&uuml;r die Verwendung in Echtzeitanwendungen wie z.&nbsp;B.
den folgenden entworfen und ist nicht f&uuml;r diese bestimmt: Onlinesteuerung von Flugzeugen, Flugverkehr, Flugzeugnavigation oder Kommunikation im Flugverkehr sowie Entwurf, Konstruktion, Betrieb oder Instandhaltung von nuklearen Einrichtungen (Liste kann erweitert werden).</p>
<a name="overview"></a>
<h1 id="overview"><a href="#ToC_2">&Uuml;bersicht</a></h1>
<div>
<p>Bei IBM SDK handelt es sich um eine Entwicklungsumgebung zum Schreiben und Ausf&uuml;hren von Applets und Anwendungen, die der Java 6 Core-API (Application Programming Interface - Anwendungsprogrammierschnittstelle) entsprechen.</p></div>
<p>Das SDK umfasst Runtime Environment for Linux. Mit dieser Komponente k&ouml;nnen Sie nur Java-Anwendungen ausf&uuml;hren. Wenn Sie das SDK installiert haben, ist auch Runtime Environment enthalten.</p>
<p>Runtime Environment enth&auml;lt Java Virtual Machine sowie unterst&uuml;tzende Dateien, wie z.&nbsp;B. Dateien mit der Erweiterung '.so', bei denen kein Debugging m&ouml;glich ist, und Klassendateien. Runtime Environment enth&auml;lt nur eine Untergruppe der Klassen, die im SDK enthalten sind. Mit dieser Komponente k&ouml;nnen Sie ein Java-Programm w&auml;hrend der Laufzeit verwenden; Sie haben jedoch nicht die M&ouml;glichkeit, Java-Programme zu kompilieren. Runtime Environment for Linux enth&auml;lt kein Entwicklungstool, wie z.&nbsp;B. <strong>appletviewer</strong> oder den Java-Compiler (<strong>javac</strong>), bzw. keine Klassen, die nur f&uuml;r Entwicklungssysteme konzipiert sind.</p>
<p>Au&szlig;erdem wird das Paket mit der Java Communications API f&uuml;r IA32-, PPC32/PPC64 und AMD64/EM64T-Plattformen zur Verwendung mit Runtime Environment for Linux bereitgestellt. Informationen hierzu finden Sie unter <a href="#jcommchapter">Verwenden der Java Communications API (JavaComm)</a>.</p>
<p>Die Datei license_<em>xx</em>.html enth&auml;lt die Lizenzvereinbarung f&uuml;r die
Runtime Environment for Linux-Software, wobei <em>xx</em> eine Abk&uuml;rzung f&uuml;r die Sprache darstellt. &Ouml;ffnen Sie diese Datei in einem Web-Browser, um die Lizenzvereinbarung anzuzeigen oder zu drucken.</p>
<a name="lnx_conventions"></a>
<h2 id="lnx_conventions"><a href="#ToC_3">Konventionen</a></h2>
<div>
<p>In diesem Handbuch lautet das Standardinstallationsverzeichnis des SDK /opt/ibm/java-i386-60/.
Wenn Sie nicht Linux IA 32 Bit verwenden, ist das Standardinstallationsverzeichnis ein anderes.</p></div>
<p>Die hier aufgef&uuml;hrten Plattformen haben verschiedene Standardinstallationsverzeichnisse. Verwenden Sie das f&uuml;r Ihre Plattform entsprechende Verzeichnis, wenn /opt/ibm/java-i386-60/ angezeigt wird: 
</p>
<ul>
<li>Linux IA
32 Bit: /opt/ibm/java-i386-60/</li>
<li>Linux AMD
64 Bit: /opt/ibm/java-x86_64-60/</li>
<li>Linux PPC
32 Bit: /opt/ibm/java-ppc-60/</li>
<li>Linux PPC
64 Bit: /opt/ibm/java-ppc64-60/</li>
<li>Linux System
z 31 Bit: /opt/ibm/java-s390-60/</li>
<li>Linux System
z 64 Bit: /opt/ibm/java-s390x-60/</li></ul>
<p>In den Beispielen in diesem Benutzerhandbuch werden Korn-Shellbefehle verwendet.</p>
<a name="compatibility"></a>
<h2 id="compatibility"><a href="#ToC_4">Versionskompatibilit&auml;t</a></h2>
<div>
<p>Normalerweise m&uuml;ssten alle Applets
oder Anwendungen, die mit einer Vorversion von SDK ausgef&uuml;hrt wurden, zusammen mit
IBM SDK for Linux Version 6 ordnungsgem&auml;&szlig; ausgef&uuml;hrt werden.
F&uuml;r Klassen, die auf der Grundlage dieses Releases kompiliert wurden, kann nicht garantiert werden, dass sie zusammen mit fr&uuml;heren Releases eingesetzt werden k&ouml;nnen.</p></div>
<p>Weitere Informationen zu Kompatibilit&auml;tsproblemen zwischen Releases finden Sie auf den folgenden Sun-Websites unter:</p>
<p><a href="http://java.sun.com/javase/6/webnotes/compatibility.html" target="_blank"><font color="RED"><span id="changed">|</span>http://java.sun.com/javase/6/webnotes/compatibility.html</font></a></p>
<p><a href="http://java.sun.com/j2se/5.0/compatibility.html" target="_blank">http://java.sun.com/j2se/5.0/compatibility.html</a></p>
<p><a href="http://java.sun.com/j2se/1.4/compatibility.html" target="_blank">http://java.sun.com/j2se/1.4/compatibility.html</a></p>
<p><a href="http://java.sun.com/j2se/1.3/compatibility.html" target="_blank">http://java.sun.com/j2se/1.3/compatibility.html</a></p>
<p>Wenn Sie das SDK als Teil eines anderen Produkts verwenden (z.&nbsp;B. von IBM WebSphere Application
Server) und von einer fr&uuml;heren Version des SDK aus ein Upgrade durchf&uuml;hren, z.&nbsp;B. von Version 5.0, sind serialisierte Klassen m&ouml;glicherweise nicht kompatibel. Klassen verschiedener Serviceaktualisierungen sind jedoch miteinander kompatibel.</p>
<a name="migrating"></a>
<h2 id="migrating"><a href="#ToC_5">Migrieren von weiteren IBM JVMs</a></h2>
<div>
<p>Ab Version 5.0 enth&auml;lt IBM Runtime Environment for Linux neue Versionen von IBM Virtual Machine for Java und des JIT-Compilers (JIT - Just-in-Time).</p></div>
<p>Wenn Sie von einer &auml;lteren
IBM Runtime Environment-Version migrieren, beachten Sie Folgendes:</p>
<ul>
<li>Die gemeinsam genutzte JVM-Bibliothek libjvm.so ist nun in
jre/lib/&lt;Architektur&gt;/j9vm
und jre/lib/&lt;Architektur&gt;/classic gespeichert, was der Organisation von Sun Java Virtual Machine mehr entspricht.</li>
<li>Ab Version 5.0 ist die JVMMI (JVM Monitoring Interface) nicht mehr verf&uuml;gbar. Sie m&uuml;ssen JVMMI-Anwendungen neu schreiben, um stattdessen die JVMTI (JVM Tool Interface) zu verwenden. Die JVMTI entspricht funktional nicht der JVMMI. Weitere Informationen zu JVMTI finden Sie unter <a href="http://java.sun.com/javase/6/docs/technotes/guides/jvmti/" target="_blank">http://java.sun.com/javase/6/docs/technotes/guides/jvmti/</a> und im Handbuch <a href="http://www.ibm.com/developerworks/java/jdk/diagnosis/60.html" target="_blank">Diagnostics Guide</a>.</li>
<li>Ab Version 5.0 entspricht die neue Implementierung von JNI der JNI-Spezifikation, unterscheidet sich jedoch von der Implementierung der Version 1.4.2.
Sie gibt Kopien der Objekte zur&uuml;ck, anstatt die urspr&uuml;nglichen Objekte im Speicher zu belassen. Dieser Unterschied kann zu Fehlern im JNI-Anwendungscode f&uuml;hren. Informationen zum Debugging von JNI-Code finden Sie unter <strong>-Xcheck:jni</strong> in <a href="#xoptions">Anhang A. Vom Standard abweichende Optionen</a>.</li>
<li>Ab Version 5.0 wurden Format und Inhalt von ausf&uuml;hrlichen Garbage-Collector-Protokollen ge&auml;ndert, die mit Hilfe von <strong>-verbose:gc</strong> empfangen wurden. Die Daten weisen jetzt das XML-Format auf. Der Dateninhalt zeigt die &Auml;nderungen der Implementierung der Garbage-Collection in JVM an. Die meisten statistischen Ausgabedaten wurden ge&auml;ndert. Sie m&uuml;ssen alle Programme &auml;ndern, die die ausf&uuml;hrliche GC-Ausgabe verarbeiten, damit diese Programme mit dem neuen Format und den neuen Daten funktionieren. Im Handbuch <a href="http://www.ibm.com/developerworks/java/jdk/diagnosis/60.html" target="_blank">Diagnostics Guide</a> finden Sie ein Beispiel der neuen ausf&uuml;hrlichen GC-Daten.</li>
<li>SDK 1.4-Versionen von IBM JRE umfassten spezifische Klassen f&uuml;r JVM, die in einer Datei mit dem Namen 'core.jar' enthalten waren. Ab Version 5.0 sind diese Klassen in einer Datei mit dem Namen vm.jar enthalten.</li>
<li>Fr&uuml;here IBM JRE-Versionen umfassten eine Datei mit dem Namen rt.jar im Verzeichnis jre/lib. Ab Version 1.4 wurde diese Datei durch mehrere JAR-Dateien im Verzeichnis jre/lib ersetzt.</li>
<li><font color="RED"><span id="changed">|</span>Weitere Informationen zur Kompatibilit&auml;t und zu veralteten APIs in Bezug auf Sun-Java-Releases finden Sie in <a href="http://java.sun.com/javase/6/webnotes/compatibility.html" target="_blank">Sun's Java 6 Compatibility Documentation</a> und <a href="http://java.sun.com/javase/6/docs/api/deprecated-list.html" target="_blank">Sun's Java 6 Deprecated API List</a>.</font></li>
<li>Die Tracefunktion f&uuml;r Klassenabh&auml;ngigkeiten, die mit Hilfe von <strong>-verbose:Xclassdep</strong> aufgerufen wird, wird nicht unterst&uuml;tzt. Wenn Sie <strong>-verbose:Xclassdep</strong> angeben, zeigt JVM eine Fehlernachricht an und startet nicht.</li></ul>
<a name="zhardware"></a>
<h2 id="zhardware"><a href="#ToC_6">Unterst&uuml;tzte Hardware f&uuml;r System z</a></h2>
<div>
<p>Die 31-Bit- und 64-Bit-SDKs und Runtime Environments von System z werden auf System
z9- und zSeries-Hardware ausgef&uuml;hrt.</p></div>
<p>Die SDKs und Runtime Environments werden auf den folgenden Servern oder funktional entsprechenden Servern ausgef&uuml;hrt:
</p>
<ul>
<li>z9-109</li>
<li>z990</li>
<li>z900</li>
<li>z890</li>
<li>z800</li></ul>
<a name="contents_sdk"></a>
<h1 id="contents_sdk"><a href="#ToC_7">Inhalt von SDK und Runtime Environment</a></h1>
<div>
<p>SDK enth&auml;lt mehrere Entwicklungstools und Java Runtime Environment (JRE). Dieser Abschnitt enth&auml;lt Erl&auml;uterungen zum Inhalt der SDK-Tools und von Runtime Environment.</p></div>
<p>Anwendungen, die vollst&auml;ndig in Java geschrieben sind, d&uuml;rfen <strong>keine</strong> Abh&auml;ngigkeiten von der IBM SDK-Verzeichnisstruktur (oder Dateien in diesen Verzeichnissen) aufweisen. Abh&auml;ngigkeiten von der SDK-Verzeichnisstruktur (oder den Dateien in diesen Verzeichnissen) k&ouml;nnte zu Fehlern bei der Portierbarkeit von Anwendungen f&uuml;hren.</p>
<p>SDK for Linux enth&auml;lt lediglich die Benutzerhandb&uuml;cher, die Javadoc-Komponente und die zugeh&ouml;rigen Lizenzdateien, die zugeh&ouml;rigen Copyrightdateien, das Javadoc-Verzeichnis und das Demoverzeichnis. Sie k&ouml;nnen die Sun-Softwaredokumentation &uuml;ber die Sun-Website aufrufen oder das Dokumentationspaket zur Sun-Software &uuml;ber die Sun-Website herunterladen: <a href="http://java.sun.com" target="_blank">http://java.sun.com</a>.</p>
<a name="jretools"></a>
<h2 id="jretools"><a href="#ToC_8">Runtime Environment-Klassen und -Tools</a></h2>
<div>
<p>Eine Liste von Klassen und Tools, die Sie mit der Standardversion von Runtime Environment verwenden k&ouml;nnen.</p></div>
<p></p>
<ul>
<li>Wichtige Klassen - Dies sind die kompilierten Klassendateien f&uuml;r die Plattform. Sie m&uuml;ssen komprimiert bleiben, damit der Compiler und der Interpreter auf sie zugreifen k&ouml;nnen. &Auml;ndern Sie diese Klassen nicht, sondern erstellen Sie stattdessen Unterklassen, und &uuml;berschreiben Sie diese, falls erforderlich.</li>
<li>JRE-Tools - Die folgenden Tools sind Teil von Runtime Environment. Sofern nichts anderes angegeben ist, befinden sie sich im Verzeichnis /opt/ibm/java-i386-60/jre/bin.

<dl class="parml">
<dt class="bold">ikeyman (iKeyman-GUI-Dienstprogramm)</dt>
<dd>Erm&ouml;glicht das Verwalten von Schl&uuml;sseln, Zertifikaten und Zertifikatsanforderungen. Weitere Informationen finden Sie im zugeh&ouml;rigen Handbuch <em>Security Guide</em> und unter <a href="http://www.ibm.com/developerworks/java/jdk/security" target="_blank">http://www.ibm.com/developerworks/java/jdk/security</a>.
Das SDK enth&auml;lt auch eine Befehlszeilenversion dieses Dienstprogramms.
</dd>
<dt class="bold">java (Java-Interpreter)</dt>
<dd>F&uuml;hrt Java-Klassen aus. Der Java-Interpreter f&uuml;hrt Programme aus, die in der Programmiersprache Java geschrieben sind.
</dd>
<dt class="bold">javaw (Java-Interpreter)</dt>
<dd>F&uuml;hrt Java-Klassen genauso aus wie der Befehl <strong>java</strong>, verwendet jedoch kein Konsolfenster.
</dd>
<dt class="bold"><strong><span class="bold-italic">(Nur Linux IA 32 Bit, PPC32 und PPC64) </span></strong>javaws (Java Web Start)</dt>
<dd>Erm&ouml;glicht die Implementierung und automatische Verwaltung von Java-Anwendungen.
Weitere Informationen finden Sie unter <a href="#installing_webstart">Ausf&uuml;hren von Java Web Start</a>.
</dd>
<dt class="bold">jextract (Extrahierungsprogramm f&uuml;r Speicherausz&uuml;ge)</dt>
<dd>Konvertiert einen vom System erstellten Speicherauszug in ein einheitliches Format, das von jdmpview verwendet werden kann. Weitere Informationen finden Sie unter <a href="#sdktools__jdmpview">jdmpview</a>.
</dd>
<dt class="bold">keytool (Tool f&uuml;r das Schl&uuml;ssel- und Zertifikatmanagement)</dt>
<dd>Verwaltet einen Schl&uuml;sselspeicher (Datenbank) mit privaten Schl&uuml;sseln und den ihnen zugeordneten X.509-Zertifikatketten, die die entsprechenden &ouml;ffentlichen Schl&uuml;ssel authentifizieren.
</dd>
<dt class="bold">kinit</dt>
<dd>Bezieht Kerberos-Ticket-Granting-Tickets und stellt sie in den Cache.
</dd>
<dt class="bold">klist</dt>
<dd>Zeigt Eintr&auml;ge im lokalen Cache f&uuml;r Berechtigungsnachweise und in der lokalen Schl&uuml;sseltabelle an.
</dd>
<dt class="bold">ktab</dt>
<dd>Verwaltet die Namen der Principals und Serviceschl&uuml;ssel, die in einer lokalen Schl&uuml;sseltabelle gespeichert sind.
</dd>
<dt class="bold">pack200</dt>
<dd>Setzt eine JAR-Datei mit Hilfe des Java-Komprimierungsprogramms 'gzip' in eine komprimierte pack200-Datei um.
</dd>
<dt class="bold">policytool (Tool f&uuml;r die Erstellung und Verwaltung von Richtliniendateien)</dt>
<dd>Erstellt und &auml;ndert die externen Richtlinienkonfigurationsdateien, die die Java-Sicherheitsrichtlinie Ihrer Installation definieren.
</dd>
<dt class="bold">rmid (Systemd&auml;mon f&uuml;r die RMI-Aktivierung)</dt>
<dd>Startet den Aktivierungssystemd&auml;mon, so dass Objekte in JVM (Java Virtual Machine) registriert und aktiviert werden k&ouml;nnen.
</dd>
<dt class="bold">rmiregistry (Java-Registrierungsdatenbank f&uuml;r ferne Objekte)</dt>
<dd>Erstellt und startet eine Registrierungsdatenbank f&uuml;r ferne Objekte an dem angegebenen Port des aktuellen Hosts.
</dd>
<dt class="bold">tnameserv (CORBA Transient Naming Service (CORBA - Common Object Request Broker Architecture))</dt>
<dd>Startet den CORBA Transient Naming Service.
</dd>
<dt class="bold">unpack200</dt>
<dd>Setzt eine von pack200 erzeugte gepackte Datei in eine JAR-Datei um.
</dd>
</dl></li></ul>
<a name="sdktools"></a>
<h2 id="sdktools"><a href="#ToC_9">SDK-Tools und -Referenzinformationen</a></h2>
<div>
<p>Eine Liste von Tools und Referenzinformationen, die zum Lieferumfang der Standardversion des SDK geh&ouml;rt.</p></div>
<p></p>
<dl class="parml">
<dt class="bold">Die folgenden Tools sind Teil des SDK und befinden sich im Verzeichnis /opt/ibm/java-i386-60/bin:</dt>
<dd>
<dl class="parml">
<dt class="bold">appletviewer (Java Applet Viewer)</dt>
<dd>Testet und f&uuml;hrt Applets au&szlig;erhalb eines Web-Browsers aus.
</dd>
<dt class="bold">apt (Tool zur Verarbeitung von Annotationen)</dt>
<dd>Sucht und f&uuml;hrt Annotationsprozessoren aus, basierend auf den Annotationen, die in der Gruppe der angegebenen, zu untersuchenden Quellendateien vorhanden sind.
</dd>
<dt class="bold">extcheck (Extcheck-Dienstprogramm)</dt>
<dd>Stellt Versionskonflikte zwischen einer JAR-Zieldatei und neu installierten JAR-Erweiterungsdateien fest.
</dd>
<dt class="bold"><strong><span class="bold-italic">(Nur Linux IA 32 Bit, PPC32 und PPC64) </span></strong>HtmlConverter (Java Plug-in HTML Converter)</dt>
<dd>Konvertiert eine HTML-Seite, in der Applets enthalten sind, in ein Format, das das Java Plug-in verwenden kann.
</dd>
<dt class="bold">idlj (IDL f&uuml;r Java-Compiler) </dt>
<dd>Generiert Java-Bindungen &uuml;ber eine festgelegte IDL-Datei.
</dd>
<dt class="bold">ikeycmd (iKeyman-Befehlszeilendienstprogramm)</dt>
<dd>Erm&ouml;glicht das Verwalten von Schl&uuml;sseln, Zertifikaten und Zertifikatsanforderungen &uuml;ber die Befehlszeile. Weitere Informationen finden Sie im zugeh&ouml;rigen Handbuch <em>Security Guide</em> und unter <a href="http://www.ibm.com/developerworks/java/jdk/security" target="_blank">http://www.ibm.com/developerworks/java/jdk/security</a>.
</dd>
<dt class="bold">jar (Java-Archivierungstool)</dt>
<dd>Kombiniert mehrere Dateien in einer einzelnen JAR-Datei (Java Archive).
</dd>
<dt class="bold">jarsigner (Tool zur JAR-Signierung und -Pr&uuml;fung)</dt>
<dd>Generiert Signaturen f&uuml;r JAR-Dateien und pr&uuml;ft die Signaturen der signierten JAR-Dateien.
</dd>
<dt class="bold">java-rmi.cgi (HTTP-zu-CGI-Anforderungsweiterleitungstool)</dt>
<dd>Akzeptiert RMI-&uuml;ber-HTTP-Anforderungen und leitet diese an einen RMI-Server weiter, der an einem beliebigen Port empfangsbereit ist.
</dd>
<dt class="bold">javac (Java-Compiler) </dt>
<dd>Kompiliert Programme, die in der Programmiersprache Java in Bytecodes (kompilierter Java-Code) geschrieben werden.
</dd>
<dt class="bold">javadoc (Java-Dokumentationsgenerator)</dt>
<dd>Generiert HTML-Seiten der API-Dokumentation &uuml;ber Java-Quellendateien.
</dd>
<dt class="bold">javah (C-Header- und Stubdateigenerator)</dt>
<dd>Erm&ouml;glicht die Zuordnung nativer Methoden zu Code, der in der Programmiersprache Java geschrieben wurde.
</dd>
<dt class="bold">javap (Disassembler f&uuml;r Klassendateien)</dt>
<dd>Zerlegt kompilierte Dateien und kann eine Darstellung der Bytecodes drucken.
</dd>
<dt class="bold">javaw (Java-Interpreter)</dt>
<dd>F&uuml;hrt Java-Klassen genauso aus wie der Befehl <strong>java</strong>, verwendet jedoch kein Konsolfenster.
</dd>
<dt class="bold"><strong><span class="bold-italic">(Nur Linux IA 32 Bit, PPC32 und PPC64) </span></strong>javaws (Java Web Start)</dt>
<dd>Erm&ouml;glicht die Implementierung und automatische Verwaltung von Java-Anwendungen.
Weitere Informationen finden Sie unter <a href="#installing_webstart">Ausf&uuml;hren von Java Web Start</a>.
</dd>
<dt class="bold">jconsole (JConsole - &Uuml;berwachungs- und Verwaltungstool)</dt>
<dd>&Uuml;berwacht lokale und ferne JVMs mit Hilfe einer grafischen Benutzerschnittstelle. JMX-kompatibel.
</dd>
<dt class="bold">jdb (Java-Debugger)</dt>
<dd>Hilft beim Debugging Ihres Java-Programms.
</dd>
<dt class="bold"><a id="sdktools__jdmpview" name="sdktools__jdmpview"></a>jdmpview (plattformunabh&auml;ngiges Formatierprogramm f&uuml;r Speicherausz&uuml;ge)</dt>
<dd>Analysiert Speicherausz&uuml;ge. Weitere Informationen finden Sie im Handbuch <a href="http://www.ibm.com/developerworks/java/jdk/diagnosis/60.html" target="_blank">Diagnostics Guide</a>.
</dd>
<dt class="bold">native2ascii (Native-zu-ASCII-Converter)</dt>
<dd>Konvertiert eine native Codierungsdatei in eine ASCII-Datei, die Zeichen enth&auml;lt, die in Latin-1 und/oder Unicode codiert sind.
</dd>
<dt class="bold">rmic (Java-RMI-Stub-Converter (RMI - Remote Method Invocation))</dt>
<dd>Generiert Stubs, Entw&uuml;rfe und Ties f&uuml;r ferne Objekte. Umfasst Unterst&uuml;tzung f&uuml;r RMI-IIOP
(RMI over Internet Inter-ORB Protocol).
</dd>
<dt class="bold">schemagen</dt>
<dd>Erstellt eine Schemadatei f&uuml;r jeden Namensbereich, der in Ihren Java-Klassen angegeben ist.
</dd>
<dt class="bold">serialver (Befehl f&uuml;r serialisierte Version)</dt>
<dd>Wandelt die serialVersionUID f&uuml;r mindestens eine Klasse in ein Format um, das in eine Klasse kopiert werden kann, die sich in einer zuk&uuml;nftigen Version &auml;ndert.
</dd>
<dt class="bold">wsgen</dt>
<dd>Generiert portierbare JAX-WS-Artefakte, die in JAX-WS-Web-Services verwendet werden.
</dd>
<dt class="bold">wsimport</dt>
<dd>Generiert portierbare JAX-WS-Artefakte aus einer WSDL-Datei.
</dd>
<dt class="bold">xjc</dt>
<dd>Kompiliert XML-Schemadateien.
</dd>
</dl>
</dd>
<dt class="bold">Include-Dateien</dt>
<dd>C-Header f&uuml;r JNI-Programme.
</dd>
<dt class="bold">Demos</dt>
<dd>Das Verzeichnis 'demo' enth&auml;lt mehrere Unterverzeichnisse, in denen
Musterquellcode, Demos, Anwendungen und Applets enthalten sind, die Sie verwenden k&ouml;nnen. <span><font color="RED"><span id="changed">|</span>Ab Version 6 ist die RMI-IIOP-Demo nicht mehr im SDK enthalten.</font></span>
</dd>
<dt class="bold">Copyright</dt>
<dd>Der Copyrightvermerk f&uuml;r die SDK for Linux-Software.
</dd>
<dt class="bold">Lizenz</dt>
<dd>
<p>Die Lizenzdatei
/opt/ibm/java-i386-60/docs/content/<em>&lt;L&auml;ndereinstellung&gt;</em>/LA_<em>&lt;L&auml;ndereinstellung&gt;</em>
enth&auml;lt die Lizenzvereinbarung f&uuml;r die SDK for Linux-Software (wobei <em>&lt;L&auml;ndereinstellung&gt;</em> die Bezeichnung Ihrer L&auml;ndereinstellung ist, wie z.&nbsp;B. de). &Ouml;ffnen Sie diese Datei in einem Web-Browser, um die Lizenzvereinbarung anzuzeigen oder zu drucken.</p>
</dd>
</dl>
<a name="lin_install_config"></a>
<h1 id="lin_install_config"><a href="#ToC_10">Installieren und Konfigurieren von SDK und Runtime Environment</a></h1>
<div>
<p>Sie k&ouml;nnen IBM Java SDK und Runtime Environment entweder aus einer RPM- oder .tgz-Datei installieren. Sofern Sie nicht allen Benutzern des Systems den Zugriff auf diese Java-Installation erlauben wollen, f&uuml;hren Sie die Installation anhand der .tgz-Datei durch.
Wenn Sie nicht &uuml;ber Rootberechtigung verf&uuml;gen, verwenden Sie die .tgz-Datei.</p></div>
<p>Wenn Sie die Installation mit Hilfe einer RPM-Datei ausf&uuml;hren, werden die Java-Dateien im Verzeichnis /opt/ibm/java-i386-60/ installiert.
Bei den Beispielen in diesem Handbuch wird vorausgesetzt, dass Sie Java in diesem Verzeichnis installiert haben.</p>
<a name="upgrading"></a>
<h2 id="upgrading"><a href="#ToC_11">Ausf&uuml;hren eines Upgrades f&uuml;r SDK</a></h2>
<div>
<p>Wenn Sie ein Upgrade von einem fr&uuml;heren SDK-Release ausf&uuml;hren, sichern Sie alle Konfigurations- und Sicherheitsrichtliniendateien, bevor Sie das Upgrade starten.</p></div>
<p>
<p>Nach dem Ausf&uuml;hren des Upgrades m&uuml;ssen Sie diese Dateien eventuell wiederherstellen oder neu konfigurieren, da sie beim Upgradeprozess m&ouml;glicherweise &uuml;berschrieben wurden. Pr&uuml;fen Sie die Syntax der neuen Dateien, bevor Sie die urspr&uuml;nglichen Dateien wiederherstellen, da sich das Format oder die Optionen f&uuml;r die Dateien ge&auml;ndert haben k&ouml;nnen.</p></p>
<a name="installredhat4"></a>
<h2 id="installredhat4"><a href="#ToC_12">Installieren unter Red Hat Enterprise Linux (RHEL) 4</a></h2>
<div>
<p>Das SDK ist von gemeinsam genutzten Bibliotheken abh&auml;ngig, die nicht standardm&auml;&szlig;ig f&uuml;r Red Hat Enterprise Linux (RHEL) installiert sind.</p></div><a id="idx1" name="idx1"></a><a id="idx2" name="idx2"></a>
<p>
<p>Bei RHEL 4 sind diese Bibliotheken in folgenden RPM-Dateien enthalten:</p></p>
<ul>
<li><tt class="xph">compat-libstdc++-33-3.2.3</tt> und <tt class="xph">xorg-x11-deprecated-libs-6.8.1</tt>
(alle Plattformen au&szlig;er zSeries)</li>
<li><tt class="xph">compat-libstdc++-295-2.95.3</tt> und <tt class="xph">xorg-x11-deprecated-libs-6.8.1</tt> (zSeries)</li></ul>
<p>Gehen Sie wie folgt vor, um diese Bibliotheken bei der Installation von RHEL 4 einzuschlie&szlig;en:</p>
<ol type="1">
<li>W&auml;hlen Sie <strong>Customize the set of packages to be installed</strong> in der Anzeige <strong>Package Defaults</strong> aus.</li>
<li>W&auml;hlen Sie <strong>Details</strong> unter <strong>X Windows System</strong> in der Anzeige <strong>Package Group Selection</strong> aus, und stellen Sie sicher, dass Sie
<tt class="xph">xorg-x11-deprecated-libs</tt> ausgew&auml;hlt haben.</li>
<li>W&auml;hlen Sie aus den <strong>Development</strong>-Optionen <strong>Legacy
Software Development</strong> aus.</li></ol>
<a name="installredhat5"></a>
<h2 id="installredhat5"><a href="#ToC_13">Installieren unter Red Hat Enterprise Linux (RHEL) 5</a></h2>
<div>
<p>Das SDK ist von gemeinsam genutzten Bibliotheken abh&auml;ngig, die nicht standardm&auml;&szlig;ig f&uuml;r Red Hat Enterprise Linux (RHEL) installiert sind.</p></div><a id="idx3" name="idx3"></a><a id="idx4" name="idx4"></a><a id="idx5" name="idx5"></a>
<p>
<p>Bei RHEL 5 sind diese Bibliotheken in folgenden RPM-Dateien enthalten:</p></p>
<ul>
<li><tt class="xph">libXp-1.0.0-8</tt> (Alle Plattformen)</li>
<li><tt class="xph">compat-libstdc++-33-3.2.3</tt> (Alle Plattformen au&szlig;er zSeries)</li>
<li><tt class="xph">compat-libstdc++-296-2.95.3</tt>  (zSeries)</li></ul>
<p>Gehen Sie wie folgt vor, um diese Bibliotheken bei der Installation von RHEL 5 einzuschlie&szlig;en:</p>
<ol type="1">
<li>W&auml;hlen Sie <strong>Customize now</strong> in der Softwareauswahlanzeige aus.</li>
<li>W&auml;hlen Sie in der n&auml;chsten Anzeige im linken Fenster <strong>Base System</strong> aus. W&auml;hlen Sie im rechten Fenster <strong>Legacy Software Support</strong> aus.
Mit diesen Optionen werden die compat-libstdc++-Pakete installiert.</li>
<li>Das Paket 'libXp' ist erforderlich, kann aber in der grafischen Benutzerschnittstelle nicht zur Installation ausgew&auml;hlt werden. Wenn die Installation beendet ist, &ouml;ffnen Sie eine Shell, suchen das Paket
'libXp' auf den Red Hat-Installationsmedien und installieren es.
Beispiel: Geben Sie f&uuml;r die Installation auf einer 32-Bit-Intel-Plattform folgenden Befehl ein: <tt class="xph">rpm -i /media/cdrom/Server/libXp-1.0.0-8.i386.rpm</tt>.</li></ol>
<a name="lin_redhat_selinux"></a>
<h3 id="lin_redhat_selinux"><a href="#ToC_14">Ausf&uuml;hren von Java mit SELinux unter RHEL 5</a></h3>
<div>
<p>Zum Ausf&uuml;hren von IBM SDK for Java unter Red Hat Enterprise Linux Version 5 mit aktiviertem SELinux muss Java im Standardverzeichnis installiert werden, oder es muss ein Befehl eingegeben werden.</p></div><a id="idx6" name="idx6"></a>
<p>
<p>Wenn Java nicht im Standardverzeichnis installiert wurde, geben Sie folgenden Befehl ein: </p>
<pre class="xmp">chcon -R -t texrel_shlib_t &lt;Pfad des SDK&gt;</pre>
<p>Dabei gilt Folgendes: <tt class="xph">&lt;Pfad des SDK&gt;</tt> ist der Pfad, in dem Java installiert wurde.</p>
<p>Weitere Informationen zu SELinux finden Sie unter <a href="http://www.redhat.com/docs/manuals/enterprise/RHEL-5-manual/Deployment_Guide-en-US/ch-selinux.html" target="_blank">Introduction to SELinux</a> in der Red Hat-Dokumentation.</p></p>
<a name="lin_install"></a>
<h2 id="lin_install"><a href="#ToC_15">Installieren eines 32-Bit-SDK auf einer 64-Bit-Architektur</a></h2>
<div>
<p>Zum Ausf&uuml;hren des SDK m&uuml;ssen Sie die richtigen Versionen (32 oder 64 Bit) aller f&uuml;r das SDK erforderlichen Bibliotheken installieren.</p></div>
<p>
<p>Bei RHEL4 sind die 64-Bit-Versionen der Pakete in der Paketgruppe <strong>Compatibility Arch Support</strong> verf&uuml;gbar.</p>
<p>Sie k&ouml;nnen mit dem Tool RPM &uuml;berpr&uuml;fen, welche Versionen der Pakete installiert sind. F&uuml;gen Sie dazu
die Option <tt class="xph">--queryformat "%{NAME}.%{ARCH}\n"</tt> an den Befehl RPM an. Beispiel:</p></p>
<pre class="xmp">/home/username : rpm --queryformat "%{NAME}.%{ARCH}\n" -q libstdc++
libstdc++.x86_64
libstdc++.i386</pre>
<a name="lin_rpm_install"></a>
<h2 id="lin_rpm_install"><a href="#ToC_16">Installieren aus einer RPM-Datei</a></h2>
<div>
<p>Eine Prozedur f&uuml;r die Installation aus einer RPM-Datei.</p></div>
<p>Zum Durchf&uuml;hren eines Upgrade von JVM mit dem Tool 'rpm' m&uuml;ssen Sie die vorherige Version deinstallieren. M&ouml;chten Sie zwei Versionen von JVM an unterschiedlichen Speicherpositionen installieren, verwenden Sie die rpm-Option '--force', um den Versionskonflikt zu ignorieren, oder installieren Sie JVM aus der .tgz-Datei.</p>
<ol type="1">
<li>Rufen Sie eine Shelleingabeaufforderung auf, und stellen
Sie sicher, dass Sie als Root angemeldet sind.</li>
<li>Geben Sie an einer Shelleingabeaufforderung <tt class="xph">rpm -ivh &lt;RPM-Datei&gt;</tt> ein.  Beispiel: 


<pre class="xmp">rpm -ivh ibm-java2-&lt;Architektur&gt;-sdk-6.0-0.0.&lt;Architektur&gt;.rpm</pre>oder


<pre class="xmp">rpm -ivh ibm-java2-&lt;Architektur&gt;-jre-6.0-0.0.&lt;Architektur&gt;.rpm</pre>


<p>Dabei gilt Folgendes: <tt class="xph">&lt;Architektur&gt;</tt> stellt Ihre Architektur dar: i386, x86_64, ppc, ppc64, s390 oder s390x.</p></li></ol>
<a name="lin_tgz_install"></a>
<h2 id="lin_tgz_install"><a href="#ToC_17">Installieren aus einer .tgz-Datei</a></h2>
<div>
<p>Eine Prozedur f&uuml;r die Installation aus einer .tgz-Datei.</p></div>
<ol type="1">
<li>Erstellen Sie ein Verzeichnis zum Speichern der Java-Paketdateien. Bei den Beispielen in diesem Handbuch wird eine Installation im Verzeichnis /opt/ibm/java-i386-60/ vorausgesetzt.
Ersetzen Sie im restlichen Handbuch /opt/ibm/java-i386-60/ durch das Verzeichnis, in dem Sie Java installiert haben.</li>
<li>Geben Sie an einer Shelleingabeaufforderung <tt class="xph">tar -zxvf &lt;.tgz-Datei&gt;</tt> ein.  

<pre class="xmp">tar -zxvf ibm-java2-sdk-60-linux-&lt;Architektur&gt;.tgz</pre>oder 


<pre class="xmp">tar -zxvf ibm-java2-jre-60-linux-&lt;Architektur&gt;.tgz</pre>


<p>Dabei steht <tt class="xph">&lt;Architektur&gt;</tt> f&uuml;r Ihre Architektur:
i386, x86_64, ppc, ppc64, s390 oder s390x.</p></li>
<li>Wenn Sie SELinux (Security-Enhanced Linux) ausf&uuml;hren, m&uuml;ssen Sie die gemeinsam genutzten Java-Bibliotheken im System angeben. Geben Sie Folgendes ein:


<pre class="xmp">chcon -R -t texrel_shlib_t /opt/ibm/java2-i386-60/jre
chcon -R -t texrel_shlib_t /opt/ibm/java2-i386-60/bin
chcon -R -t texrel_shlib_t /opt/ibm/java2-i386-60/lib</pre></li></ol>
<a name="lin_jpackage_install"></a>
<h2 id="lin_jpackage_install"><a href="#ToC_18">Verwenden eines JPackage-kompatiblen Formats</a></h2>
<div>
<p>Das IBM Java-Paket ist auch in einem JPackage-kompatiblen Format verf&uuml;gbar.</p></div>
<p>
<p> Zur einfacheren Verwaltung des SDK sind dessen verschiedene Komponenten jetzt auch als separate RPM-Dateien verf&uuml;gbar:
das Java Runtime Environment-Basispaket, Development Kit, Plug-in, JDBC, Demo, Sound, Source und Fonts. Die RPM-Datei 'jpackage-utils' (unter
<a href="http://jpackage.org" target="_blank">http://jpackage.org</a> f&uuml;r den Download verf&uuml;gbar), die die Verwaltung mehrerer
Java-RPM-Dateien auf einem System erm&ouml;glicht, ist auch eine Voraussetzung f&uuml;r die IBM SDKs. Weitere Informationen zur JPackage-Spezifikation finden Sie unter <a href="http://jpackage.org" target="_blank">http://jpackage.org</a>.</p></p>
<a name="lin_config"></a>
<h2 id="lin_config"><a href="#ToC_19">Konfigurieren von SDK und
Runtime Environment f&uuml;r Linux</a></h2>
<div>
<p>Inkonsistenzen bei den Schriftartcodierungen unter Red Hat Advanced Server</p></div>
<a name="wq16"></a>
<div class="note-noindent" id="wq16">
<span class="notetitle">Anmerkung:</span> <span class="notebody"><strong><span class="bold-italic">(Nur f&uuml;r Benutzer von Linux IA 32 Bit in Chinesisch)</span></strong> Auf Grund der Inkonsistenzen bei den Schriftartcodierungen unter
Red Hat Advanced Server ist es bei der Installation f&uuml;r eine Umgebung mit Chinesisch als Standardsprache besser, zun&auml;chst Englisch als Standardsprache zu installieren und diese dann nach Abschluss der Installation in Chinesisch zu &auml;ndern. Andernfalls werden chinesische Schriftarten m&ouml;glicherweise nicht angezeigt.</span></div>
<a name="pathcons"></a>
<h3 id="pathcons"><a href="#ToC_20">Festlegen des Pfads</a></h3>
<div>
<p>Alle vorhandenen Java-Startprogramme in dem von Ihnen verwendeten Pfad werden &uuml;berschrieben, wenn Sie die
Umgebungsvariable <strong>PATH</strong> &auml;ndern.</p></div>
<p>
<p>Mit der Umgebungsvariablen <strong>PATH</strong> k&ouml;nnen unter Linux Programme und Dienstprogramme wie z.&nbsp;B. javac, java und javadoc in allen aktuellen Verzeichnissen gesucht werden. Geben Sie zum Anzeigen des aktuellen Werts der
Umgebungsvariablen <strong>PATH</strong> Folgendes an einer
Eingabeaufforderung ein: </p>
<pre class="xmp">echo $PATH</pre>
<p>Gehen Sie wie folgt vor, um die Java-Startprogramme Ihrem Pfad hinzuzuf&uuml;gen: 
</p>
<ol type="1">
<li>Editieren Sie die Shellstartdatei im Ausgangsverzeichnis (in der Regel .bashrc, je nach
der von Ihnen verwendeten Shell), und f&uuml;gen Sie der Umgebungsvariablen <strong>PATH</strong> die
absoluten Pfade hinzu. Beispiel:  
<pre class="xmp">export PATH=/opt/ibm/java-i386-60/bin:/opt/ibm/java-i386-60/jre/bin:$PATH</pre></li>
<li>Melden Sie sich erneut an, oder f&uuml;hren Sie das aktualisierte Shell-Script aus,
um die neue Umgebungsvariable <strong>PATH</strong> zu aktivieren.</li></ol></p>
<p>
<p>Nach dem Festlegen des Pfads k&ouml;nnen Sie ein Tool ausf&uuml;hren, indem Sie an einer Eingabeaufforderung
den Namen des Tools eingeben. Geben Sie beispielsweise zum Kompilieren der Datei MeineDatei.Java Folgendes an einer Eingabeaufforderung ein:</p></p>
<pre class="xmp">javac MeineDatei.Java</pre>
<a name="classpath"></a>
<h3 id="classpath"><a href="#ToC_21">Festlegen des Klassenpfades</a></h3>
<div>
<p>Der Klassenpfad teilt den SDK-Tools
(z.&nbsp;B. java, javac und javadoc)
die Speicherposition der Java-Klassenbibliotheken mit.</p></div>
<p>
<p>Sie m&uuml;ssen den Klassenpfad explizit nur in folgenden F&auml;llen festlegen: 
</p>
<ul>
<li>Sie ben&ouml;tigen eine andere Bibliothek oder Klassendatei (&auml;hnlich der, die Sie entwickeln),
und diese befindet sich nicht im aktuellen Verzeichnis.</li>
<li>Sie &auml;ndern die Speicherposition der Verzeichnisse
bin und lib, und sie befinden sich nicht mehr
im selben &uuml;bergeordneten Verzeichnis.</li>
<li>Sie wollen Anwendungen entwickeln oder ausf&uuml;hren, die unterschiedliche
Laufzeitumgebungen auf demselben System verwenden.</li></ul>
<p>Geben Sie zum Anzeigen des aktuellen Werts der Umgebungsvariable <strong>CLASSPATH</strong> an einer
Shelleingabeaufforderung folgenden Befehl ein: </p>
<pre class="xmp">  echo $CLASSPATH</pre>
<p>Wenn Sie Anwendungen entwickeln und ausf&uuml;hren wollen, die unterschiedliche Laufzeitumgebungen verwenden,
wie z.&nbsp;B. andere Versionen, die separat installiert wurden, m&uuml;ssen Sie <strong>CLASSPATH</strong>
und <strong>PATH</strong> f&uuml;r jede Anwendung explizit festlegen. Wenn Sie mehrere Anwendungen
gleichzeitig ausf&uuml;hren und unterschiedliche Laufzeitumgebungen verwenden, muss jede Anwendung
in einem separaten Befehlsfenster in einer separaten Shelleingabeaufforderung
ausgef&uuml;hrt werden.</p></p>
<a name="lin_uninstall"></a>
<h2 id="lin_uninstall"><a href="#ToC_22">Deinstallieren von SDK und Runtime Environment for Linux</a></h2>
<div>
<p>Welchen Prozess Sie zum Entfernen von SDK und Runtime Environment for Linux verwenden, h&auml;ngt vom verwendeten Installationstyp ab.</p></div>
<p>Anweisungen finden Sie unter <a href="#uninstrpm">Deinstallieren des RPM-Pakets (Red Hat Package Manager)</a> oder <a href="#uninsttar">Deinstallieren des komprimierten TAR-Pakets (Tape Archive)</a>.</p>
<a name="uninstrpm"></a>
<h3 id="uninstrpm"><a href="#ToC_23">Deinstallieren des RPM-Pakets (Red Hat Package Manager)</a></h3>
<div>
<p>Eine Prozedur zum Deinstallieren des RPM-Pakets (Red Hat Package Manager).</p></div><a id="idx7" name="idx7"></a><a id="idx8" name="idx8"></a><a id="idx9" name="idx9"></a>
<p>
<p>Gehen Sie wie folgt vor, um SDK oder Runtime Environment for Linux zu deinstallieren, wenn Sie diese als RPM-Paket installiert haben:</p></p>
<ol type="1">
<li>Geben Sie zum &Uuml;berpr&uuml;fen der installierten RPM-Pakete folgenden Befehl ein: <tt class="xph">rpm -qa | grep -i java</tt>. 

<p>Anschlie&szlig;end wird eine Liste aller installierten IBM Java-Pakete angezeigt. Beispiel:</p>
<pre class="xmp">ibm-java2-&lt;Architektur&gt;-jre-6.0-0.0.<em>&lt;Architektur&gt;</em>
ibm-java2-&lt;Architektur&gt;-sdk-6.0-0.0.<em>&lt;Architektur&gt;</em></pre>



<p>Diese Ausgabe gibt an, welche Pakete Sie mit dem Befehl <tt class="xph">rpm -e</tt> deinstallieren k&ouml;nnen. Beispiel: </p>
<pre class="xmp">rpm -e ibm-java2-&lt;Architektur&gt;-jre-6.0-0.0.<em>&lt;Architektur&gt;</em>
rpm -e ibm-java2-&lt;Architektur&gt;-sdk-6.0-0.0.<em>&lt;Architektur&gt;</em></pre>



<p>Sie k&ouml;nnen auch ein
grafisches Tool verwenden, wie beispielsweise kpackage oder yast2.</p></li>
<li>L&ouml;schen Sie das Verzeichnis, in dem Sie SDK and Runtime Environment installiert haben, aus der Anweisung <strong>PATH</strong>. </li>
<li>(Nur Linux IA
32 Bit und PPC32) Wenn Sie das Java Plug-in installiert haben, l&ouml;schen Sie die Dateien f&uuml;r das Java Plug-in aus dem Verzeichnis des Web-Browsers.</li></ol>
<a name="uninsttar"></a>
<h3 id="uninsttar"><a href="#ToC_24">Deinstallieren des komprimierten TAR-Pakets (Tape Archive)</a></h3>
<div>
<p>Eine Liste der Schritte zum L&ouml;schen des aus dem komprimierten Paket extrahierten IBM SDK for Linux Version 6.</p></div><a id="idx10" name="idx10"></a><a id="idx11" name="idx11"></a>
<ol type="1">
<li>L&ouml;schen Sie die Dateien f&uuml;r SDK oder Runtime Environment aus dem Verzeichnis, in dem Sie SDK oder Runtime Environment installiert haben.</li>
<li>L&ouml;schen Sie das Verzeichnis, in dem Sie SDK oder Runtime Environment installiert haben, aus der Anweisung <strong>PATH</strong>.</li>
<li>Melden Sie sich erneut an, oder f&uuml;hren Sie das aktualisierte Shell-Script aus,
um die neue Einstellung der Umgebungsvariablen <strong>PATH</strong> zu aktivieren.</li>
<li>(Nur Linux IA
32 Bit und AMD64/EM64T) Wenn Sie das Java Plug-in installiert haben, l&ouml;schen Sie die Dateien f&uuml;r das Java Plug-in aus dem Verzeichnis des Web-Browsers.</li></ol>
<a name="running_applications"></a>
<h1 id="running_applications"><a href="#ToC_25">Ausf&uuml;hren von Java-Anwendungen</a></h1>
<div>
<p>Java-Anwendungen k&ouml;nnen mit Hilfe des Startprogramms java oder durch JNI gestartet werden. Einstellungen werden mit Hilfe von Befehlszeilenargumenten, Umgebungsvariablen und Merkmaldateien an eine Java-Anwendung &uuml;bergeben.</p></div>
<a name="invint"></a>
<h2 id="invint"><a href="#ToC_26">Die Befehle java und javaw</a></h2>
<div>
<p>Eine kurze &Uuml;bersicht &uuml;ber die Befehle java und javaw.</p></div>
<p>
<a name="wq24"></a>
<h3 id="wq24">Zweck</h3>
<p>Mit den Tools java und javaw wird durch Starten von Java Runtime
Environment und Laden einer angegebenen Klasse eine
Java-Anwendung gestartet.</p>
<p>Der Befehl javaw ist identisch mit dem
Befehl java, au&szlig;er dass beim Verwenden des
Befehls javaw kein zugeordnetes Konsolfenster
angezeigt wird. Verwenden Sie den Befehl javaw,
wenn kein Fenster mit einer Eingabeaufforderung angezeigt werden
soll. Der Startbefehl javaw zeigt im Falle eines fehlgeschlagenen Starts ein Dialogfeld mit Fehlerinformationen an.</p></p>
<p>
<a name="wq25"></a>
<h3 id="wq25">Verwendung</h3>
<p>JVM sucht in den drei folgenden Positionsgruppen nach der urspr&uuml;nglichen Klasse (und anderen verwendeten Klassen): im Klassenpfad des Bootprogramms, in den installierten Erweiterungen und im Benutzerklassenpfad. Die nach dem Klassennamen oder JAR-Dateinamen angegebenen Argumente werden an die Hauptfunktion &uuml;bermittelt.</p>
<p>Die Befehle java und javaw haben folgende
Syntax:</p></p>
<pre class="xmp">java [ <em>Optionen</em> ] <em>&lt;Klasse&gt;</em> [ <em>Argumente ...</em> ]
java [ <em>Optionen</em> ] -jar <em>&lt;Datei.jar&gt;</em> [ <em>Argumente ...</em> ]
javaw [ <em>Optionen</em> ] <em>&lt;Klasse&gt;</em> [ Argumente ... ]
javaw [ <em>Optionen</em> ] -jar <em>&lt;Datei.jar&gt;</em> [ <em>Argumente ...</em> ]</pre>
<p>
<a name="wq26"></a>
<h3 id="wq26">Parameter</h3></p>
<dl class="parml">
<dt class="bold">[<em>Optionen</em>]</dt>
<dd>Befehlszeilenoptionen, die an die Laufzeitumgebung &uuml;bergeben werden.
</dd>
<dt class="bold"><em>&lt;Klasse&gt;</em></dt>
<dd>Systemstartklasse. Die Klasse muss eine Methode main() enthalten.
</dd>
<dt class="bold"><em>&lt;Datei.jar&gt;</em></dt>
<dd>Der Name der JAR-Datei, die aufgerufen werden soll. Sie wird nur mit der Option <strong>-jar</strong> verwendet.
Die benannte JAR-Datei muss Klassen- und Ressourcendateien f&uuml;r die Anwendung enthalten, wobei die Systemstartklasse &uuml;ber den Manifestheader f&uuml;r die Hauptklasse angegeben wird.
</dd>
<dt class="bold">[<em>Argumente ...</em>]</dt>
<dd>Befehlszeilenargumente, die an die Funktion main() der Systemstartklasse &uuml;bergeben werden sollen.
</dd>
</dl>
<a name="build_number"></a>
<h3 id="build_number"><a href="#ToC_30">Erhalten von Versionsinformationen</a></h3>
<div>
<p>Die IBM Build- und Versionsnummer f&uuml;r Ihre Java-Installation erhalten Sie mit Hilfe der Option <strong>-version</strong>. <span><font color="RED"><span id="changed">|</span>Sie k&ouml;nnen auch die Versionsnummer f&uuml;r alle jar-Dateien im Klassenpfad mit Hilfe der Option <strong>-Xjarversion</strong> abrufen.</font></span></p></div>
<ol type="1">
<li>&Ouml;ffnen Sie eine Shelleingabeaufforderung.</li>
<li>Geben Sie den folgenden Befehl ein: 
<pre class="xmp">java -version</pre> Sie werden Informationen sehen wie etwa:




<pre class="xmp">Java Version "1.6.0-internal"
Java(TM) SE Runtime Environment (Build 20070329_01)
IBM J9 VM (build 2.4, J2RE 1.6.0 IBM J9 2.4 Linux x86-32 jvmxi3260-20070326_12091 (JIT enabled)
J9VM - 20070326_12091_lHdSMR
JIT  - dev_20070326_1800
GC   - 20070319_AA)</pre>


Die pr&auml;zisen Datumsangaben f&uuml;r Builds und Versionen &auml;ndern sich.</li></ol>
<p><font color="RED"><span id="changed">|</span>
<span id="changed">|</span><p>Geben Sie den folgenden Befehl ein, um Versionsinformationen zu allen verf&uuml;gbaren
<span id="changed">|</span>jar-Dateien im Klassenpfad, im Klassenpfad des Bootprogramms und im Erweiterungsverzeichnis anzuzeigen:</p></p>
<span id="changed">|</span><pre class="xmp">Java -Xjarversion</pre>
<span id="changed">|</span><p>Sie werden Informationen sehen wie etwa:</p>
<span id="changed">|</span><pre class="xmp">...
<span id="changed">|</span>/opt/ibm/java-i386-60/jre/lib/ext/ibmpkcs11impl.jar  VERSION: 1.0 build_20070125
<span id="changed">|</span>/opt/ibm/java-i386-60/jre/lib/ext/dtfjview.jar
<span id="changed">|</span>/opt/ibm/java-i386-60/jre/lib/ext/xmlencfw.jar  VERSION: 1.00, 20061011  LEVEL: -20061011
<span id="changed">|</span>
<span id="changed">|</span>...</pre>
<span id="changed">|</span><p>Die f&uuml;r jede JAR-Datei verf&uuml;gbaren Informationen variieren und sind den
<span id="changed">|</span>Merkmalen Implementation-Version und Build-Level im Inhaltsverzeichnis der JAR-Datei entnommen.</p></font>
<a name="specifying_options"></a>
<h3 id="specifying_options"><a href="#ToC_31">Angeben von Java-Optionen und Systemmerkmalen</a></h3>
<div>
<p>Sie k&ouml;nnen Java-Optionen und Systemmerkmale in die Befehlszeile eingeben, indem Sie eine Optionsdatei oder eine Umgebungsvariable verwenden.</p></div>
<p>Diese Methoden zum Angeben von Java-Optionen sind nach der Ausf&uuml;hrungspriorit&auml;t aufgelistet:</p>
<ol type="1">
<li>Durch Angeben der Option oder des Merkmals in der Befehlszeile. Beispiel: 

<pre class="xmp">java -Dmysysprop1=tcpip -Dmysysprop2=wait -Xdisablejavadump MeineJavaKlasse</pre></li>
<li>Durch Erstellen einer Datei, die die Optionen enth&auml;lt, und Angeben der Datei in der Befehlszeile mit <strong>-Xoptionsfile=</strong><em>&lt;Datei&gt;</em>.</li>
<li>Durch Erstellen einer Umgebungsvariable mit der Bezeichnung <strong>IBM_JAVA_OPTIONS</strong>, die die Optionen enth&auml;lt. Beispiel: 

<pre class="xmp">export IBM_JAVA_OPTIONS="-Dmysysprop1=tcpip -Dmysysprop2=wait -Xdisablejavadump"</pre></li></ol>
<p>
<p>Die Optionen, die in der Befehlszeile ganz rechts stehen, haben Vorrang vor den Optionen, die ganz links stehen. Wenn Sie z.&nbsp;B. Folgendes angeben</p></p>
<pre class="xmp">java -Xint -Xjit MeineKlasse</pre>
<p>hat die Option <strong>-Xjit</strong> Vorrang.</p>
<a name="standard_options"></a>
<h3 id="standard_options"><a href="#ToC_32">Standardoptionen</a></h3>
<div>
<p>Die Definitionen f&uuml;r die Standardoptionen.</p></div><a id="idx12" name="idx12"></a><a id="idx13" name="idx13"></a><a id="idx14" name="idx14"></a><a id="idx15" name="idx15"></a><a id="idx16" name="idx16"></a><a id="idx17" name="idx17"></a><a id="idx18" name="idx18"></a><a id="idx19" name="idx19"></a><a id="idx20" name="idx20"></a><a id="idx21" name="idx21"></a><a id="idx22" name="idx22"></a><a id="idx23" name="idx23"></a><a id="idx24" name="idx24"></a><a id="idx25" name="idx25"></a><a id="idx26" name="idx26"></a>
<p></p>
<dl class="parml">
<dt class="bold"><strong>-agentlib</strong>:<em>&lt;Bibliotheksname&gt;</em>[=<em>&lt;Optionen&gt;</em>]</dt>
<dd>L&auml;dt die native Agentenbibliothek <em>&lt;Bibliotheksname&gt;</em>; z.&nbsp;B. <strong>-agentlib:hprof</strong>. Geben Sie <strong>-agentlib:jdwp=help</strong> und <strong>-agentlib:hprof=help</strong> in der Befehlszeile an, um weitere Informationen zu erhalten.
</dd>
<dt class="bold"><strong>-agentpath</strong>:<em>Bibliotheksname</em>[=<em>&lt;Optionen&gt;</em>]</dt>
<dd>L&auml;dt die native Agentenbibliothek mit dem vollst&auml;ndigen Pfadnamen.
</dd>
<dt class="bold"><strong>-cp</strong> <em>&lt;Durch</em> : <em>getrennte Verzeichnisse und ZIP- oder JAR-Dateien&gt;</em></dt>
<dd>Definiert den Suchpfad f&uuml;r Anwendungsklassen und -ressourcen. Wenn die Optionen <strong>-classpath</strong> und <strong>-cp</strong> nicht verwendet werden und die Umgebungsvariable <strong>CLASSPATH</strong> nicht definiert wurde, ist der Benutzerklassenpfad standardm&auml;&szlig;ig das aktuelle Verzeichnis (.).
</dd>
<dt class="bold"><strong>-classpath</strong> <em>&lt;Durch</em> :<em> getrennte Verzeichnisse und ZIP- oder JAR-Dateien&gt;</em></dt>
<dd>Definiert den Suchpfad f&uuml;r Anwendungsklassen und -ressourcen. Wenn die Optionen <strong>-classpath</strong> und <strong>-cp</strong> nicht verwendet werden und die Umgebungsvariable <strong>CLASSPATH</strong> nicht definiert wurde, ist der Benutzerklassenpfad standardm&auml;&szlig;ig das aktuelle Verzeichnis (.).
</dd>
<dt class="bold"><strong>-D</strong><em>&lt;Merkmalname&gt;</em>=<em>&lt;Wert&gt;</em></dt>
<dd>Definiert ein Systemmerkmal.
</dd>
<dt class="bold"><strong>-help oder -?</strong></dt>
<dd>Zeigt einen Benutzungshinweis an.
</dd>
<dt class="bold"><strong>-javaagent</strong>:<em>&lt;JAR-Pfad&gt;</em>[=<em>&lt;Optionen&gt;</em>] </dt>
<dd>L&auml;dt einen Agenten der Programmiersprache Java. Weitere Informationen finden Sie in der Dokumentation zur API java.lang.instrument.
</dd>
<dt class="bold"><strong>-jre-restrict-search</strong></dt>
<dd>Nimmt private Benutzer-JREs in die Versionssuche auf.
</dd>
<dt class="bold"><strong>-no-jre-restrict-search</strong></dt>
<dd>Schlie&szlig;t private Benutzer-JREs von der Versionssuche aus.
</dd>
<dt class="bold"><strong>-showversion</strong></dt>
<dd>Zeigt die Produktversion an und setzt den Vorgang fort.
</dd>
<dt id="standard_options__verbose" class="bold">
<a name="standard_options__verbose"></a><strong>-verbose</strong>:<em>&lt;Option&gt;</em></dt>
<dd>Aktiviert die ausf&uuml;hrliche Ausgabe. Die folgenden Optionen sind verf&uuml;gbar:

<dl class="parml">
<dt class="bold"><strong>class</strong></dt>
<dd>Schreibt f&uuml;r jede geladene Klasse einen Eintrag an 'stderr'.
</dd>
<dt class="bold"><strong>gc</strong></dt>
<dd>Schreibt Informationen zur ausf&uuml;hrlichen Garbage-Collection an 'stderr'. Verwenden Sie <a href="#xoptions__xverbosegclog"><strong>-Xverbosegclog</strong></a>, um die Ausgabe zu steuern. Weitere Informationen finden Sie im Handbuch <a href="http://www.ibm.com/developerworks/java/jdk/diagnosis/60.html" target="_blank">Diagnostics
Guide</a>.
</dd>
<dt class="bold"><strong>jni</strong></dt>
<dd>Schreibt Informationen an 'stderr', die die von der Anwendung und von JVM aufgerufenen JNI-Services beschreiben.
</dd>
<dt class="bold"><strong>sizes</strong></dt>
<dd>Schreibt Informationen an 'stderr', die die Einstellungen der aktiven Speicherbelegung beschreiben.
</dd>
<dt class="bold"><strong>stack</strong></dt>
<dd>Schreibt Informationen an 'stderr', die die Java- und C-Stack-Belegung f&uuml;r jeden Thread beschreiben.
</dd>
</dl>
</dd>
<dt class="bold"><strong>-version</strong></dt>
<dd>Zeigt die Produktversion an.
</dd>
<dt class="bold"><strong>-version</strong>:<em>&lt;Wert&gt;</em></dt>
<dd>Erfordert, dass die angegebene Version ausgef&uuml;hrt wird, z.&nbsp;B. &quot;1.5&quot;.
</dd>
<dt class="bold"><strong>-X</strong></dt>
<dd>Zeigt Hilfe f&uuml;r vom Standard abweichende Optionen an.
</dd>
</dl>
<a name="globalization"></a>
<h3 id="globalization"><a href="#ToC_33">Globalisierung des Befehls java</a></h3>
<div>
<p>Die Startprogramme java und javaw akzeptieren Argumente und Klassennamen mit beliebigen Zeichen, die im Zeichensatz der aktuellen L&auml;ndereinstellung enthalten sind. Mit Hilfe von Java-Escapezeichenfolgen k&ouml;nnen Sie auch alle im Klassennamen und in den Argumenten enthaltenen Unicode-Zeichen angeben.</p></div>
<p>F&uuml;r diesen Vorgang m&uuml;ssen Sie die Befehlszeilenoption <strong>-Xargencoding</strong> verwenden.</p>
<dl class="parml">
<dt class="bold"><strong>-Xargencoding</strong></dt>
<dd>Verwenden Sie die Argumentverschl&uuml;sselung. Verwenden Sie zum Angeben eines Unicode-Zeichens Escapezeichenfolgen
im Format <tt>\u####</tt>. Dabei ist # eine
Hexadezimalziffer (0-9, A-F).
</dd>
<dt class="bold"><strong>-Xargencoding:utf8</strong></dt>
<dd>Verwenden Sie die UTF8-Verschl&uuml;sselung.
</dd>
<dt class="bold"><strong>-Xargencoding:latin</strong></dt>
<dd>Verwenden Sie die ISO8859_1-Verschl&uuml;sselung.
</dd>
</dl>
<p>Wenn Sie beispielsweise eine Klasse mit dem Namen "HelloWorld" angeben m&ouml;chten und f&uuml;r die beiden Gro&szlig;buchstaben die Unicode-Verschl&uuml;sselung verwenden, f&uuml;hren Sie den folgenden Befehl aus:</p>
<pre class="xmp">java -Xargencoding '\u0048ello\u0057orld'</pre>
<p>Die Befehle java und javaw stellen &uuml;bersetzte Nachrichten bereit. Diese Nachrichten unterscheiden sich je nach der L&auml;ndereinstellung, in der Java ausgef&uuml;hrt wird. Die detaillierte Fehlerbeschreibung und andere von
java zur&uuml;ckgegebene Fehlerinformationen werden
in Englisch angezeigt.</p>
<a name="jit"></a>
<h2 id="jit"><a href="#ToC_34">JIT-Compiler (Just-In-Time)</a></h2>
<div>
<p>Der IBM JIT-Compiler (Just-In-Time) generiert dynamisch Maschinencode f&uuml;r h&auml;ufig
verwendete Bytecodesequenzen in Java-Anwendungen und Java-Applets, w&auml;hrend diese ausgef&uuml;hrt werden. <span>Der JIT-Compiler V6 bietet neue Optimierungen als Ergebnis der Compiler-Forschung, verbessert Optimierungen, die in vorherigen Versionen des JIT-Compilers implementiert wurden, und bietet bessere Hardware-Nutzung.</span></p></div><a id="idx27" name="idx27"></a><a id="idx28" name="idx28"></a><a id="idx29" name="idx29"></a><a id="idx30" name="idx30"></a><a id="idx31" name="idx31"></a>
<p>IBM SDK und Runtime Environment enthalten beide den JIT-Compiler, der standardm&auml;&szlig;ig in Benutzeranwendungen und in SDK-Tools aktiviert ist. In der Regel rufen Sie den JIT-Compiler nicht explizit auf. Die Kompilierung des Java-Bytecodes in Maschinencode erfolgt transparent.
Sie k&ouml;nnen den JIT-Compiler inaktivieren, um ein Problem besser eingrenzen zu k&ouml;nnen. Wenn ein Problem beim Ausf&uuml;hren einer Java-Anwendung oder eines Java-Applets auftritt, k&ouml;nnen Sie den JIT-Compiler inaktivieren, um es besser eingrenzen zu k&ouml;nnen. Die Inaktivierung des JIT-Compilers ist nur eine vor&uuml;bergehende Ma&szlig;nahme. Der JIT-Compiler ist f&uuml;r die Optimierung der Leistung erforderlich.</p>
<p>Weitere Informationen zum JIT-Compiler finden Sie im Handbuch <a href="http://www.ibm.com/developerworks/java/jdk/diagnosis/60.html" target="_blank">Diagnostics Guide</a>.</p>
<a name="disjit"></a>
<h3 id="disjit"><a href="#ToC_35">Inaktivieren des JIT-Compilers</a></h3>
<div>
<p>Der JIT-Compiler kann auf verschiedene Arten inaktiviert werden. Beide Befehlszeilenoptionen &uuml;berschreiben die Umgebungsvariable <strong>JAVA_COMPILER</strong>.</p></div>
<p>Das Inaktivieren des JIT-Compilers ist eine vor&uuml;bergehende Ma&szlig;nahme, die dazu beitragen kann, Probleme beim Debugging von Java-Anwendungen einzugrenzen.</p>
<ul>
<li>Setzen Sie die Umgebungsvariable <strong>JAVA_COMPILER</strong> auf <tt>NONE</tt>
oder auf eine leere Zeichenfolge, bevor Sie die Java-Anwendung ausf&uuml;hren. Geben Sie Folgendes an einer Shelleingabeaufforderung ein:

<pre class="xmp">    export JAVA_COMPILER=NONE</pre></li>
<li>Verwenden Sie die Option <strong>-D</strong> in der JVM-Befehlszeile, um das Merkmal <strong>java.compiler</strong> auf <tt>NONE</tt> oder auf eine leere Zeichenfolge zu setzen. Geben Sie Folgendes an einer Shelleingabeaufforderung ein:

<pre class="xmp">java -Djava.compiler=NONE <em>&lt;Klasse&gt;</em></pre></li>
<li>Verwenden Sie die Option <strong>-Xint</strong> in der JVM-Befehlszeile. Geben Sie Folgendes an einer Shelleingabeaufforderung ein:

<pre class="xmp">java -Xint <em>&lt;Klasse&gt;</em></pre></li></ul>
<a name="enajit"></a>
<h3 id="enajit"><a href="#ToC_36">Aktivieren des JIT-Compilers</a></h3>
<div>
<p>Der JIT-Compiler ist standardm&auml;&szlig;ig aktiviert. Sie k&ouml;nnen ihn aber auch auf verschiedene Arten explizit aktivieren. Beide Befehlszeilenoptionen &uuml;berschreiben die Umgebungsvariable <strong>JAVA_COMPILER</strong>.</p></div>
<ul>
<li>Setzen Sie die Umgebungsvariable <strong>JAVA_COMPILER</strong> auf <tt>jitc</tt>, bevor Sie die
Java-Anwendung ausf&uuml;hren. Geben Sie Folgendes an einer Shelleingabeaufforderung ein:

<pre class="xmp">export JAVA_COMPILER=jitc</pre> Wenn die Umgebungsvariable <strong>JAVA_COMPILER</strong> eine leere Zeichenfolge ist, bleibt der JIT-Compiler inaktiviert. Geben Sie zum Inaktivieren der Umgebungsvariablen Folgendes an der
Shelleingabeaufforderung ein:


<pre class="xmp">unset JAVA_COMPILER</pre></li>
<li>Verwenden Sie die Option <strong>-D</strong> in der JVM-Befehlszeile, um das Merkmal <strong>java.compiler</strong> auf den Wert <tt>jitc</tt> zu setzen. Geben Sie Folgendes an einer Shelleingabeaufforderung ein: 

<pre class="xmp">java -Djava.compiler=jitc <em>&lt;Klasse&gt;</em></pre></li>
<li>Verwenden Sie die Option <strong>-Xjit</strong> in der JVM-Befehlszeile. Geben Sie <strong>nicht</strong> gleichzeitig die Option <strong>-Xint</strong> an. Geben Sie Folgendes an einer Shelleingabeaufforderung ein: 

<pre class="xmp">java -Xjit <em>&lt;Klasse&gt;</em></pre></li></ul>
<a name="detjit"></a>
<h3 id="detjit"><a href="#ToC_37">Pr&uuml;fen, ob der JIT-Compiler aktiviert ist</a></h3>
<div>
<p>Sie k&ouml;nnen den Status des JIT-Compilers mit der Option <strong>-version</strong> ermitteln.</p></div><a id="idx32" name="idx32"></a><a id="idx33" name="idx33"></a>
<p>F&uuml;hren Sie das Java-Startprogramm mit der Option <strong>-version</strong> aus.
Geben sie Folgendes an einer Shelleingabeaufforderung ein: </p>
<pre class="xmp">java -version</pre> 
<p>Wenn der JIT-Compiler derzeit nicht verwendet wird, wird folgende Nachricht angezeigt:</p>

<pre class="xmp">(JIT disabled)</pre>

<p>Wenn der JIT-Compiler verwendet wird, wird folgende Nachricht angezeigt:</p>

<pre class="xmp">(JIT enabled)</pre>
<p>Weitere Informationen zum JIT-Compiler finden Sie im Handbuch <a href="http://www.ibm.com/developerworks/java/jdk/diagnosis/60.html" target="_blank">Diagnostics Guide</a>.</p>
<a name="garbage"></a>
<h2 id="garbage"><a href="#ToC_38">Angeben der Garbage-Collection-Richtlinie</a></h2>
<div>
<p>Der Garbage-Collector verwaltet den von Java und von den Anwendungen verwendeten Speicher, die mit JVM ausgef&uuml;hrt werden.</p></div><a id="idx34" name="idx34"></a>
<p>Sobald der Garbage-Collector eine Speicheranforderung empf&auml;ngt, wird hierf&uuml;r nicht verwendeter Freispeicher durch einen Prozess vorgesehen, der auch als "Zuordnung" bezeichnet wird. Der Garbage-Collector pr&uuml;ft au&szlig;erdem, ob Speicherbereiche vorhanden sind, auf die nicht mehr verwiesen wird, und gibt sie zur erneuten Verwendung frei. Dies wird auch als "Erfassung" bezeichnet.</p>
<p>Die Erfassungsphase kann durch einen Fehler bei der Hauptspeicherzuordnung ausgel&ouml;st werden, der dann auftritt, wenn f&uuml;r
Speicheranforderungen kein weiterer Speicherbereich mehr vorhanden
ist. Sie kann aber auch &uuml;ber einen expliziten Aufruf System.gc() ausgel&ouml;st werden.</p>
<p>Die Garbage-Collection kann erhebliche Auswirkungen auf die
Anwendungsleistung haben. IBM VM stellt daher
verschiedene Methoden zur Verf&uuml;gung, &uuml;ber die die Ausf&uuml;hrung
der Garbage-Collection optimiert werden kann. Dadurch k&ouml;nnen sich
die Auswirkungen auf Ihre Anwendungen verringern.</p>
<p>Ausf&uuml;hrliche Informationen zur Garbage-Collection finden Sie im Handbuch <a href="http://www.ibm.com/developerworks/java/jdk/diagnosis/60.html" target="_blank">Diagnostics Guide</a>.</p>
<a name="garbage_options"></a>
<h3 id="garbage_options"><a href="#ToC_39">Optionen der Garbage-Collection</a></h3>
<div>
<p>Die Optionen <strong>-Xgcpolicy</strong> steuern das Verhalten des Garbage-Collectors. Sie f&uuml;hren einen Kompromiss herbei zwischen dem Durchsatz der Anwendung und des Gesamtsystems und den durch die Garbage-Collection verursachten Pausezeiten.</p></div><a id="idx35" name="idx35"></a><a id="idx36" name="idx36"></a><a id="idx37" name="idx37"></a>
<p>
<p>Das Format der Option und der zugeh&ouml;rigen Werte lautet wie folgt:
</p>
<dl class="parml">
<dt class="bold"><strong>-Xgcpolicy:optthruput</strong></dt>
<dd>(Standardm&auml;&szlig;iger und empfohlener Wert.) Erm&ouml;glicht einen sehr hohen Anwendungsdurchsatz, wobei jedoch
gelegentliche Pausen auftreten.
</dd>
<dt class="bold"><strong>-Xgcpolicy:optavgpause</strong></dt>
<dd>Verringert die Zeit
der Garbage-Collection-Pausen. Au&szlig;erdem werden  die
Auswirkungen eines h&ouml;heren Freispeicherumfangs w&auml;hrend der Garbage-Collection-Pause begrenzt. Verwenden Sie <strong>optavgpause</strong>, wenn Ihre Konfiguration &uuml;ber einen sehr gro&szlig;en Freispeicher verf&uuml;gt.
</dd>
<dt class="bold"><strong>-Xgcpolicy:gencon</strong></dt>
<dd>Fordert die kombinierte Verwendung von gleichzeitig ablaufendem GC und GC nach Objektalter an, um alle Garbage-Collection-Pausen zu verringern.
</dd>
<dt class="bold"><strong>-Xgcpolicy:subpool</strong></dt>
<dd>(Nur PPC und zSeries.) Verwendet einen verbesserten Algorithmus f&uuml;r die Objektzuordnung, um eine bessere Leistung beim Zuordnen von Objekten im Freispeicher zu erzielen. Diese Option kann Leistungssteigerungen auf gro&szlig;en SMP-Systemen erm&ouml;glichen.
</dd>
</dl></p>
<a name="garbage_pause"></a>
<h3 id="garbage_pause"><a href="#ToC_40">Pausezeit</a></h3>
<div>
<p>Wenn eine Anwendung wegen des verf&uuml;gbaren Freispeichers nicht sofort ein Objekt erstellen kann, ist die Garbage-Collection f&uuml;r die Erkennung von Objekten ohne Verweis (Garbage) zust&auml;ndig sowie f&uuml;r deren L&ouml;schung und f&uuml;r die Wiederherstellung eines Freispeicherstatus, mit dem sofortige und nachfolgende Zuordnungsanforderungen schnell beantwortet werden k&ouml;nnen.</p></div><a id="idx38" name="idx38"></a><a id="idx39" name="idx39"></a>
<p>Solche Garbage-Collection-Zyklen ergeben gelegentliche unerwartete Pausen bei der Ausf&uuml;hrung des Anwendungscodes. Wenn sich die Gr&ouml;&szlig;e und Komplexit&auml;t der Anwendungen erh&ouml;ht und wenn
die Freispeicher entsprechend umfangreicher werden, tendiert diese
Pausezeit der Garbage-Collection dazu, gr&ouml;&szlig;er zu werden.</p>
<p>Der Standardwert <strong>-Xgcpolicy:optthruput</strong> f&uuml;r die
Garbage-Collection bietet Anwendungen einen sehr hohen Durchsatz, verursacht jedoch
gelegentliche Pausen. Diese Pausen k&ouml;nnen wenige Millisekunden bis zu mehreren Sekunden dauern,
je nachdem, wie gro&szlig; der Freispeicher und das Garbagevolumen ist.</p>
<a name="pausetimereduction"></a>
<h3 id="pausetimereduction"><a href="#ToC_41">Verringerung der Pausezeit</a></h3>
<div>
<p>JVM verwendet zwei Verfahren zur Verringerung von Pausezeiten: gleichzeitig ablaufende Garbage-Collection und Garbage-Collection nach Objektalter.</p></div><a id="idx40" name="idx40"></a><a id="idx41" name="idx41"></a>
<p>Die Befehlszeilenoption <strong>-Xgcpolicy:optavgpause</strong> fordert die Verwendung der gleichzeitig ablaufenden Garbage-Collection an, um die Pausezeit der Garbage-Collection (GC) erheblich zu verringern. Die gleichzeitig ablaufende GC verringert die Pausezeit, indem die Ausf&uuml;hrung einiger GC-Aktivit&auml;ten zur gleichen Zeit wie die normale Programmausf&uuml;hrung erfolgt. Dabei wird die durch die Erfassung des Freispeichers verursachte Unterbrechung minimiert. Die Option <strong>-Xgcpolicy:optavgpause</strong> begrenzt au&szlig;erdem den Effekt eines h&ouml;heren Freispeicherumfangs w&auml;hrend der Garbage-Collection-Pause. Die Option <strong>-Xgcpolicy:optavgpause</strong> ist f&uuml;r Konfigurationen mit gro&szlig;en Freispeichern sehr n&uuml;tzlich. Die Verringerung der Pausezeit hat m&ouml;glicherweise einen reduzierten Anwendungsdurchsatz zur Folge.</p>
<p>W&auml;hrend der gleichzeitig ablaufenden Garbage-Collection wird viel Zeit f&uuml;r die Identifizierung von Objekten mit einer relativ langen Lebensdauer verwendet, die nicht erfasst werden k&ouml;nnen. Wenn sich die Garbage-Collection nur auf die Objekte konzentriert, die h&ouml;chstwahrscheinlich wiederverwendbar sind, k&ouml;nnen Sie die Pausezeit f&uuml;r einige Anwendungen weiter verringern.
Die GC nach Objektalter verringert die Pausezeit, indem der Freispeicher in zwei "Generationen" aufgeteilt wird: in die Bereiche "Junge Objekte" und "Alte Objekte". Die Objekte werden abh&auml;ngig von ihrem Alter in einen dieser Bereiche gestellt. Der Bereich "Junge Objekte" ist der kleinere der beiden Bereiche und enth&auml;lt j&uuml;ngere Objekte. Der Bereich "Alte Objekte" ist gr&ouml;&szlig;er und enth&auml;lt &auml;ltere Objekte. Objekte werden zuerst dem Bereich "Junge Objekte" zugeordnet. Wenn sie lang genug &uuml;berleben, werden Sie schlie&szlig;lich in den Bereich "Alte Objekte" umgestuft.</p>
<p>Die GC nach Objektalter basiert darauf, dass die meisten Objekte nur eine kurze Lebensdauer haben. Die GC nach Objektalter verringert Pausezeiten, indem sie sich auf das Zur&uuml;ckgewinnen von Speicher im Bereich "Junge Objekte" konzentriert, da dieser Bereich &uuml;ber den meisten wiederverwendbaren Speicherplatz verf&uuml;gt. Im Gegensatz zu gelegentlichen aber &uuml;berm&auml;&szlig;ig langen Pausezeiten beim Erfassen des gesamten Freispeichers wird der Bereich "Junge Objekte" regelm&auml;&szlig;iger erfasst. Au&szlig;erdem sind Pausezeiten verh&auml;ltnism&auml;&szlig;ig kurz, wenn der Bereich klein genug ist. Die GC nach Objektalter hat jedoch den Nachteil, dass der Bereich "Alte Objekte" mit der Zeit voll wird, wenn zu viele Objekte eine zu lange Lebensdauer haben. Verwenden Sie eine Kombination aus der gleichzeitig ablaufenden GC und der GC nach Objektalter, um in dieser Situation die Pausezeit zu minimieren. Die Option <strong>-Xgcpolicy:gencon</strong> fordert die kombinierte Verwendung der gleichzeitig ablaufenden GC und der GC nach Objektalter an, um die GC-Pausezeit zu verringern.</p>
<a name="garbage_full_heap"></a>
<h3 id="garbage_full_heap"><a href="#ToC_42">Umgebungen mit sehr vollen Freispeichern</a></h3>
<div>
<p>Wenn der Java-Freispeicher nahezu voll ist und wenn sehr wenig Garbagespeicher freigegeben werden kann, werden
Anforderungen f&uuml;r neue Objekte m&ouml;glicherweise nicht schnell
beantwortet, da kein Speicherbereich sofort verf&uuml;gbar ist.</p></div><a id="idx42" name="idx42"></a><a id="idx43" name="idx43"></a>
<p>Bei der Ausf&uuml;hrung mit nahezu vollem Freispeicher kann die Anwendungsleistung geringer werden, unabh&auml;ngig davon, welche Garbage-Collection-Optionen Sie verwenden; wenn weiterhin Freispeicher angefordert wird, empf&auml;ngt die Anwendung m&ouml;glicherweise eine Ausnahmebedingung OutOfMemoryError wegen ungen&uuml;gender Speicherkapazit&auml;t und JVM wird beendet, es sei denn, die Ausnahmebedingung wird abgefangen und bearbeitet. In diesem Fall erstellt JVM eine Java-Speicherauszugsdatei, die w&auml;hrend der Diagnose verwendet wird. Unter diesen Umst&auml;nden
sollten Sie entweder die Freispeichergr&ouml;&szlig;e mit der Option <strong>-Xmx</strong> erh&ouml;hen oder die Anzahl der verwendeten
Objekte verringern.</p>
<p>Weitere Informationen finden Sie im Handbuch <a href="http://www.ibm.com/developerworks/java/jdk/diagnosis/60.html" target="_blank">Diagnostics Guide</a>.</p>
<a name="euro_symbol"></a>
<h2 id="euro_symbol"><a href="#ToC_43">Unterst&uuml;tzung des Euro-Symbols</a></h2>
<div>
<p>F&uuml;r IBM SDK und Runtime Environment
gilt ab dem 1. Januar 2002 f&uuml;r die L&auml;nder der Europ&auml;ischen W&auml;hrungsunion der Euro als Standardw&auml;hrung. <span>Ab dem
1. Januar 2008 gilt der Euro auch f&uuml;r Zypern und Malta als Standardw&auml;hrung.</span></p></div>
<p>Wenn Sie die fr&uuml;here nationale W&auml;hrung verwenden m&ouml;chten, geben Sie in der Java-Befehlszeile
<strong>-Duser.variant=PREEURO</strong> an.</p>
<p>Wenn Sie mit der britischen, d&auml;nischen oder schwedischen L&auml;ndereinstellung arbeiten und
den Euro als W&auml;hrung verwenden m&ouml;chten, geben Sie in der Java-Befehlszeile
<strong>-Duser.variant=EURO</strong> an.</p>
<a name="fallback_font"></a>
<h2 id="fallback_font"><a href="#ToC_44">Schriftartkonfigurationsdateien zur Zur&uuml;cksetzung</a></h2>
<div>
<p>Die Linux-Schriftartkonfigurationsdateien zur Zur&uuml;cksetzung (fontconfig.RedHat.bfc und fontconfig.SuSE.bfc) werden installiert, da sie
Schriftarteinstellungen enthalten, die f&uuml;r neue unternehmensweite Linux-Varianten geeignet sind.</p></div>
<p>Das Vorhandensein dieser Dateien bedeutet nicht, dass die neue Linux-Variante eine unterst&uuml;tzte Plattform f&uuml;r IBM SDK and Runtime Environment for Linux platforms, Java Technology
Edition, Version 6 darstellt.</p><font color="RED"><span id="changed">|</span>
<span id="changed">|</span><a name="input_method_extensions"></a>
<span id="changed">|</span><h2 id="input_method_extensions"><a href="#ToC_45">Verwenden von Eingabemethoden f&uuml;r Indisch und Thail&auml;ndisch</a></h2>
<span id="changed">|</span><div>
<span id="changed">|</span><p>Ab Version 6 sind die Eingabemethoden f&uuml;r Indisch und Thail&auml;ndisch nicht standardm&auml;&szlig;ig verf&uuml;gbar. Sie m&uuml;ssen die entsprechenden JAR-Dateien manuell in den Java-Erweiterungspfad einschlie&szlig;en, um die Eingabemethoden f&uuml;r Indisch und Thail&auml;ndisch verwenden zu k&ouml;nnen.</p></div>
<span id="changed">|</span><p>Bei Version 5.0 waren die JAR-Dateien f&uuml;r die Eingabemethoden im Verzeichnis <a name="input_method_extensions__ext"></a><span id="input_method_extensions__ext">jre/lib/ext</span> enthalten und wurden von JVM automatisch geladen. Bei Version 6 sind diese JAR-Dateien im Verzeichnis
<span id="changed">|</span><a name="input_method_extensions__im"></a><span id="input_method_extensions__im">jre/lib/im</span> enthalten und m&uuml;ssen dem Java-Erweiterungspfad manuell hinzugef&uuml;gt werden, um die Eingabemethoden f&uuml;r Indisch und Thail&auml;ndisch zu aktivieren. Dies wird durch eine der folgenden Methoden erreicht:</p>
<span id="changed">|</span><ul>
<span id="changed">|</span><li>Kopieren Sie die Dateien indicim.jar und thaiim.jar aus dem Verzeichnis jre/lib/im in das Verzeichnis
<span id="changed">|</span>jre/lib/ext.</li>
<span id="changed">|</span><li>F&uuml;gen Sie das Verzeichnis jre/lib/im dem Systemmerkmal der Erweiterungsverzeichnisse hinzu. Verwenden Sie die folgende Befehlszeilenoption:
<span id="changed">|</span>
<span id="changed">|</span><pre class="xmp">java -Djava.ext.dirs=/opt/ibm/java-i386-60/jre/lib/ext:/opt/ibm/java-i386-60/jre/lib/im <em>&lt;Klasse&gt;</em></pre></li></ul>
<span id="changed">|</span><p>
<span id="changed">|</span><p>Wenn SDK oder Runtime Environment in einem anderen Verzeichnis installiert sind, ersetzen Sie /opt/ibm/java-i386-60/ durch das Verzeichnis, in dem SDK oder Runtime Environment installiert sind.</p></p></font>
<a name="developing"></a>
<h1 id="developing"><a href="#ToC_46">Verwenden von SDK zur Entwicklung
von Java-Anwendungen</a></h1>
<div>
<p>Das SDK f&uuml;r Linux enth&auml;lt viele Tools und Bibliotheken, die f&uuml;r die Java-Softwareentwicklung erforderlich sind.</p></div>
<p> Einzelheiten zu den verf&uuml;gbaren Tools finden Sie in <a href="#sdktools">SDK-Tools und -Referenzinformationen</a>.</p><font color="RED"><span id="changed">|</span>
<span id="changed">|</span><a name="xml_using"></a>
<span id="changed">|</span><h2 id="xml_using"><a href="#ToC_47">Verwenden von XML</a></h2>
<span id="changed">|</span><div>
<span id="changed">|</span><p>IBM SDK enth&auml;lt die Parser XML4J und
<span id="changed">|</span>XL XP-J, den Compiler XL TXE-J 1.0 XSLT und den Interpreter XSLT4J XSLT.
<span id="changed">|</span>Mit Hilfe dieser Tools
<span id="changed">|</span>k&ouml;nnen Sie XML-Dokumente unabh&auml;ngig von einer bestimmten Implementierung zur XML-Verarbeitung
<span id="changed">|</span>syntaktisch analysieren, umwandeln und serialisieren.</p></div><a id="idx44" name="idx44"></a><a id="idx45" name="idx45"></a>
<span id="changed">|</span><p>
<span id="changed">|</span><p> Verwenden Sie Factory-Finder zum Suchen von Implementierungen der abstrakten Factory-Klassen, wie unter <a href="#xml_using__select_processor">Ausw&auml;hlen eines XML-Prozessors</a> beschrieben.
<span id="changed">|</span>Mit Hilfe der Factory-Finder k&ouml;nnen Sie eine andere XML-Bibliothek ausw&auml;hlen, ohne Ihren
<span id="changed">|</span>Java-Code zu &auml;ndern.</p></p>
<span id="changed">|</span><p>
<span id="changed">|</span><a name="wq40"></a>
<span id="changed">|</span><h3 id="wq40">Verf&uuml;gbare XML-Bibliotheken</h3>
<span id="changed">|</span><p>IBM SDK for Java enth&auml;lt die folgenden XML-Bibliotheken.</p></p>
<span id="changed">|</span><dl>
<span id="changed">|</span><dt class="bold">XML4J 4.5</dt>
<span id="changed">|</span><dd>
<span id="changed">|</span><p>XML4J ist ein Validierungsparser mit Unterst&uuml;tzung f&uuml;r die folgenden Standards:
<span id="changed">|</span></p>
<span id="changed">|</span><ul>
<span id="changed">|</span><li>XML 1.0 (4. Ausgabe)</li>
<span id="changed">|</span><li>Namespaces in XML 1.0 (2. Ausgabe)</li>
<span id="changed">|</span><li>XML 1.1 (2. Ausgabe)</li>
<span id="changed">|</span><li>Namespaces in XML 1.1 (2. Ausgabe)</li>
<span id="changed">|</span><li>W3C XML Schema 1.0 (2. Ausgabe)</li>
<span id="changed">|</span><li>XInclude 1.0 (2. Ausgabe)</li>
<span id="changed">|</span><li>OASIS XML Catalogs 1.0</li>
<span id="changed">|</span><li>SAX 2.0.2</li>
<span id="changed">|</span><li>DOM Level 3 Core, Load and Save</li>
<span id="changed">|</span><li>DOM Level 2 Core, Events, Traversal and Range</li>
<span id="changed">|</span><li>JAXP 1.4</li></ul>
<span id="changed">|</span>
<span id="changed">|</span><p>XML4J 4.5 basiert auf Apache Xerces-J 2.9.0. Weitere Informationen hierzu finden Sie unter <a href="http://xerces.apache.org/xerces2-j/" target="_blank">http://xerces.apache.org/xerces2-j/</a>.</p>
<span id="changed">|</span></dd>
<span id="changed">|</span><dt class="bold">XL XP-J 1.1</dt>
<span id="changed">|</span><dd>
<span id="changed">|</span><p>XL XP-J 1.1 ist ein leistungsf&auml;higer Parser ohne Validierung mit Unterst&uuml;tzung f&uuml;r
<span id="changed">|</span>StAX 1.0 (JSR 173); eine bidirektionale Anwendungsprogrammierschnittstelle f&uuml;r Pull-Parsing- und Streaming-Serialisierung
<span id="changed">|</span>von XML 1.0- und XML 1.1-Dokumenten. Weitere Informationen dazu, was von XL XP-J 1.1 unterst&uuml;tzt wird, finden Sie in <a href="#xlxpj_reference">Referenzinformationen zu XL XP-J</a>.</p>
<span id="changed">|</span></dd>
<span id="changed">|</span><dt class="bold">XL TXE-J 1.0.1 Beta</dt>
<span id="changed">|</span><dd>
<span id="changed">|</span><p>Bei Version 5.0 umfasste IBM SDK for Java den XSLT4J-Compiler und -Interpreter.
<span id="changed">|</span>Der XSLT4J-Interpreter wurde standardm&auml;&szlig;ig verwendet.</p>
<span id="changed">|</span>
<span id="changed">|</span><p>Bei Version 6 umfasst IBM SDK for Java
<span id="changed">|</span>XL TXE-J. XL TXE-J umfasst den XSLT4J-Interpreter und einen neuen
<span id="changed">|</span>XSLT-Compiler.
<span id="changed">|</span>Der neue Compiler wird standardm&auml;&szlig;ig verwendet. Der XSLT4J-Compiler
<span id="changed">|</span>ist in IBM SDK
<span id="changed">|</span>for Java nicht mehr enthalten. Weitere Informationen zum Migrieren auf XL TXE-J finden Sie in <a href="#xslt_migration_steps">Migrieren auf den XL-TXE-J-Compiler</a>.</p>
<span id="changed">|</span>
<span id="changed">|</span><p>XL TXE-J unterst&uuml;tzt die folgenden Standards:
<span id="changed">|</span></p>
<span id="changed">|</span><ul>
<span id="changed">|</span><li>XSLT 1.0</li>
<span id="changed">|</span><li>XPath 1.0</li>
<span id="changed">|</span><li>JAXP 1.4</li></ul>
<span id="changed">|</span></dd>
<span id="changed">|</span></dl>
<span id="changed">|</span><p>
<span id="changed">|</span><a name="xml_using__select_processor"></a>
<span id="changed">|</span><h3 id="xml_using__select_processor">Ausw&auml;hlen eines XML-Prozessors</h3>
<span id="changed">|</span><p>Die Auswahl eines XML-Prozessors wird mit Hilfe von Service-Providern durchgef&uuml;hrt. Bei Verwendung eines Factory-Finders schlie&szlig;t Java bei der Suche nach einem entsprechenden Service-Provider Folgendes ein:
<span id="changed">|</span></p>
<span id="changed">|</span><ol type="1">
<span id="changed">|</span><li>Das Systemmerkmal, das denselben Namen wie der Service-Provider hat.</li>
<span id="changed">|</span><li><strong>Nur f&uuml;r XMLEventFactory, XMLInputFactory und
<span id="changed">|</span>XMLOutputFactory.</strong> Den Wert des Service-Providers in der Datei /opt/ibm/java-i386-60/jre/lib/stax.properties.</li>
<span id="changed">|</span><li><strong>F&uuml;r andere Factorys.</strong> Den Wert des Service-Providers in der Datei /opt/ibm/java-i386-60/jre/lib/jaxp.properties.</li>
<span id="changed">|</span><li>Den Inhalt der Datei META-INF/services/&lt;Service.Provider&gt;.</li>
<span id="changed">|</span><li>Den standardm&auml;&szlig;igen Service-Provider.</li></ol>
<span id="changed">|</span><p>Die folgenden Service-Provider steuern die XML verarbeitenden Bibliotheken, die von Java verwendet werden:
<span id="changed">|</span></p>
<span id="changed">|</span><dl class="parml">
<span id="changed">|</span><dt class="bold"><strong>javax.xml.parsers.SAXParserFactory</strong></dt>
<span id="changed">|</span><dd>W&auml;hlt den SAX-Parser aus. Standardm&auml;&szlig;ig wird org.apache.xerces.jaxp.SAXParserFactoryImpl aus der XML4J-Bibliothek verwendet.
<span id="changed">|</span></dd>
<span id="changed">|</span><dt class="bold"><strong>javax.xml.parsers.DocumentBuilderFactory</strong></dt>
<span id="changed">|</span><dd>W&auml;hlt das Dokumenterstellungsprogramm aus. Standardm&auml;&szlig;ig wird org.apache.xerces.jaxp.DocumentBuilderFactoryImpl aus der
<span id="changed">|</span>XML4J-Bibliothek verwendet.
<span id="changed">|</span></dd>
<span id="changed">|</span><dt class="bold"><strong>javax.xml.datatype.DatatypeFactory</strong></dt>
<span id="changed">|</span><dd>W&auml;hlt die Datentypfactory aus. Standardm&auml;&szlig;ig wird org.apache.xerces.jaxp.datatype.DatatypeFactoryImpl aus der
<span id="changed">|</span>XML4J-Bibliothek verwendet.
<span id="changed">|</span></dd>
<span id="changed">|</span><dt class="bold"><strong>javax.xml.stream.XMLEventFactory</strong></dt>
<span id="changed">|</span><dd>W&auml;hlt die StAX-Ereignisfactory aus. Standardm&auml;&szlig;ig wird com.ibm.xml.xlxp.api.stax.XMLEventFactoryImpl aus der
<span id="changed">|</span>XL XP-J-Bibliothek verwendet.
<span id="changed">|</span></dd>
<span id="changed">|</span><dt class="bold"><strong>javax.xml.stream.XMLInputFactory</strong></dt>
<span id="changed">|</span><dd>W&auml;hlt den StAX-Parser aus. Standardm&auml;&szlig;ig wird com.ibm.xml.xlxp.api.stax.XMLInputFactoryImpl aus der
<span id="changed">|</span>XL XP-J-Bibliothek verwendet.
<span id="changed">|</span></dd>
<span id="changed">|</span><dt class="bold"><strong>javax.xml.stream.XMLOutputFactory</strong></dt>
<span id="changed">|</span><dd>W&auml;hlt die StAX-Serialisierungsmethode aus. Standardm&auml;&szlig;ig wird com.ibm.xml.xlxp.api.stax.XMLOutputFactoryImpl aus der
<span id="changed">|</span>XL XP-J-Bibliothek verwendet.
<span id="changed">|</span></dd>
<span id="changed">|</span><dt class="bold"><strong>javax.xml.transform.TransformerFactory</strong></dt>
<span id="changed">|</span><dd>W&auml;hlt den XSLT-Prozessor aus. G&uuml;ltige Werte sind:
<span id="changed">|</span>
<span id="changed">|</span><dl class="parml">
<span id="changed">|</span><dt class="bold">com.ibm.xtq.xslt.jaxp.compiler.TransformerFactoryImpl</dt>
<span id="changed">|</span><dd>Verwendet den XL TXE-J-Compiler. Dies ist der Standardwert.
<span id="changed">|</span></dd>
<span id="changed">|</span><dt class="bold">org.apache.xalan.processor.TransformerFactoryImpl</dt>
<span id="changed">|</span><dd>Verwendet den XSLT4J-Interpreter.
<span id="changed">|</span></dd>
<span id="changed">|</span></dl>
<span id="changed">|</span></dd>
<span id="changed">|</span><dt class="bold"><strong>javax.xml.validation.SchemaFactory:http://www.w3.org/2001/XMLSchema</strong></dt>
<span id="changed">|</span><dd>W&auml;hlt die Schemafactory f&uuml;r die W3C XML Schemasprache aus. Standardm&auml;&szlig;ig wird org.apache.xerces.jaxp.validation.XMLSchemaFactory aus der XML4J-Bibliothek verwendet.
<span id="changed">|</span></dd>
<span id="changed">|</span><dt class="bold"><strong>javax.xml.xpath.XPathFactory</strong></dt>
<span id="changed">|</span><dd>W&auml;hlt den XPath-Prozessor aus. Standardm&auml;&szlig;ig wird org.apache.xpath.jaxp.XPathFactoryImpl aus der
<span id="changed">|</span>XSLT4J-Bibliothek verwendet.
<span id="changed">|</span></dd>
<span id="changed">|</span></dl></p>
<span id="changed">|</span><a name="xslt_migration_steps"></a>
<span id="changed">|</span><h3 id="xslt_migration_steps"><a href="#ToC_50">Migrieren auf den XL-TXE-J-Compiler</a></h3>
<span id="changed">|</span><div>
<span id="changed">|</span><p>Der XL TXE-J-Compiler hat den XSLT4J-Interpreter als XSLT-Standardprozessor ersetzt. F&uuml;hren Sie die folgenden Schritte aus, um Ihre Anwendung f&uuml;r die neue Bibliothek vorzubereiten.</p></div>
<span id="changed">|</span><p>
<span id="changed">|</span><p>Der XL TXE-J-Compiler ist schneller als der XSLT4J-Interpreter, wenn Sie die gleichen Transformationen mehrmals anwenden. Wenn Sie jede einzelne Transformation nur einmal anwenden, ist der XL TXE-J-Compiler auf Grund des Kompilierungs- und Optimierungsaufwands langsamer als der XSLT4J-Interpreter.</p>
<span id="changed">|</span><p>Setzen Sie den Service-Provider <strong>javax.xml.transform.TransformerFactory</strong> auf
<span id="changed">|</span>org.apache.xalan.processor.TransformerFactoryImpl, um den XSLT4J-Interpreter weiterhin als Ihren XSLT-Prozessor zu verwenden.</p>
<span id="changed">|</span><p>F&uuml;hren Sie zum Migrieren auf den XL-TXE-J-Compiler die folgenden Schritte aus:</p></p>
<span id="changed">|</span><ol type="1">
<span id="changed">|</span><li>Verwenden Sie com.ibm.xtq.xslt.jaxp.compiler.TransformerFactoryImpl, wenn Sie den Service-Provider <strong>javax.xml.transform.TransformerFactory</strong> festlegen.</li>
<span id="changed">|</span><li>Generieren Sie vom XSLT4J-Compiler generierte Klassendateien neu. XL TXE-J kann keine Klassendateien ausf&uuml;hren, die vom XSLT4J-Compiler generiert wurden.</li>
<span id="changed">|</span><li>Durch einige vom Compiler generierten Methoden wird m&ouml;glicherweise die JVM-Methodengr&ouml;&szlig;enbegrenzung &uuml;berschritten. In diesem Fall versucht der Compiler, diese Methoden in kleinere Methoden zu teilen.
<span id="changed">|</span>
<span id="changed">|</span><ul>
<span id="changed">|</span><li>Wenn die Methode vom Compiler erfolgreich geteilt werden konnte, erhalten Sie die folgende Warnung:
<span id="changed">|</span>&quot;Einige generierte Funktionen &uuml;berschritten die Gr&ouml;&szlig;enbegrenzung der JVM-Methode und wurden automatisch in kleinere Funktionen geteilt. Sie k&ouml;nnen eine bessere Leistung erzielen, indem Sie sehr gro&szlig;e Vorlagen manuell in kleinere Vorlagen teilen. Verwenden Sie dazu die Option 'splitlimit' mit dem Verarbeitungs- und Kompilierungsbefehl, oder legen Sie das Transformer-Factory-Attribut 'http://www.ibm.com/xmlns/prod/xltxe-j/split-limit' fest.&quot;. Sie k&ouml;nnen die kompilierten Klassen verwenden, aber Sie erzielen m&ouml;glicherweise eine bessere Leistung, wenn Sie den Teilungsgrenzwert manuell steuern.</li>
<span id="changed">|</span><li>Wenn die Methode vom Compiler nicht erfolgreich geteilt wurde, erhalten Sie eine der folgenden Ausnahmebedingungen: &quot;com.ibm.xtq.bcel.generic.ClassGenException: Branch target offset too large for short&quot; oder &quot;bytecode array size &gt; 65535
<span id="changed">|</span>at offset=#####&quot;. Versuchen Sie, den Teilungsgrenzwert manuell festzulegen oder einen niedrigeren Teilungsgrenzwert zu verwenden.</li></ul> Verwenden Sie zum Festlegen des Teilungsgrenzwerts die Option <strong>-SPLITLIMIT</strong>, wenn Sie die Befehle
<span id="changed">|</span>'Process' oder 'Compile' verwenden, oder das Transformer-Factory-Attribut <strong>http://www.ibm.com/xmlns/prod/xltxe-j/split-limit</strong>, wenn Sie die Transformer-Factory verwenden. Der Teilungsgrenzwert kann zwischen 100 und 2000 liegen. Verwenden Sie beim manuellen Festlegen des Teilungsgrenzwerts den gr&ouml;&szlig;tm&ouml;glichen Teilungsgrenzwert, um die h&ouml;chste Leistung zu erhalten.</li>
<span id="changed">|</span><li>Der XL TXE-J-Compiler ben&ouml;tigt m&ouml;glicherweise mehr Speicher als der XSLT4J-Compiler. Erh&ouml;hen Sie mit Hilfe der Option <strong>-Xmx</strong> die Gr&ouml;&szlig;e des Freispeichers, wenn Ihnen der Speicherplatz ausgeht, oder die Leistung nachl&auml;sst.</li>
<span id="changed">|</span><li>Migrieren Sie Ihre Anwendung, so dass sie die neuen Attributschl&uuml;ssel verwendet. Die alten Attributschl&uuml;ssel von Transformer-Factory sind veraltet. Die alten Namen werden unter Ausgabe einer Warnung akzeptiert. 
<span id="changed">|</span>
<span id="changed">|</span><a name="wq44"></a>
<span id="changed">|</span><table id="wq44" width="90%" summary="" border="1" frame="border" rules="all">
<span id="changed">|</span><caption>Tabelle 1. &Auml;nderungen an Attributschl&uuml;sseln zwischen dem XSL4J- und dem XL TXE-J-Compiler</caption>
<span id="changed">|</span><thead valign="bottom">
<span id="changed">|</span><tr valign="bottom">
<span id="changed">|</span><th id="wq45" align="left">Attribut des XSL4J-Compilers</th>
<span id="changed">|</span><th id="wq46" align="left">Attribut des XL TXE-J-Compilers</th>
<span id="changed">|</span></tr>
<span id="changed">|</span></thead>
<span id="changed">|</span><tbody valign="top">
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq45">translet-name</td>
<span id="changed">|</span><td headers="wq46">http://www.ibm.com/xmlns/prod/xltxe-j/translet-name</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq45">destination-directory</td>
<span id="changed">|</span><td headers="wq46">http://www.ibm.com/xmlns/prod/xltxe-j/destination-directory</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq45">package-name</td>
<span id="changed">|</span><td headers="wq46">http://www.ibm.com/xmlns/prod/xltxe-j/package-name</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq45">jar-name</td>
<span id="changed">|</span><td headers="wq46">http://www.ibm.com/xmlns/prod/xltxe-j/jar-name</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq45">generate-translet</td>
<span id="changed">|</span><td headers="wq46">http://www.ibm.com/xmlns/prod/xltxe-j/generate-translet</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq45">auto-translet</td>
<span id="changed">|</span><td headers="wq46">http://www.ibm.com/xmlns/prod/xltxe-j/auto-translet</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq45">use-classpath</td>
<span id="changed">|</span><td headers="wq46">http://www.ibm.com/xmlns/prod/xltxe-j/use-classpath</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq45">debug</td>
<span id="changed">|</span><td headers="wq46">http://www.ibm.com/xmlns/prod/xltxe-j/debug</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq45">indent-number</td>
<span id="changed">|</span><td headers="wq46">http://www.ibm.com/xmlns/prod/xltxe-j/indent-number</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq45">enable-inlining</td>
<span id="changed">|</span><td headers="wq46"><em>Im neuen Compiler veraltet</em></td>
<span id="changed">|</span></tr>
<span id="changed">|</span></tbody>
<span id="changed">|</span></table></li>
<span id="changed">|</span><li>Optional: Stellen Sie f&uuml;r eine optimale Leistung sicher, dass Sie wiederverwendbare XSLT-Transformationen nicht erneut kompilieren. Verwenden Sie zur Wiederverwendung kompilierter Transformationen eine der folgenden Methoden:
<span id="changed">|</span>
<span id="changed">|</span><ul>
<span id="changed">|</span><li>Falls sich Ihr Style-Sheet w&auml;hrend der Laufzeit nicht &auml;ndert, kompilieren Sie das Style-Sheet als Teil Ihres Erstellungsprozesses,
<span id="changed">|</span>und stellen Sie die kompilierten Klassen in Ihren Klassenpfad.
<span id="changed">|</span>Verwenden Sie den Befehl org.apache.xalan.xsltc.Compile zum Kompilieren des Style-Sheet und setzen Sie das Transformer-Factory-Attribut
<span id="changed">|</span><strong>http://www.ibm.com/xmlns/prod/xltxe-j/use-classpath</strong> auf <tt>true</tt>, um die Klassen aus dem Klassenpfad zu laden.</li>
<span id="changed">|</span><li>Falls Ihre Anwendung dasselbe Style-Sheet f&uuml;r mehrere Ausf&uuml;hrungen verwendet, setzen Sie das Transformer-Factory-Attribut <strong>http://www.ibm.com/xmlns/prod/xltxe-j/auto-translet</strong> auf <tt>true</tt>, um das kompilierte Style-Sheet zur  Wiederverwendung automatisch auf Platte zu speichern. Der Compiler verwendet ein kompiliertes Style-Sheet, falls ein solches verf&uuml;gbar ist, und kompiliert das Style-Sheet, falls es nicht verf&uuml;gbar oder nicht auf dem neuesten Stand ist. Verwenden Sie das Transformer-Factory-Attribut <strong>http://www.ibm.com/xmlns/prod/xltxe-j/destination-directory</strong>, um das Verzeichnis festzulegen, in dem kompilierte Style-Sheets gespeichert werden sollen.
<span id="changed">|</span>Kompilierte Style-Sheets werden standardm&auml;&szlig;ig im selben Verzeichnis wie das Style-Sheet gespeichert.</li>
<span id="changed">|</span><li>Handelt es sich bei Ihrer Anwendung um eine Anwendung mit langer Laufzeit, die dasselbe Style-Sheet wiederverwendet, verwenden Sie die Transformer-Factory zum Kompilieren des Style-Sheet, und erstellen Sie ein Templates-Objekt. Sie k&ouml;nnen das Objekt Templates zum Erstellen von Transformer-Objekten verwenden, ohne das Style-Sheet erneut kompilieren zu m&uuml;ssen.  Auch die Transformer-Objekte k&ouml;nnen wiederverwendet werden, sind allerdings nicht threadsicher.</li></ul></li></ol>
<span id="changed">|</span><a name="xml_reference"></a>
<span id="changed">|</span><h3 id="xml_reference"><a href="#ToC_51">XML-Referenzinformationen</a></h3>
<span id="changed">|</span><div>
<span id="changed">|</span><p>Die XL XP-J- und XL TXE-J-XML-Bibliotheken sind bei Version 6 des SDK neu. In folgenden Referenzinformationen werden die von diesen Bibliotheken unterst&uuml;tzten Features beschrieben.</p></div><span id="changed">|</span>
<span id="changed">|</span><a name="xlxpj_reference"></a>
<span id="changed">|</span><h4 id="xlxpj_reference">Referenzinformationen zu XL XP-J</h4>
<span id="changed">|</span><div>
<span id="changed">|</span><p>XL XP-J 1.1 ist ein leistungsf&auml;higer Parser ohne Validierung mit Unterst&uuml;tzung f&uuml;r
<span id="changed">|</span>StAX 1.0 (JSR 173); eine bidirektionale Anwendungsprogrammierschnittstelle f&uuml;r Pull-Parsing- und Streaming-Serialisierung
<span id="changed">|</span>von XML 1.0- und XML 1.1-Dokumenten.</p></div>
<span id="changed">|</span><p>
<span id="changed">|</span><a name="wq47"></a>
<span id="changed">|</span><h5 id="wq47">Nicht unterst&uuml;tzte Features</h5>
<span id="changed">|</span><p>Die folgenden optionalen StAX-Features werden von
<span id="changed">|</span>XL XP-J nicht unterst&uuml;tzt:
<span id="changed">|</span></p>
<span id="changed">|</span><ul>
<span id="changed">|</span><li>DTD-Validierung bei Verwendung von XMLStreamReader oder XMLEventReader.
<span id="changed">|</span>Der XL XP-J-Parser ist nicht validierend.</li>
<span id="changed">|</span><li>Positionsinformationen bei Verwendung von XMLStreamReader oder XMLEventReader.
<span id="changed">|</span>Die Abfrage der Methoden getCharacterOffset(), getColumnNumber() und getLineNumber() eines Location-Objekts gibt -1 zur&uuml;ck, unabh&auml;ngig von der aktuellen Position des Parsers im Dokument.</li></ul></p>
<span id="changed">|</span><p>
<span id="changed">|</span><a name="wq48"></a>
<span id="changed">|</span><h5 id="wq48">Referenzinformationen zu XMLInputFactory</h5>
<span id="changed">|</span><p>Die folgenden Merkmale werden von der javax.xml.stream.XMLInputFactory-Implementierung unterst&uuml;tzt. Sie werden unter <a href="http://java.sun.com/javase/6/docs/api/javax/xml/stream/XMLInputFactory.html" target="_blank">XMLInputFactory Javadoc</a> beschrieben.</p></p>
<span id="changed">|</span><a name="wq49"></a>
<span id="changed">|</span><table id="wq49" width="100%" summary="" border="1" frame="border" rules="all">
<span id="changed">|</span><caption>Tabelle 2. </caption>
<span id="changed">|</span><thead valign="bottom">
<span id="changed">|</span><tr valign="bottom">
<span id="changed">|</span><th id="wq50" align="left">Merkmalname</th>
<span id="changed">|</span><th id="wq51" align="left">Unterst&uuml;tzt</th>
<span id="changed">|</span></tr>
<span id="changed">|</span></thead>
<span id="changed">|</span><tbody valign="top">
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq50"><strong>javax.xml.stream.isValidating</strong></td>
<span id="changed">|</span><td headers="wq51">Nein. Der XL XP-J-Scanner unterst&uuml;tzt keine Validierung.</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq50"><strong>javax.xml.stream.isNamespaceAware</strong></td>
<span id="changed">|</span><td headers="wq51">Ja (unterst&uuml;tzt 'true' und 'false'). F&uuml;r XMLStreamReader, die aus
<span id="changed">|</span>DOMSources erstellt wurden, ist die Namensbereichsverarbeitung abh&auml;ngig von den Methoden, die zum Erstellen der DOM-Struktur verwendet wurden; dieser Wert hat keine Auswirkungen.</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq50"><strong>javax.xml.stream.isCoalescing</strong></td>
<span id="changed">|</span><td headers="wq51">Ja</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq50"><strong>javax.xml.stream.isReplacingEntityReferences</strong></td>
<span id="changed">|</span><td headers="wq51">Ja. F&uuml;r XMLStreamReader, die aus
<span id="changed">|</span>DOMSources erstellt wurden, hat die Festlegung dieses Parameters keine Auswirkungen, wenn bereits Entit&auml;ten in der DOM-Struktur ersetzt wurden.</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq50"><strong>javax.xml.stream.isSupportingExternalEntities</strong></td>
<span id="changed">|</span><td headers="wq51">Ja</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq50"><strong>javax.xml.stream.supportDTD</strong></td>
<span id="changed">|</span><td headers="wq51">Nein. DTDs werden immer unterst&uuml;tzt. Die Festlegung dieses Werts auf 'false' hat keine Auswirkungen.</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq50"><strong>javax.xml.stream.reporter</strong></td>
<span id="changed">|</span><td headers="wq51">Ja</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq50"><strong>javax.xml.stream.resolver</strong></td>
<span id="changed">|</span><td headers="wq51">Ja</td>
<span id="changed">|</span></tr>
<span id="changed">|</span></tbody>
<span id="changed">|</span></table>
<span id="changed">|</span><p>XL XP-J unterst&uuml;tzt auch die optionale Methode createXMLStreamReader(javax.xml.transform.Source),
<span id="changed">|</span>so dass StAX-Eingabeprogramme aus DOM- und SAX-Quellen erstellt werden k&ouml;nnen.</p>
<span id="changed">|</span><p>
<span id="changed">|</span><a name="wq52"></a>
<span id="changed">|</span><h5 id="wq52">Referenzinformationen zu XMLStreamReader</h5>
<span id="changed">|</span><p>Die folgenden Merkmale werden von der javax.xml.stream.XMLStreamReader-Implementierung unterst&uuml;tzt. Sie werden unter <a href="http://java.sun.com/javase/6/docs/api/javax/xml/stream/XMLStreamReader.html" target="_blank">XMLStreamReader Javadoc</a> beschrieben.</p></p>
<span id="changed">|</span><a name="wq53"></a>
<span id="changed">|</span><table id="wq53" width="100%" summary="" border="1" frame="border" rules="all">
<span id="changed">|</span><caption>Tabelle 3. </caption>
<span id="changed">|</span><thead valign="bottom">
<span id="changed">|</span><tr valign="bottom">
<span id="changed">|</span><th id="wq54" align="left">Merkmalname</th>
<span id="changed">|</span><th id="wq55" align="left">Unterst&uuml;tzt</th>
<span id="changed">|</span></tr>
<span id="changed">|</span></thead>
<span id="changed">|</span><tbody valign="top">
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq54"><strong>javax.xml.stream.entities</strong></td>
<span id="changed">|</span><td headers="wq55">Ja</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq54"><strong>javax.xml.stream.notations</strong></td>
<span id="changed">|</span><td headers="wq55">Ja</td>
<span id="changed">|</span></tr>
<span id="changed">|</span></tbody>
<span id="changed">|</span></table>
<span id="changed">|</span><p>XL XP-J unterst&uuml;tzt auch das Merkmal <strong>javax.xml.stream.isInterning</strong>, die einen booleschen Wert zur&uuml;ckgibt, der angibt, ob von den API-Aufrufen zur&uuml;ckgegebene XML-Namen und Namensbereichs-URIs vom Parser mit der Methode 'intern' verarbeitet wurden.</p>
<span id="changed">|</span><p>
<span id="changed">|</span><a name="wq56"></a>
<span id="changed">|</span><h5 id="wq56">Referenzinformationen zu XMLOutputFactory</h5>
<span id="changed">|</span><p>Die folgenden Merkmale werden von der javax.xml.stream.XMLOutputFactory-Implementierung unterst&uuml;tzt. Sie werden unter <a href="http://java.sun.com/javase/6/docs/api/javax/xml/stream/XMLOutputFactory.html" target="_blank">XMLOutputFactory Javadoc</a> beschrieben.</p></p>
<span id="changed">|</span><a name="wq57"></a>
<span id="changed">|</span><table id="wq57" width="100%" summary="" border="1" frame="border" rules="all">
<span id="changed">|</span><caption>Tabelle 4. </caption>
<span id="changed">|</span><thead valign="bottom">
<span id="changed">|</span><tr valign="bottom">
<span id="changed">|</span><th id="wq58" align="left">Merkmalname</th>
<span id="changed">|</span><th id="wq59" align="left">Unterst&uuml;tzt</th>
<span id="changed">|</span></tr>
<span id="changed">|</span></thead>
<span id="changed">|</span><tbody valign="top">
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq58"><strong>javax.xml.stream.isRepairingNamespaces</strong></td>
<span id="changed">|</span><td headers="wq59">Ja</td>
<span id="changed">|</span></tr>
<span id="changed">|</span></tbody>
<span id="changed">|</span></table>
<span id="changed">|</span><p>
<span id="changed">|</span><a name="wq60"></a>
<span id="changed">|</span><h5 id="wq60">Referenzinformationen zu XMLStreamWriter</h5>
<span id="changed">|</span><p>Die folgenden Merkmale werden von der javax.xml.stream.XMLStreamWriter-Implementierung unterst&uuml;tzt. Sie werden unter <a href="http://java.sun.com/javase/6/docs/api/javax/xml/stream/XMLStreamWriter.html" target="_blank">XMLStreamWriter Javadoc</a> beschrieben.</p></p>
<span id="changed">|</span><a name="wq61"></a>
<span id="changed">|</span><table id="wq61" width="100%" summary="" border="1" frame="border" rules="all">
<span id="changed">|</span><caption>Tabelle 5. </caption>
<span id="changed">|</span><thead valign="bottom">
<span id="changed">|</span><tr valign="bottom">
<span id="changed">|</span><th id="wq62" align="left">Merkmalname</th>
<span id="changed">|</span><th id="wq63" align="left">Unterst&uuml;tzt</th>
<span id="changed">|</span></tr>
<span id="changed">|</span></thead>
<span id="changed">|</span><tbody valign="top">
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq62"><strong>javax.xml.stream.isRepairingNamespaces</strong></td>
<span id="changed">|</span><td headers="wq63">Ja</td>
<span id="changed">|</span></tr>
<span id="changed">|</span></tbody>
<span id="changed">|</span></table>
<span id="changed">|</span><p>Die Merkmale bei XMLStreamWriter-Objekten sind schreibgesch&uuml;tzt.</p><span id="changed">|</span>
<span id="changed">|</span><a name="xltxej_reference"></a>
<span id="changed">|</span><h4 id="xltxej_reference">Referenzinformationen zu XL TXE-J</h4>
<span id="changed">|</span><div>
<span id="changed">|</span><p>XL TXE-J ist eine XSLT-Bibliothek, die den Interpreter XSLT4J 2.7.8 und einen XSLT-Compiler umfasst.</p></div>
<span id="changed">|</span><p>
<span id="changed">|</span><a name="wq64"></a>
<span id="changed">|</span><h5 id="wq64">Funktionsvergleichstabelle</h5></p>
<span id="changed">|</span><a name="wq65"></a>
<span id="changed">|</span><table id="wq65" width="100%" summary="" border="1" frame="border" rules="all">
<span id="changed">|</span><caption>Tabelle 6. Vergleich der Features von XSLT4J-Interpreter, XSLT4J-Compiler und XL TXE-J-Compiler</caption>
<span id="changed">|</span><thead valign="bottom">
<span id="changed">|</span><tr valign="bottom">
<span id="changed">|</span><th id="wq66" width="46%" align="left">Funktion</th>
<span id="changed">|</span><th id="wq67" width="17%" align="left">XSLT4J-Interpreter (enthalten)</th>
<span id="changed">|</span><th id="wq68" width="17%" align="left">XSLT4J-Compiler (nicht enthalten)</th>
<span id="changed">|</span><th id="wq69" width="17%" align="left">XL TXE-J-Compiler (enthalten)</th>
<span id="changed">|</span></tr>
<span id="changed">|</span></thead>
<span id="changed">|</span><tbody valign="top">
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq66">http://javax.xml.transform.stream.StreamSource/feature - Funktion</td>
<span id="changed">|</span><td headers="wq67">Ja</td>
<span id="changed">|</span><td headers="wq68">Ja</td>
<span id="changed">|</span><td headers="wq69">Ja</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq66">http://javax.xml.transform.stream.StreamResult/feature - Funktion</td>
<span id="changed">|</span><td headers="wq67">Ja</td>
<span id="changed">|</span><td headers="wq68">Ja</td>
<span id="changed">|</span><td headers="wq69">Ja</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq66">http://javax.xml.transform.dom.DOMSource/feature - Funktion</td>
<span id="changed">|</span><td headers="wq67">Ja</td>
<span id="changed">|</span><td headers="wq68">Ja</td>
<span id="changed">|</span><td headers="wq69">Ja</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq66">http://javax.xml.transform.dom.DOMResult/feature - Funktion</td>
<span id="changed">|</span><td headers="wq67">Ja</td>
<span id="changed">|</span><td headers="wq68">Ja</td>
<span id="changed">|</span><td headers="wq69">Ja</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq66">http://javax.xml.transform.sax.SAXSource/feature - Funktion</td>
<span id="changed">|</span><td headers="wq67">Ja</td>
<span id="changed">|</span><td headers="wq68">Ja</td>
<span id="changed">|</span><td headers="wq69">Ja</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq66">http://javax.xml.transform.sax.SAXResult/feature - Funktion</td>
<span id="changed">|</span><td headers="wq67">Ja</td>
<span id="changed">|</span><td headers="wq68">Ja</td>
<span id="changed">|</span><td headers="wq69">Ja</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq66">http://javax.xml.transform.stax.StAXSource/feature - Funktion</td>
<span id="changed">|</span><td headers="wq67">Ja</td>
<span id="changed">|</span><td headers="wq68">Nein</td>
<span id="changed">|</span><td headers="wq69">Ja</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq66">http://javax.xml.transform.stax.StAXResult/feature - Funktion</td>
<span id="changed">|</span><td headers="wq67">Ja</td>
<span id="changed">|</span><td headers="wq68">Nein</td>
<span id="changed">|</span><td headers="wq69">Ja</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq66">http://javax.xml.transform.sax.SAXTransformerFactory/feature - Funktion</td>
<span id="changed">|</span><td headers="wq67">Ja</td>
<span id="changed">|</span><td headers="wq68">Ja</td>
<span id="changed">|</span><td headers="wq69">Ja</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq66">http://javax.xml.transform.sax.SAXTransformerFactory/feature/xmlfilter - Funktion</td>
<span id="changed">|</span><td headers="wq67">Ja</td>
<span id="changed">|</span><td headers="wq68">Ja</td>
<span id="changed">|</span><td headers="wq69">Ja</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq66">http://javax.xml.XMLConstants/feature/secure-processing - Funktion</td>
<span id="changed">|</span><td headers="wq67">Ja</td>
<span id="changed">|</span><td headers="wq68">Ja</td>
<span id="changed">|</span><td headers="wq69">Ja</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq66">http://xml.apache.org/xalan/features/incremental - Attribut</td>
<span id="changed">|</span><td headers="wq67">Ja</td>
<span id="changed">|</span><td headers="wq68">Nein</td>
<span id="changed">|</span><td headers="wq69">Nein</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq66">http://xml.apache.org/xalan/features/optimize - Attribut</td>
<span id="changed">|</span><td headers="wq67">Ja</td>
<span id="changed">|</span><td headers="wq68">Nein</td>
<span id="changed">|</span><td headers="wq69">Nein</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq66">http://xml.apache.org/xalan/properties/source-location - Attribut</td>
<span id="changed">|</span><td headers="wq67">Ja</td>
<span id="changed">|</span><td headers="wq68">Nein</td>
<span id="changed">|</span><td headers="wq69">Nein</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq66">Attribut 'translet-name'</td>
<span id="changed">|</span><td headers="wq67">nicht zutreffend</td>
<span id="changed">|</span><td headers="wq68">Ja</td>
<span id="changed">|</span><td headers="wq69">Ja (mit neuem Namen)</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq66">Attribut 'destination-directory'</td>
<span id="changed">|</span><td headers="wq67">nicht zutreffend</td>
<span id="changed">|</span><td headers="wq68">Ja</td>
<span id="changed">|</span><td headers="wq69">Ja (mit neuem Namen)</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq66">Attribut 'package-name'</td>
<span id="changed">|</span><td headers="wq67">nicht zutreffend</td>
<span id="changed">|</span><td headers="wq68">Ja</td>
<span id="changed">|</span><td headers="wq69">Ja (mit neuem Namen)</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq66">Attribut 'jar-name'</td>
<span id="changed">|</span><td headers="wq67">nicht zutreffend</td>
<span id="changed">|</span><td headers="wq68">Ja</td>
<span id="changed">|</span><td headers="wq69">Ja (mit neuem Namen)</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq66">Attribut 'generate-translet'</td>
<span id="changed">|</span><td headers="wq67">nicht zutreffend</td>
<span id="changed">|</span><td headers="wq68">Ja</td>
<span id="changed">|</span><td headers="wq69">Ja (mit neuem Namen)</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq66">Attribut 'auto-translet'</td>
<span id="changed">|</span><td headers="wq67">nicht zutreffend</td>
<span id="changed">|</span><td headers="wq68">Ja</td>
<span id="changed">|</span><td headers="wq69">Ja (mit neuem Namen)</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq66">Attribut 'use-classpath'</td>
<span id="changed">|</span><td headers="wq67">nicht zutreffend</td>
<span id="changed">|</span><td headers="wq68">Ja</td>
<span id="changed">|</span><td headers="wq69">Ja (mit neuem Namen)</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq66">Attribut 'enable-inlining'</td>
<span id="changed">|</span><td headers="wq67">Nein</td>
<span id="changed">|</span><td headers="wq68">Ja</td>
<span id="changed">|</span><td headers="wq69">Nein (in TL TXE-J veraltet)</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq66">Attribut 'indent-number'</td>
<span id="changed">|</span><td headers="wq67">Nein</td>
<span id="changed">|</span><td headers="wq68">Ja</td>
<span id="changed">|</span><td headers="wq69">Ja (mit neuem Namen)</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq66">Attribut 'debug'</td>
<span id="changed">|</span><td headers="wq67">Nein</td>
<span id="changed">|</span><td headers="wq68">Ja</td>
<span id="changed">|</span><td headers="wq69">Ja (mit neuem Namen)</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq66">Java-Erweiterungen</td>
<span id="changed">|</span><td headers="wq67">Ja</td>
<span id="changed">|</span><td colspan="2" headers="wq68 wq69">Ja (nur abgek&uuml;rzte Syntax, Konstrukte 'xalan:component/xalan:script' werden nicht unterst&uuml;tzt)</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq66">JavaScript-Erweiterungen</td>
<span id="changed">|</span><td headers="wq67">Ja</td>
<span id="changed">|</span><td headers="wq68">Nein</td>
<span id="changed">|</span><td headers="wq69">Nein</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq66">Erweiterungselemente</td>
<span id="changed">|</span><td headers="wq67">Ja</td>
<span id="changed">|</span><td headers="wq68">Nein</td>
<span id="changed">|</span><td headers="wq69">Nein</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq66">EXSLT-Erweiterungsfunktionen</td>
<span id="changed">|</span><td headers="wq67">Ja</td>
<span id="changed">|</span><td headers="wq68">Ja (au&szlig;er dynamischen)</td>
<span id="changed">|</span><td headers="wq69">Ja (au&szlig;er dynamischen)</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq66">Erweiterung 'redirect'</td>
<span id="changed">|</span><td headers="wq67">Ja</td>
<span id="changed">|</span><td headers="wq68">Ja (au&szlig;er 'redirect:open' und 'redirect:close')</td>
<span id="changed">|</span><td headers="wq69">Ja</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq66">Erweiterung 'output'</td>
<span id="changed">|</span><td headers="wq67">Nein</td>
<span id="changed">|</span><td headers="wq68">Ja</td>
<span id="changed">|</span><td headers="wq69">Ja</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq66">Erweiterung 'NodeSet'</td>
<span id="changed">|</span><td headers="wq67">Ja</td>
<span id="changed">|</span><td headers="wq68">Ja</td>
<span id="changed">|</span><td headers="wq69">Ja</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq66">Erweiterungsfunktionen 'NodeInfo'</td>
<span id="changed">|</span><td headers="wq67">Ja</td>
<span id="changed">|</span><td headers="wq68">Nein</td>
<span id="changed">|</span><td headers="wq69">Nein</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq66">SQL-Bibliothekserweiterung</td>
<span id="changed">|</span><td headers="wq67">Ja</td>
<span id="changed">|</span><td headers="wq68">Nein</td>
<span id="changed">|</span><td headers="wq69">Nein</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq66">Erweiterung 'pipeDocument'</td>
<span id="changed">|</span><td headers="wq67">Ja</td>
<span id="changed">|</span><td headers="wq68">Nein</td>
<span id="changed">|</span><td headers="wq69">Nein</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq66">Erweiterung 'evaluate'</td>
<span id="changed">|</span><td headers="wq67">Ja</td>
<span id="changed">|</span><td headers="wq68">Nein</td>
<span id="changed">|</span><td headers="wq69">Nein</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq66">Erweiterung 'tokenize'</td>
<span id="changed">|</span><td headers="wq67">Ja</td>
<span id="changed">|</span><td headers="wq68">Nein</td>
<span id="changed">|</span><td headers="wq69">Nein</td>
<span id="changed">|</span></tr>
<span id="changed">|</span><tr>
<span id="changed">|</span><td headers="wq66">XML 1.1</td>
<span id="changed">|</span><td headers="wq67">Ja</td>
<span id="changed">|</span><td headers="wq68">Ja</td>
<span id="changed">|</span><td headers="wq69">Ja</td>
<span id="changed">|</span></tr>
<span id="changed">|</span></tbody>
<span id="changed">|</span></table>
<span id="changed">|</span><p>
<span id="changed">|</span><a name="wq70"></a>
<span id="changed">|</span><h5 id="wq70">Hinweise</h5>
<span id="changed">|</span><p>Verwenden Sie mit dem Verarbeitungsbefehl (Process) die Option <strong>-FLAVOR sr2sw</strong> f&uuml;r eine Umsetzung mit Hilfe der StAX-Streamverarbeitung und <strong>-FLAVOR er2ew</strong> f&uuml;r die StAX-Ereignisverarbeitung.</p>
<span id="changed">|</span><p>Der neue Compiler sucht nicht nach dem
<span id="changed">|</span>Service-Provider org.apache.xalan.xsltc.dom.XSLTCDTMManager. Stattdessen schaltet der Compiler bei Verwendung von StreamSource auf einen leistungsf&auml;higen XML-Parser um.</p>
<span id="changed">|</span><p>Inlining ist in XL TXE-J nicht mehr erforderlich.
<span id="changed">|</span></p>
<span id="changed">|</span><ul>
<span id="changed">|</span><li>Die Option <strong>-XN</strong> f&uuml;r den Befehl Process wird stillschweigend ignoriert.</li>
<span id="changed">|</span><li>Die Option <strong>-n</strong> f&uuml;r den Befehl Compile wird stillschweigend ignoriert.</li>
<span id="changed">|</span><li>Das Attribut <strong>enable-inlining</strong> von Transformer-Factory wird stillschweigend ignoriert.</li></ul>
<span id="changed">|</span><p>Die Klasse org.apache.xalan.xsltc.trax.SmartTransformerFactoryImpl wird nicht mehr unterst&uuml;tzt.</p></p>
<span id="changed">|</span><a name="old_xerces"></a>
<span id="changed">|</span><h4 id="old_xerces">Verwenden einer &auml;lteren Version von Xerces oder Xalan</h4>
<span id="changed">|</span><div>
<span id="changed">|</span><p>Wenn Sie im &Uuml;berschreibungsverzeichnis eine &auml;lteren Version von Xerces (vor Version 2.0) oder Xalan (vor Version 2.3) verwenden, wird beim Starten der Anwendung m&ouml;glicherweise die Ausnahmebedingung NullPointerException angezeigt. Diese Ausnahmebedingung tritt auf, da bei
<span id="changed">|</span>&auml;lteren Versionen die Datei jaxp.properties nicht ordnungsgem&auml;&szlig; verarbeitet werden kann.</p></div>
<span id="changed">|</span><p>
<span id="changed">|</span><p>Gehen Sie wie folgt vor, um diesen Fehler zu umgehen: 
<span id="changed">|</span></p>
<span id="changed">|</span><ul>
<span id="changed">|</span><li>F&uuml;hren Sie ein Upgrade auf eine neuere Version der
<span id="changed">|</span>Anwendung aus, die die aktuelle JAXP-Spezifikation (Java API for XML
<span id="changed">|</span>Programming) implementiert (http://java.sun.com/xml/jaxp/index.html).</li>
<span id="changed">|</span><li>Entfernen Sie die Datei jaxp.properties aus /opt/ibm/java-i386-60/jre/lib.</li>
<span id="changed">|</span><li>Entfernen Sie die Kommentarzeichen in der Datei jaxp.properties in /opt/ibm/java-i386-60/jre/lib.</li>
<span id="changed">|</span><li>Legen Sie das Systemmerkmal f&uuml;r <strong>javax.xml.parsers.SAXParserFactory</strong>, <strong>javax.xml.parsers.DocumentBuilderFactory</strong> oder <strong>javax.xml.transform.TransformerFactory</strong> mit Hilfe der Befehlszeilenoption <strong>-D</strong> fest.</li>
<span id="changed">|</span><li>Legen Sie das Systemmerkmal f&uuml;r <strong>javax.xml.parsers.SAXParserFactory</strong>, <strong>javax.xml.parsers.DocumentBuilderFactory</strong> oder <strong>javax.xml.transform.TransformerFactory</strong> innerhalb des Anwendungscodes fest. Ein Beispiel hierzu finden Sie in der Spezifikation JAXP 1.4.</li>
<span id="changed">|</span><li>Definieren Sie SAXParserFactory, DocumentBuilderFactory oder TransformerFactory explizit unter Verwendung der Umgebungsvariablen <strong>IBM_JAVA_OPTIONS</strong>. Beispiel: 
<span id="changed">|</span><pre class="xmp">export IBM_JAVA_OPTIONS=-Djavax.xml.parsers.SAXParserFactory=
<span id="changed">|</span>    org.apache.xerces.jaxp.SAXParserFactoryImpl </pre>oder 
<span id="changed">|</span><pre class="xmp">export IBM_JAVA_OPTIONS=-Djavax.xml.parsers.DocumentBuilderFactory=
<span id="changed">|</span>    org.apache.xerces.jaxp.DocumentBuilderFactoryImpl</pre>oder  
<span id="changed">|</span><pre class="xmp">export IBM_JAVA_OPTIONS=-Djavax.xml.transform.TransformerFactory=
<span id="changed">|</span>    org.apache.xalan.processor.TransformerFactoryImpl  </pre></li></ul></p></font>
<a name="debugger"></a>
<h2 id="debugger"><a href="#ToC_62">Debugging in Java-Anwendungen</a></h2>
<div>
<p>Zur Fehlerbehebung in Java-Programmen k&ouml;nnen Sie den Java-Debugger (JDB) oder andere Debugger
verwenden, die &uuml;ber die JPDA (Java Platform Debugger Architecture) kommunizieren, die in SDK for Linux enthalten ist.</p></div>
<p>Weitere Informationen zur Problemdiagnose unter Verwendung von  Java finden Sie im Handbuch <a href="http://www.ibm.com/developerworks/java/jdk/diagnosis/60.html" target="_blank">Diagnostics Guide</a>.</p>
<a name="jdb"></a>
<h3 id="jdb"><a href="#ToC_63">Java-Debugger (JDB)</a></h3>
<div>
<p>Der Java-Debugger (JDB) ist in SDK for Linux enthalten. Dieser Debugger wird &uuml;ber den Befehl
jdb aufgerufen. Er wird JVM &uuml;ber die JPDA zugeordnet.</p></div>
<p>
<p> Gehen Sie zur Fehlerbehebung in Java-Anwendungen wie folgt vor: 
</p>
<ol type="1">
<li id="jdb__jdb_start_jvm">
<a name="jdb__jdb_start_jvm"></a>Starten Sie JVM unter Angabe folgender Optionen: 
<pre class="xmp">java -Xdebug -Xrunjdwp:transport=dt_socket,server=y,address=<em>&lt;Port&gt;</em> <em>&lt;Klasse&gt;</em></pre>Daraufhin startet JVM. Vor dem Starten der Java-Anwendung wird die Ausf&uuml;hrung jedoch ausgesetzt.</li>
<li>Sie k&ouml;nnen den Debugger in einer separaten Sitzung &uuml;ber folgenden Befehl JVM zuordnen: 
<pre class="xmp">jdb -attach <em>&lt;Port&gt;</em></pre>Der Debugger wird daraufhin JVM zugeordnet, und Sie k&ouml;nnen
eine Reihe von Befehlen zur &Uuml;berpr&uuml;fung und Steuerung der Java-Anwendung ausf&uuml;hren. Mit dem Befehl
<tt class="xph">run</tt> k&ouml;nnen Sie die Java-Anwendung beispielsweise starten.</li></ol></p>
<p>
<p>Wenn Sie weitere Informationen zu JDB-Optionen aufrufen m&ouml;chten, geben Sie Folgendes ein: </p>
<pre class="xmp">jdb -help</pre><p class="indatacontent">Wenn Sie weitere Informationen zu JDB-Befehlen aufrufen m&ouml;chten: 
</p>
<ol type="1">
<li>Geben Sie <tt class="xph">jdb</tt> ein.</li>
<li>Geben Sie an der jdb-Eingabeaufforderung <tt class="xph">help</tt> ein.</li></ol></p>
<p>
<p>Sie k&ouml;nnen JDB au&szlig;erdem f&uuml;r die Fehlerbehebung in Java-Anwendungen auf fernen Maschinen verwenden. JPDA verwendet ein TCP/IP-Socket f&uuml;r die Verbindung mit der fernen JVM. 
</p>
<ol type="1">
<li>Starten Sie JVM unter Angabe folgender Optionen: 
<pre class="xmp">java -Xdebug -Xrunjdwp:transport=dt_socket,server=y,address=<em>&lt;Port&gt;</em> <em>&lt;Klasse&gt;</em></pre>Daraufhin startet JVM. Vor dem Starten der Java-Anwendung wird die Ausf&uuml;hrung jedoch ausgesetzt.</li>
<li>Ordnen Sie den Debugger mit folgendem Befehl der fernen JVM zu: 
<pre class="xmp">jdb -attach <em>&lt;Host&gt;</em>:<em>&lt;Port&gt;</em></pre></li></ol></p>
<p>
<p>Die JVMDI (Java Virtual Machine Debugging Interface) wird in diesem Release nicht unterst&uuml;tzt. Sie wurde durch die JVMTI (Java Virtual Machine Tool Interface) ersetzt.</p></p>
<p>
<p>Weitere Informationen zu JDB und JPDA sowie deren Verwendung finden Sie auf den folgenden Websites:  
</p>
<ul>
<li><a href="http://java.sun.com/products/jpda/" target="_blank">http://java.sun.com/products/jpda/</a></li>
<li><a href="http://java.sun.com/javase/6/docs/technotes/guides/jpda/" target="_blank">http://java.sun.com/javase/6/docs/technotes/guides/jpda/</a></li>
<li><a href="http://java.sun.com/javase/6/docs/technotes/guides/jpda/jdb.html" target="_blank">http://java.sun.com/javase/6/docs/technotes/guides/jpda/jdb.html</a></li></ul></p>
<a name="bit_check"></a>
<h2 id="bit_check"><a href="#ToC_64">Ermitteln, ob eine Anwendung auf JVM im 32-Bit- oder 64-Bit-Modus ausgef&uuml;hrt wird</a></h2>
<div>
<p>Einige Java-Anwendungen m&uuml;ssen in der Lage sein zu ermitteln, ob sie auf JVM im 32-Bit- oder 64-Bit-Modus ausgef&uuml;hrt werden. Falls Ihre Anwendung beispielsweise &uuml;ber eine Bibliothek mit nativem Code
verf&uuml;gt, muss die Bibliothek f&uuml;r Plattformen, die sowohl den 32-Bit- als auch den 64-Bit-Betriebsmodus unterst&uuml;tzen, separat im 32-Bit- und im 64-Bit-Format kompiliert werden. In diesem Fall muss die Anwendung w&auml;hrend der Laufzeit die richtige Bibliothek laden,
da der 32-Bit- und der 64-Bit-Code nicht miteinander kombiniert werden k&ouml;nnen.</p></div>
<p>
<p>Mit Hilfe des Systemmerkmals <strong>com.ibm.vm.bitmode</strong> k&ouml;nnen Anwendungen den Modus ermitteln,
in dem JVM ausgef&uuml;hrt wird. Es werden folgende Werte zur&uuml;ckgegeben:  
</p>
<ul>
<li>32 - JVM wird im 32-Bit-Modus  ausgef&uuml;hrt (31-Bit-Modus f&uuml;r Linux auf System z)</li>
<li>64 - JVM wird im 64-Bit-Modus ausgef&uuml;hrt</li></ul><p class="indatacontent">Mit dem folgenden Aufruf k&ouml;nnen Sie das Systemmerkmal <strong>com.ibm.vm.bitmode</strong> innerhalb des Anwendungscodes &uuml;berpr&uuml;fen: </p>
<pre class="xmp">System.getProperty("com.ibm.vm.bitmode");</pre></p>
<a name="signals"></a>
<h2 id="signals"><a href="#ToC_65">Signalverarbeitung durch JVM</a></h2>
<div>
<p>Wenn ein f&uuml;r Java Virtual Machine (JVM) wichtiges Signal gesendet wird, wird eine Signalroutine aufgerufen. Diese Signalroutine legt fest, ob das Signal f&uuml;r einen Java- oder
Nicht-Java-Thread aufgerufen wurde.</p></div>
<p>Wurde das Signal f&uuml;r einen Java-Thread aufgerufen, steuert JVM die Signalverarbeitung. Wenn eine Anwendungsroutine f&uuml;r dieses Signal installiert ist, und Sie die Befehlszeilenoption <strong>-Xnosigchain</strong> nicht angegeben haben, wird die Anwendungsroutine f&uuml;r dieses Signal aufgerufen, nachdem JVM die Verarbeitung abgeschlossen hat.</p>
<p>Wurde das Signal f&uuml;r einen Nicht-Java-Thread aufgerufen und wurde
zuvor mit der Anwendung, mit der JVM installiert wurde, eine
eigene Routine f&uuml;r das Signal installiert, &uuml;bernimmt diese
Signalroutine die Steuerung. Wenn das Signal jedoch von JVM oder der Java-Anwendung angefordert wird, wird es ignoriert, oder die Standardaktion wird ausgef&uuml;hrt.</p>
<p>JVM f&uuml;hrt f&uuml;r Signale bei Ausnahmebedingungen und f&uuml;r
Fehlersignale eine der folgenden Aktionen aus:  
</p>
<ul>
<li>Verarbeiten der Bedingung und Wiederherstellung</li>
<li>Beginnen einer Sequenz f&uuml;r einen kontrollierten Systemabschluss. Dabei werden die folgenden Aktionen ausgef&uuml;hrt:  

<ol type="1">
<li>Erstellen von Speicherausz&uuml;gen, um den JVM-Status am Fehlerpunkt zu beschreiben</li>
<li>Aufrufen der Signalroutine Ihrer Anwendung f&uuml;r dieses Signal</li>
<li>Aufrufen eines beliebigen durch die Anwendung installierten Abbruchhooks</li>
<li>Ausf&uuml;hren der erforderlichen Bereinigung f&uuml;r einen ordnungsgem&auml;&szlig;en Systemabschluss</li></ol></li></ul>Informationen zum Schreiben eines Startprogramms, das die oben aufgef&uuml;hrten Hooks angibt, finden Sie unter der folgenden Adresse: <a href="http://www.ibm.com/developerworks/java/library/i-signalhandling/" target="_blank">http://www.ibm.com/developerworks/java/library/i-signalhandling/</a>. Dieser Abschnitt wurde f&uuml;r Java Version 1.3.1 geschrieben, gilt jedoch auch f&uuml;r sp&auml;tere Versionen.
<p>Bei Interruptsignalen beginnt JVM ebenfalls eine Sequenz f&uuml;r einen kontrollierten Systemabschluss, der jedoch in diesem Fall wie eine normale Beendigung behandelt wird. Hierbei f&uuml;hrt JVM die folgenden Aktionen aus:
</p>
<ol type="1">
<li>Aufrufen der Signalroutine Ihrer Anwendung f&uuml;r dieses Signal.</li>
<li>Ausf&uuml;hren aller Hooks f&uuml;r das Beenden der Anwendung.</li>
<li>Aufrufen eines beliebigen durch die Anwendung installierten Exit-Hooks.</li>
<li>Ausf&uuml;hren der erforderlichen JVM-Bereinigung.</li></ol>
<p>Der Systemabschluss entspricht dem Systemabschluss, der &uuml;ber einen Aufruf
der Java-Methode <tt class="xph">System.exit()</tt> eingeleitet wurde.</p>
<p>Weitere von JVM verwendete Signale werden f&uuml;r die interne
Steuerung verwendet und f&uuml;hren nicht zur Beendigung von JVM. Das einzige wichtige Steuerungssignal ist
SIGQUIT, durch
das ein Java-Speicherauszug generiert wird.</p>
<a name="sighand"></a>
<h3 id="sighand"><a href="#ToC_66">Von JVM verwendete Signale</a></h3>
<div>
<p>Die Signaltypen sind Ausnahmebedingungen, Fehler, Interrupts und Steuerzeichen.</p></div>
<p>
<p>In <a href="#sighand__sig_table">Tabelle 7</a> sind die von JVM verwendeten Signale aufgef&uuml;hrt. Die Signale werden in der Tabelle nach Typ oder Verwendung wie folgt
zusammengefasst: 
</p>
<dl>
<dt class="bold">Ausnahmebedingungen</dt>
<dd>Das Betriebssystem setzt beim Auftreten einer schwer wiegenden Bedingung ein entsprechendes Signal zum Anzeigen einer Ausnahmebedingung ab.
</dd>
<dt class="bold">Fehler</dt>
<dd>JVM setzt ein Signal SIGABRT ab, wenn es eine Bedingung feststellt, aus der keine Wiederherstellung m&ouml;glich ist.
</dd>
<dt class="bold">Interrupts</dt>
<dd>Interruptsignale werden au&szlig;erhalb eines JVM-Prozesses asynchron abgesetzt, um einen
Systemabschluss anzufordern.
</dd>
<dt class="bold">Steuerzeichen</dt>
<dd>Hierbei handelt es sich um andere Signale, die von JVM zu Steuerungszwecken verwendet werden.
</dd>
</dl><p class="indatacontent">
</p>
<a name="sighand__sig_table"></a>
<table id="sighand__sig_table" width="100%" summary="" border="1" frame="border" rules="all">
<caption>Tabelle 7. Von JVM verwendete Signale</caption>
<thead valign="bottom">
<tr>
<th id="wq84" width="25%" align="left">Signalname</th>
<th id="wq85" width="25%" align="left">Signaltyp</th>
<th id="wq86" width="25%" align="left">Beschreibung</th>
<th id="wq87" width="25%" align="left">Inaktiviert durch -Xrs</th>
</tr>
</thead>
<tbody valign="top">
<tr>
<td headers="wq84">SIGBUS (7)</td>
<td headers="wq85">Ausnahmebedingung</td>
<td headers="wq86">Falscher Zugriff auf den Speicher (falsche Datenanordnung)</td>
<td align="center" headers="wq87">Ja</td>
</tr>
<tr>
<td headers="wq84">SIGSEGV (11)</td>
<td headers="wq85">Ausnahmebedingung</td>
<td headers="wq86">Falscher Zugriff auf den Speicher (es wurden Daten
in einen Speicherbereich geschrieben, auf den nicht zugegriffen werden kann).</td>
<td align="center" headers="wq87">Ja</td>
</tr>
<tr>
<td headers="wq84">SIGILL (4)</td>
<td headers="wq85">Ausnahmebedingung</td>
<td headers="wq86">Nicht zul&auml;ssige Anweisung (es wurde versucht, eine
unbekannte Maschineninstruktion aufzurufen).</td>
<td align="center" headers="wq87">Nein</td>
</tr>
<tr>
<td headers="wq84">SIGFPE (8)</td>
<td headers="wq85">Ausnahmebedingung</td>
<td headers="wq86">Ausnahmebedingung bei der Gleitkommaverarbeitung
(Division durch null).</td>
<td align="center" headers="wq87">Ja</td>
</tr>
<tr>
<td headers="wq84">SIGABRT (6)</td>
<td headers="wq85">Fehler</td>
<td headers="wq86">Abnormale Beendigung. JVM setzt dieses Signal ab, sobald ein JVM-Fehler festgestellt wird.</td>
<td align="center" headers="wq87">Ja</td>
</tr>
<tr>
<td headers="wq84">SIGINT (2)</td>
<td headers="wq85">Interrupt</td>
<td headers="wq86">Interaktiver Abruf (Strg-C). JVM wird normal beendet.</td>
<td align="center" headers="wq87">Ja</td>
</tr>
<tr>
<td headers="wq84">SIGTERM (15)</td>
<td headers="wq85">Interrupt</td>
<td headers="wq86">Beendigungsanforderung. JVM wird normal beendet.</td>
<td align="center" headers="wq87">Ja</td>
</tr>
<tr>
<td headers="wq84">SIGHUP (1)</td>
<td headers="wq85">Interrupt</td>
<td headers="wq86">Auflegen. JVM wird normal beendet.</td>
<td align="center" headers="wq87">Ja</td>
</tr>
<tr>
<td headers="wq84">SIGQUIT (3)</td>
<td headers="wq85">Steuerzeichen</td>
<td headers="wq86">Ein Beendigungssignal f&uuml;r ein Terminal. Standardm&auml;&szlig;ig wird dadurch ein
Java-Speicherauszug ausgel&ouml;st.</td>
<td align="center" headers="wq87">Ja</td>
</tr>
<tr>
<td headers="wq84">SIGTRAP (5)</td>
<td headers="wq85">Steuerzeichen</td>
<td headers="wq86">Vom JIT-Compiler verwendet.</td>
<td align="center" headers="wq87">Ja</td>
</tr>
<tr>
<td headers="wq84">__SIGRTMAX - 2</td>
<td headers="wq85">Steuerzeichen</td>
<td headers="wq86">Von SDK verwendet.</td>
<td align="center" headers="wq87">Nein</td>
</tr>
<tr>
<td headers="wq84">SIGCHLD (17)</td>
<td headers="wq85">Steuerzeichen</td>
<td headers="wq86">Von SDK f&uuml;r die interne Steuerung verwendet.</td>
<td align="center" headers="wq87">Nein</td>
</tr>
</tbody>
</table></p>
<p>
<p>Mit Hilfe der Option <strong>-Xrs</strong> (Reduzierung der Verwendung von Signalen) k&ouml;nnen Sie verhindern, dass JVM die meisten Signale verarbeitet. Weitere Informationen hierzu finden Sie auf der <a href="http://java.sun.com/javase/6/docs/technotes/tools/windows/java.html" target="_blank"> Sun-Website zum Startprogramm f&uuml;r Java-Anwendungen</a>.</p></p>
<p>
<p>Die Signale 1 (SIGHUP), 2 (SIGINT), 4 (SIGILL), 7 (SIGBUS), 8 (SIGFPE), 11 (SIGSEGV) und 15 (SIGTERM) f&uuml;r JVM-Threads f&uuml;hren zur Beendigung von JVM. Daher sollte eine Anwendungssignalroutine bei diesen Signalen keine Wiederherstellung versuchen, es sei denn, JVM wird nicht mehr ben&ouml;tigt.</p></p>
<a name="native_signals"></a>
<h3 id="native_signals"><a href="#ToC_67">Verbinden eines nativen Codetreibers mit
der Signalverkettungsbibliothek</a></h3>
<div>
<p>Runtime Environment enth&auml;lt eine Signalverkettungsfunktion. Die Signalverkettung erm&ouml;glicht eine effizientere Interaktion von JVM
mit nativem Code, der eigene Signalroutinen installiert.</p></div>
<p>
<p>Mit der Signalverkettungsfunktion kann eine
Anwendung mit der gemeinsam genutzten Bibliothek libjsig.so verbunden werden und diese Bibliothek vor den Systembibliotheken geladen werden. Mit Hilfe der Bibliothek libjsig.so wird sichergestellt, dass Aufrufe wie z.&nbsp;B. signal(), sigset()
und sigaction() abgefangen werden, so dass die JVM-Signalroutinen nicht durch die zugeh&ouml;rigen Routinen ersetzt werden. Stattdessen werden die neuen Signalroutinen durch diese Aufrufe gesichert oder nach den durch JVM installierten Signalroutinen hinzugef&uuml;gt. Wenn diese Signale zu einem sp&auml;teren Zeit gesendet werden und nicht an JVM gerichtet sind, werden die vorinstallierten Signalroutinen aufgerufen.</p>
<p>Wenn Sie Signalroutinen installieren, die sigaction() verwenden, werden einige <strong>sa_flags</strong> nicht &uuml;berwacht, wenn JVM das Signal verwendet. Dabei handelt es sich um folgende Markierungen:
</p>
<ul>
<li>SA_NOCLDSTOP - Diese Option ist niemals festgelegt.</li>
<li>SA_NOCLDWAIT - Diese Option ist niemals festgelegt.</li>
<li>SA_RESTART - Wird in jedem Fall definiert.</li></ul>
<p>Die Bibliothek libjsig.so verdeckt auch JVM-Signalroutinen vor der Anwendung. Daher geben Aufrufe wie signal(), sigset() und sigaction(), die nach dem Starten von JVM ausgef&uuml;hrt werden, keinen Verweis mehr auf die JVM-Signalroutine, sondern auf eine beliebige vor dem Starten von JVM installierte Routine zur&uuml;ck.</p>
<p>F&uuml;hren Sie die folgenden Schritte aus, um
libjsig.so zu verwenden: 
</p>
<ul>
<li>Stellen Sie eine Verbindung zu der Anwendung her, die JVM erstellt oder integriert: 
<pre class="xmp">gcc -L$JAVA_HOME/bin -ljsig -L$JAVA_HOME/bin/j9vm -ljvm Java-Anwendung.c</pre>oder</li>
<li>Verwenden Sie die Umgebungsvariable <strong>LD_PRELOAD</strong>: 
<pre class="xmp">export LD_PRELOAD=$JAVA_HOME/bin/libjsig.so; Java-Anwendung (bash und ksh)

setenv LD_PRELOAD=$JAVA_HOME/bin/libjsig.so; Java-Anwendung (csh)</pre></li></ul>
<p>Die Umgebungsvariable <strong>JAVA_HOME</strong> muss auf die Speicherposition des SDK gesetzt werden. Beispiel: /opt/ibm/java-i386-60/.</p>
<p>F&uuml;hren Sie die folgenden Schritte aus, um libjsig.a zu verwenden: 
</p>
<ul>
<li>Stellen Sie eine Verbindung zu der Anwendung her, die JVM erstellt oder integriert: 
<pre class="xmp">cc_r -q64 &lt;Anderer Kompilierungs-/Verkn&uuml;pfungsparameter&gt; -L/opt/ibm/java-i386-60/jre/bin -ljsig 
-L/opt/ibm/java-i386-60/jre/bin/j9vm -ljvm java_application.c</pre> 
<a name="wq91"></a>
<div class="note-noindent" id="wq91">
<span class="notetitle">Anmerkung:</span> <span class="notebody">Verwenden Sie <tt class="xph">xlc_r</tt> oder <tt class="xph">xlC_r</tt> an Stelle von <tt class="xph">cc_r</tt>, wenn Sie normalerweise auf diese Weise den Compiler oder Linker aufrufen.</span></div></li></ul></p>
<a name="usejni"></a>
<h2 id="usejni"><a href="#ToC_68">Schreiben von JNI-Anwendungen</a></h2>
<div>
<p>G&uuml;ltige JNI-Versionsnummmern, die &uuml;ber native Programme im API-Aufruf 'JNI_CreateJavaVM()'
angegeben werden k&ouml;nnen, lauten wie folgt: JNI_VERSION_1_2(0x00010002) und JNI_VERSION_1_4(0x00010004).</p></div>
<a name="wq92"></a>
<div class="note-noindent" id="wq92">
<span class="notetitle">Einschr&auml;nkung:</span> <span class="notebody">Version 1.1 der JNI (Java Native Interface) wird nicht unterst&uuml;tzt.</span></div>
<p>&Uuml;ber diese Versionsnummer wird lediglich die Version der zu verwendenden
nativen JNI-Schnittstelle festgelegt. Die tats&auml;chliche JVM-Version, die erstellt wird,
wird &uuml;ber die JSE-Bibliotheken angegeben (d.&nbsp;h.
V6).
Die JNI-Schnittstellen-API hat <em>keine</em>
Auswirkungen auf die Sprachenspezifikation, die &uuml;ber JVM, die APIs der Klassenbibliothek oder
einen anderen Bereich mit JVM-Funktionen implementiert wird. Weitere Informationen finden Sie unter <a href="http://java.sun.com/javase/6/docs/technotes/guides/jni/" target="_blank">http://java.sun.com/javase/6/docs/technotes/guides/jni/</a>.</p>
<p>Falls f&uuml;r Ihre Anwendung zwei JNI-Bibliotheken erforderlich sind
(f&uuml;r 32 und 64 Bit), verwenden Sie das Systemmerkmal
<strong>com.ibm.vm.bitmode</strong>, um festzustellen, ob JVM derzeit im 32- oder 64-Bit-Modus ausgef&uuml;hrt
wird, und w&auml;hlen Sie dann die geeignete Bibliothek aus.</p>
<p>Verwenden Sie zum Kompilieren und Verkn&uuml;pfen einer nativen Anwendung
mit SDK folgenden Befehl: </p>
<pre class="xmp">gcc -I/opt/ibm/java-i386-60/include -L/opt/ibm/java-i386-60/jre/lib/&lt;Architektur&gt;/j9vm 
-ljvm -ldl -lpthread &lt;JNI-Programmdateiname&gt;</pre><p class="indatacontent">Die Option <strong>-ljvm</strong> gibt an, dass libjvm.so die gemeinsam genutzte Bibliothek ist, &uuml;ber die JVM implementiert wird. Die Option <strong>-lpthread</strong> gibt an, dass die Unterst&uuml;tzung f&uuml;r native Pthreads aktiviert ist. Falls Sie keine Verbindung zur Pthread-Bibliothek hergestellt haben,
tritt beim Ausf&uuml;hren des JNI-Programms m&ouml;glicherweise ein Segmentierungsfehler (Signal SIGSEGV) auf.</p>
<a name="blocked_threads"></a>
<h2 id="blocked_threads"><a href="#ToC_69">Unterst&uuml;tzung f&uuml;r die Wiederherstellung von blockierten Verbindungen auf Threadebene</a></h2>
<div>
<p>Dem Paket com.ibm.jvm wurden zur Unterst&uuml;tzung f&uuml;r die Wiederherstellung von blockierten Verbindungen auf Threadebene vier neue IBM spezifische SDK-Klassen hinzugef&uuml;gt. Die neuen Klassen befinden sich in der Datei core.jar.</p></div>
<p>Diese Klassen erm&ouml;glichen die Aufhebung der Blockierung von Threads, die im Netzbetrieb oder bei Synchronisationsaufrufen auftrat. Wenn eine Anwendung diese Klassen nicht verwendet, muss sie den gesamten Vorgang beenden, anstatt ein einzelnes blockiertes Thread zu unterbrechen.</p>
<p>Die folgenden Klassen sind verf&uuml;gbar:</p>
<dl class="parml">
<dt class="bold">InterruptibleContext (allgemein zug&auml;ngliche Schnittstelle)</dt>
<dd>Definiert die beiden Methoden isBlocked() und unblock().
Die drei weiteren Klassen implementieren InterruptibleContext.
</dd>
<dt class="bold">InterruptibleLockContext (&ouml;ffentliche Klasse)</dt>
<dd>Eine Dienstprogrammklasse f&uuml;r die Unterbrechung von Synchronisationsaufrufen.
</dd>
<dt class="bold">InterruptibleIOContext (&ouml;ffentliche Klasse)</dt>
<dd>Eine Dienstprogrammklasse f&uuml;r die Unterbrechung von Synchronisationsaufrufen.
</dd>
<dt class="bold">InterruptibleThread (&ouml;ffentliche Klasse)</dt>
<dd>Eine Dienstprogrammklasse zur Erweiterung von java.lang.Thread, um die Wiederverwendung von Methoden zu erm&ouml;glichen, die unterbrochen werden k&ouml;nnen. Sie verwendet Instanzen der Klassen InterruptibleLockContext und InterruptibleIOContext, um die erforderlichen Methoden isBlocked() und unblock() auszuf&uuml;hren, abh&auml;ngig davon, ob ein Synchronisations- oder Netzbetriebsprozess den Thread blockiert.
</dd>
</dl>
<p>Die Klassen InterruptibleLockContext und InterruptibleIOContext funktionieren beide durch Verweis auf den aktuellen Thread. Wenn Sie die Klasse InterruptibleThread nicht verwenden, m&uuml;ssen Sie daher zum Verwenden dieser neuen Klassen eine eigene Klasse bereitstellen, durch die java.lang.Thread erweitert wird.</p>
<p>Die Javadoc-Komponente f&uuml;r diese Klassen wird mit dem SDK in der Datei docs/content/apidoc.zip mitgeliefert.</p>
<a name="alloc_large_page"></a>
<h2 id="alloc_large_page"><a href="#ToC_70">Konfigurieren einer Speicherzuordnung von gro&szlig;en Seiten</a></h2>
<div>
<p>Sie k&ouml;nnen die Unterst&uuml;tzung f&uuml;r gro&szlig;e Seiten auf Systemen aktivieren, die dies unterst&uuml;tzen.
Starten Sie dazu Java unter Angabe der Option <strong>-Xlp</strong>.</p></div>
<p>
<p>Gro&szlig;e Seiten werden in erster Linie verwendet, um Leistungssteigerungen in Anwendungen zu erzielen, die gro&szlig;e Speichermengen zuordnen und h&auml;ufig auf diesen Speicher zugreifen. Die Leistungssteigerungen durch die Verwendung gro&szlig;er Seiten werden haupts&auml;chlich durch die geringe Anzahl Fehlschl&auml;ge im Translation Lookaside Buffer (TLB) erzielt.
Der TLB ordnet einen gr&ouml;&szlig;eren Bereich an virtuellem Speicher zu,
und daraus ergeben sich die Leistungssteigerungen.</p>
<p>Die Unterst&uuml;tzung f&uuml;r gro&szlig;e Seiten muss im Kernel verf&uuml;gbar und aktiviert sein,
damit Java gro&szlig;e Seiten verwenden kann.</p>
<p>Stellen Sie zum Konfigurieren einer Speicherzuordnung von gro&szlig;en Seiten zun&auml;chst sicher, dass der aktive Kernel gro&szlig;e Seiten unterst&uuml;tzt. &Uuml;berpr&uuml;fen Sie, dass die Datei /proc/meminfo die folgenden Zeilen enth&auml;lt:  </p>
<pre class="xmp">HugePages_Total:     &lt;Anzahl Seiten&gt;
HugePages_Free:      &lt;Anzahl Seiten&gt;
Hugepagesize:        &lt;Seitengr&ouml;&szlig;e in KB&gt;</pre><p class="indatacontent">Die Anzahl verf&uuml;gbarer Seiten und deren Gr&ouml;&szlig;e
ist je nach Distribution unterschiedlich.</p>
<p>Falls die Unterst&uuml;tzung f&uuml;r gro&szlig;e Seiten nicht im Kernel verf&uuml;gbar ist,
sind die entsprechenden Zeilen nicht in der Datei /proc/meminfo vorhanden. In diesem Fall m&uuml;ssen Sie einen neuen Kernel installieren, der gro&szlig;e Seiten unterst&uuml;tzt.</p>
<p>Falls die Unterst&uuml;tzung f&uuml;r gro&szlig;e Seiten zwar verf&uuml;gbar, jedoch nicht aktiviert ist,
hat <tt class="xph">HugePages_Total</tt> den Wert 0. Dann muss der zust&auml;ndige Administrator die Unterst&uuml;tzung f&uuml;r gro&szlig;e Seiten aktivieren. Weitere Anweisungen hierzu finden Sie im Handbuch zum Betriebssystem.</p>
<p>Damit JVM gro&szlig;e Seiten verwendet, muss auf Ihrem System eine ausreichende Anzahl zusammenh&auml;ngender gro&szlig;er Seiten verf&uuml;gbar sein. Sollte es nicht m&ouml;glich sein, gro&szlig;e Seiten zuzuordnen, selbst wenn gen&uuml;gend Seiten
verf&uuml;gbar sind, h&auml;ngen die gro&szlig;en Seiten m&ouml;glicherweise nicht zusammen. Beim Konfigurieren der Anzahl gro&szlig;er Seiten w&auml;hrend des Systemstarts
werden diese als zusammenh&auml;ngende Seiten erstellt.</p>
<p>Die Zuordnung gro&szlig;er Seiten ist nur m&ouml;glich, wenn JVM &uuml;ber Rootberechtigung verf&uuml;gt. Zur Verwendung gro&szlig;er Seiten f&uuml;hren Sie Java als Root aus, oder Sie legen das SUID-Bit des Java-Startprogramms fest.</p></p>
<a name="corba"></a>
<h2 id="corba"><a href="#ToC_71">CORBA-Unterst&uuml;tzung</a></h2>
<div>
<p>Java Platform, Standard Edition (JSE)
unterst&uuml;tzt mindestens die Spezifikationen, die in der Erf&uuml;llungsbest&auml;tigung von Sun definiert sind. In einigen F&auml;llen unterst&uuml;tzt IBM JSE ORB neuere Versionen der Spezifikationen.</p></div>
<p>Die unterst&uuml;tzten Mondestspezifikationen sind in <a href="http://java.sun.com/javase/6/docs/api/org/omg/CORBA/doc-files/compliance.html" target="_blank">Offizielle Spezifikationen f&uuml;r die CORBA-Unterst&uuml;tzung in Java SE
6</a> definiert.</p>
<p>
<a name="corba__corba_giop"></a>
<h3 id="corba__corba_giop">Unterst&uuml;tzung f&uuml;r GIOP 1.2</h3>
<p>Wie in Kapitel 13 und 15 der Spezifikation CORBA 2.3.1 (OMG-Dokument <cite>formal/99-10-07</cite>) beschrieben, unterst&uuml;tzt SDK alle GIOP-Versionen.</p>
<p><a href="http://www.omg.org/cgi-bin/doc?formal/99-10-07" target="_blank">http://www.omg.org/cgi-bin/doc?formal/99-10-07</a></p>
<p>Bidirektionales GIOP wird nicht unterst&uuml;tzt.</p></p>
<p>
<a name="corba__corba_support_intercepters"></a>
<h3 id="corba__corba_support_intercepters">Unterst&uuml;tzung f&uuml;r portierbare Abfangprozesse</h3>
<p>Wie von der OMG (Object Management Group) im Dokument <cite>ptc/01-03-04</cite> beschrieben, unterst&uuml;tzt SDK portierbare Abfangprozesse. Sie k&ouml;nnen dieses Dokument unter der folgenden Adresse abrufen:</p>
<p><a href="http://www.omg.org/cgi-bin/doc?ptc/01-03-04" target="_blank">http://www.omg.org/cgi-bin/doc?ptc/01-03-04</a></p>
<p>Portierbare Abfangprozesse sind Hooks in den ORB (Object Request Broker), &uuml;ber die ORB-Services den normalen Ausf&uuml;hrungsablauf des ORBs unterbrechen k&ouml;nnen.</p></p>
<p>
<a name="corba__corba_interop_naming"></a>
<h3 id="corba__corba_interop_naming">Unterst&uuml;tzung f&uuml;r den Interoperable Naming Service</h3>
<p>Wie von der OMG im Dokument <cite>ptc/00-08-07</cite> beschrieben, unterst&uuml;tzt SDK den Interoperable Naming Service. Sie k&ouml;nnen dieses Dokument unter der folgenden Adresse abrufen:</p>
<p><a href="http://www.omg.org/cgi-bin/doc?ptc/00-08-07" target="_blank">http://www.omg.org/cgi-bin/doc?ptc/00-08-07</a></p>
<p>Der Standardport, der vom Transient Name Server (Befehl tnameserv) verwendet wird, wenn der Parameter <strong>ORBInitialPort</strong> nicht angegeben ist, wurde von <em>900</em> in <em>2809</em> ge&auml;ndert. Dies ist die Portnummer, die zusammen mit der IANA (Internet Assigned Number Authority) f&uuml;r einen CORBA Naming Service registriert wird.
Programme, die von dieser Standardeinstellung abh&auml;ngig sind, m&uuml;ssen m&ouml;glicherweise aktualisiert werden, um mit dieser Version arbeiten zu k&ouml;nnen.</p>
<p>Der Ausgangskontext, der vom Transient Name Server zur&uuml;ckgegeben wird, lautet jetzt org.omg.CosNaming.NamingContextExt.
Bereits vorhandene Programme, die den Verweis auf den Kontext org.omg.CosNaming.NamingContext eingrenzen, funktionieren weiterhin und m&uuml;ssen nicht erneut kompiliert werden.</p>
<p>Der ORB unterst&uuml;tzt die &uuml;ber die Interoperable Naming Service-Spezifikation definierten Parameter <strong>-ORBInitRef</strong> und <strong>-ORBDefaultInitRef</strong>, und die Operation
ORB::string_to_object unterst&uuml;tzt jetzt die &uuml;ber die Interoperable Naming Service-Spezifikation definierten Formate f&uuml;r ObjectURL-Zeichenfolgen (corbaloc: und corbaname:).</p>
<p>Die OMG gibt die Methode ORB::register_initial_reference an, um einen Service mit dem
Interoperable Naming Service zu registrieren. Diese Methode ist jedoch in der
Sun Java-Core-API der Version 6 nicht verf&uuml;gbar.
Programme, die in der aktuellen Version einen Service registrieren m&uuml;ssen, m&uuml;ssen diese Methode in der internen IBM ORB-Implementierungsklasse aufrufen. Dies gilt beispielsweise beim Registrieren des Services &quot;MeinService&quot;:</p>
<p> </p>
<pre class="xmp">((com.ibm.CORBA.iiop.ORB)orb).register_initial_reference("MeinService",
serviceRef);</pre>
<p>Dabei ist <tt>orb</tt> eine Instanz von org.omg.CORBA.ORB, die von ORB.init() zur&uuml;ckgegeben wird, und <tt>serviceRef</tt> ein CORBA-Objekt, das mit dem ORB verbunden ist. Dies ist ein vorl&auml;ufiger Mechanismus, der mit zuk&uuml;nftigen Versionen nicht kompatibel ist und nicht auf ORBs anderer Hersteller portiert werden kann.</p></p>
<a name="corba_properties"></a>
<h3 id="corba_properties"><a href="#ToC_75">Systemmerkmale f&uuml;r die ORB-Tracefunktion</a></h3>
<div>
<p>Durch eine Laufzeitfunktion zur Fehlerbehebung wird die Servicefreundlichkeit verbessert. Diese Funktion kann f&uuml;r die Problemdiagnose verwendet werden, oder sie wird vom IBM Kundendienst ben&ouml;tigt.</p></div>
<p>
<a name="wq94"></a>
<h4 id="wq94">Merkmale der Tracefunktion</h4></p>
<dl class="parml">
<dt class="bold"><strong>com.ibm.CORBA.Debug</strong>=<em>wahr</em></dt>
<dd>Aktiviert die ORB-Tracefunktion.
</dd>
<dt class="bold"><strong>com.ibm.CORBA.CommTrace</strong>=<em>wahr</em></dt>
<dd>F&uuml;gt dem Trace GIOP-Nachrichten hinzu (gesendete und empfangene).
</dd>
<dt class="bold"><strong>com.ibm.CORBA.Debug.Output</strong>=<em>&lt;Datei&gt;</em></dt>
<dd>Geben Sie die Datei f&uuml;r die Traceausgabe an. Diese muss standardm&auml;&szlig;ig im folgenden Format eingegeben werden: orbtrc.TTMMJJJJ.HHmm.SS.txt.
</dd>
</dl>
<p>
<a name="wq95"></a>
<h4 id="wq95">Beispiel f&uuml;r die ORB-Tracefunktion</h4>
<p> Geben Sie z.&nbsp;B. Folgendes ein, um ein Trace f&uuml;r Ereignisse und formatierte GIOP-Nachrichten &uuml;ber die Befehlszeile durchzuf&uuml;hren:</p></p>
<pre class="xmp"> java -Dcom.ibm.CORBA.Debug=true
     -Dcom.ibm.CORBA.CommTrace=true <em>&lt;MeineAnwendung&gt;</em></pre>
<p>
<a name="wq96"></a>
<h4 id="wq96">Einschr&auml;nkungen</h4>
<p>Aktivieren Sie die Tracefunktion nicht f&uuml;r normale Operationen, da dies zu Leistungseinbu&szlig;en f&uuml;hren kann. Obwohl Sie die Tracefunktion inaktiviert haben, funktioniert FFDC (First Failure Data Capture) weiterhin, so dass schwer wiegende Fehler dokumentiert werden. Wenn eine Debugausgabedatei generiert wird, pr&uuml;fen Sie sie in Bezug auf dieses Problem. Der Server k&ouml;nnte z.&nbsp;B. seinen Betrieb eingestellt haben, ohne dass ORB.shutdown() ausgef&uuml;hrt wurde.</p>
<p>Der Inhalt und das Format der Traceausgabe k&ouml;nnen von Version zu Version variieren.</p></p>
<p></p>
<a name="corba_tuning"></a>
<h3 id="corba_tuning"><a href="#ToC_79">Systemmerkmale zur Optimierung des ORB</a></h3>
<div>
<p>Der ORB kann optimiert werden, so dass er mit Ihrem spezifischen Netzwerk gut zusammenarbeitet. Die erforderlichen Merkmale f&uuml;r die Optimierung sind hier beschrieben.</p></div>
<p></p>
<dl class="parml">
<dt class="bold"><strong>com.ibm.CORBA.FragmentSize</strong>=<em>&lt;Gr&ouml;&szlig;e in Byte&gt;</em></dt>
<dd>Wird zur Kontrolle der GIOP 1.2-Fragmentierung verwendet. Die Standardgr&ouml;&szlig;e ist 1024 Byte.

<p>Setzen Sie die Fragmentgr&ouml;&szlig;e auf 0 Byte, um die Fragmentierung zu inaktivieren:</p>
<pre class="xmp">java -Dcom.ibm.CORBA.FragmentSize=0 <em>&lt;MeineAnwendung&gt;</em></pre>
</dd>
<dt class="bold"><strong>com.ibm.CORBA.RequestTimeout</strong>=<em>&lt;Zeit in Sekunden&gt;</em></dt>
<dd>Legt die maximale Zeit fest, w&auml;hrend der auf eine CORBA-Anforderung gewartet wird. Standardm&auml;&szlig;ig wartet der ORB unbegrenzt. Legen Sie f&uuml;r das Zeitlimit keinen zu niedrigen Wert fest, um zu vermeiden, dass Verbindungen unn&ouml;tigerweise beendet werden.
</dd>
<dt class="bold"><strong>com.ibm.CORBA.LocateRequestTimeout</strong>=<em>&lt;Zeit in Sekunden&gt;</em></dt>
<dd>Legt die maximale Zeit fest, w&auml;hrend der auf eine CORBA-Anforderung 'LocateRequest' gewartet wird. Standardm&auml;&szlig;ig wartet der ORB unbegrenzt.
</dd>
<dt class="bold"><strong>com.ibm.CORBA.ListenerPort</strong>=<em>&lt;Portnummer&gt;</em></dt>
<dd>Legt den Port fest, an der der ORB einkommende Anforderungen liest. Wenn f&uuml;r dieses Merkmal ein Wert festgelegt wurde, ist der ORB empfangsbereit, sobald er initialisiert wurde. Andernfalls ist er nur empfangsbereit, wenn es erforderlich ist.
</dd>
</dl>
<a name="corba_security"></a>
<h3 id="corba_security"><a href="#ToC_80">Java-Sicherheitsberechtigungen f&uuml;r den ORB</a></h3>
<div>
<p>Bei der Ausf&uuml;hrung von Java-SecurityManager kann das Aufrufen
einiger Methoden in den CORBA-API-Klassen Berechtigungspr&uuml;fungen verursachen, die
wiederum zu einer Ausnahmebedingung SecurityException f&uuml;hren.
Falls Ihr Programm eine der aufgef&uuml;hrten Methoden verwendet, m&uuml;ssen Sie sicherstellen,
dass die erforderlichen Berechtigungen vorliegen.</p></div>
<p></p>
<a name="corba_security__corbatable"></a>
<table id="corba_security__corbatable" width="100%" summary="" border="1" frame="border" rules="all">
<caption>Tabelle 8. Methoden, auf die sich das Ausf&uuml;hren von Java-SecurityManager auswirkt</caption>
<thead valign="bottom">
<tr>
<th id="wq100" width="32%" align="left">Klasse/Schnittstelle</th>
<th id="wq101" width="32%" align="left">Methode</th>
<th id="wq102" width="34%" align="left">Erforderliche Berechtigung</th>
</tr>
</thead>
<tbody valign="top">
<tr>
<td headers="wq100">org.omg.CORBA.ORB</td>
<td headers="wq101">init</td>
<td headers="wq102">java.net.SocketPermission resolve</td>
</tr>
<tr>
<td headers="wq100">org.omg.CORBA.ORB</td>
<td headers="wq101">connect</td>
<td headers="wq102">java.net.SocketPermission listen</td>
</tr>
<tr>
<td headers="wq100">org.omg.CORBA.ORB</td>
<td headers="wq101">resolve_initial_references</td>
<td headers="wq102">java.net.SocketPermission connect</td>
</tr>
<tr>
<td headers="wq100">org.omg.CORBA. portable.ObjectImpl</td>
<td headers="wq101">_is_a</td>
<td headers="wq102">java.net.SocketPermission connect</td>
</tr>
<tr>
<td headers="wq100">org.omg.CORBA. portable.ObjectImpl</td>
<td headers="wq101">_non_existent</td>
<td headers="wq102">java.net.SocketPermission connect</td>
</tr>
<tr>
<td headers="wq100">org.omg.CORBA. portable.ObjectImpl</td>
<td headers="wq101">OutputStream _request (String, boolean)</td>
<td headers="wq102">java.net.SocketPermission connect</td>
</tr>
<tr>
<td headers="wq100">org.omg.CORBA. portable.ObjectImpl</td>
<td headers="wq101">_get_interface_def</td>
<td headers="wq102">java.net.SocketPermission connect</td>
</tr>
<tr>
<td headers="wq100">org.omg.CORBA. Request</td>
<td headers="wq101">invoke</td>
<td headers="wq102">java.net.SocketPermission connect</td>
</tr>
<tr>
<td headers="wq100">org.omg.CORBA. Request</td>
<td headers="wq101">send_deferred</td>
<td headers="wq102">java.net.SocketPermission connect</td>
</tr>
<tr>
<td headers="wq100">org.omg.CORBA. Request</td>
<td headers="wq101">send_oneway</td>
<td headers="wq102">java.net.SocketPermission connect</td>
</tr>
<tr>
<td headers="wq100">javax.rmi. PortableRemoteObject</td>
<td headers="wq101">narrow</td>
<td headers="wq102">java.net.SocketPermission connect</td>
</tr>
</tbody>
</table>
<a name="corba_classes"></a>
<h3 id="corba_classes"><a href="#ToC_81">ORB-Implementierungsklassen</a></h3>
<div>
<p>Eine Liste der ORB-Implementierungsklassen.</p></div>
<p>
<p>Die ORB-Implementierungsklassen in diesem Release lauten: 
</p>
<ul>
<li>org.omg.CORBA.ORBClass=com.ibm.CORBA.iiop.ORB</li>
<li>org.omg.CORBA.ORBSingletonClass=com.ibm.rmi.corba.ORBSingleton</li>
<li>javax.rmi.CORBA.UtilClass=com.ibm.CORBA.iiop.UtilDelegateImpl</li>
<li>javax.rmi.CORBA.StubClass=com.ibm.rmi.javax.rmi.CORBA.StubDelegateImpl</li>
<li>javax.rmi.CORBA.PortableRemoteObjectClass=com.ibm.rmi.javax.rmi.PortableRemoteObject</li></ul>
<p>Hierbei handelt es sich um die Standardwerte. Es wird jedoch empfohlen, diese Merkmale
nicht direkt festzulegen bzw. nicht direkt auf die Implementierungsklassen zu verweisen. Aus Gr&uuml;nden der Portierbarkeit sollte ausschlie&szlig;lich auf die
CORBA-API-Klassen und nicht auf die Implementierungsklassen verwiesen werden.
Diese Werte werden in zuk&uuml;nftigen Releases m&ouml;glicherweise ge&auml;ndert.</p></p>
<a name="rmi-iiop"></a>
<h2 id="rmi-iiop"><a href="#ToC_82">RMI-IIOP</a></h2>
<div>
<p>Java Remote Method Invocation (RMI) bietet ein einfaches Verfahren
f&uuml;r die verteilte Java-Programmierung. RMI-IIOP (RMI over IIOP) arbeitet auf der Grundlage des
Standard-IIOP-Protokolls (IIOP - Internet Inter-ORB Protocol) der
CORBA (Common Object Request Broker Architecture) und erm&ouml;glicht so
Erweiterungen der Java-RMI bei Daten&uuml;bertragungen. Dadurch sind direkte
Interaktionen mit beliebigen anderen CORBA-Object-Request-Brokern (ORBs) m&ouml;glich, unabh&auml;ngig davon,
ob diese in Java oder einer anderen Programmiersprache implementiert wurden.</p></div>
<p>Folgende Dokumentation steht zur Verf&uuml;gung:</p>
<ul>
<li>Im Handbuch <a href="http://www.ibm.com/developerworks/java/rmi-iiop" target="_blank">RMI-IIOP Programmer's Guide</a> ist eine Einf&uuml;hrung
zum Schreiben von RMI-IIOP-Programmen enthalten.</li>
<li>Das Dokument <a href="http://www.omg.org/cgi-bin/doc?ptc/00-01-06.pdf" target="_blank">Java Language to IDL Mapping</a> enth&auml;lt detaillierte
technische Spezifikationen zu RMI-IIOP.</li></ul>
<a name="rmi"></a>
<h2 id="rmi"><a href="#ToC_83">Implementieren des Steuerroutinenpools f&uuml;r RMI-Verbindungen</a></h2>
<div>
<p>Thread-Pooling f&uuml;r Steuerroutinen von RMI-Verbindungen wird nicht standardm&auml;&szlig;ig aktiviert.</p></div>
<p>
<p>Wenn Sie das Verbindungspooling aktivieren wollen, das in der RMI-TCPTransport-Ebene implementiert ist, legen Sie die folgende Option fest:  </p>
<pre class="xmp">-Dsun.rmi.transport.tcp.connectionPool=true</pre>
<p>Diese Runtime Environment-Version verf&uuml;gt &uuml;ber keine Einstellung, die Sie verwenden k&ouml;nnen, um die Anzahl Threads im Verbindungspool zu begrenzen.</p></p>
<a name="bigd"></a>
<h2 id="bigd"><a href="#ToC_84">Funktionale Erweiterungen f&uuml;r BigDecimal</a></h2>
<div>
<p>&Uuml;ber Java 5.0 wurde die IBM BigDecimal-Klasse von Sun als
java.math.BigDecimal &uuml;bernommen. Die Klasse com.ibm.math.BigDecimal ist f&uuml;r eine m&ouml;gliche zuk&uuml;nftige Verwendung von IBM reserviert und wird derzeit nicht weiter unterst&uuml;tzt. Migrieren Sie bereits vorhandenen Java-Code f&uuml;r die Verwendung von java.math.BigDecimal.</p></div>
<p>Die neue Klasse java.math.BigDecimal verwendet dieselben Methoden
wie die Vorversion java.math.BigDecimal und wie com.ibm.math.BigDecimal.
Der bereits vorhandene Code, der java.math.BigDecimal verwendet, funktioniert weiterhin ordnungsgem&auml;&szlig;. Die beiden Klassen serialisieren nicht.</p>
<p>Wenn Sie bereits vorhandenen Java-Code migrieren wollen, um die Klasse java.math.BigDecimal zu verwenden, &auml;ndern Sie die Importanweisung am Anfang Ihrer
.java-Datei von
<tt class="xph">import com.ibm.math.*;</tt> in <tt class="xph">import java.math.*;</tt>.</p>
<a name="deploying"></a>
<h1 id="deploying"><a href="#ToC_85">Plug-in, Applet Viewer und
Web Start</a></h1>
<div>
<p>Das Java Plug-in dient zum Ausf&uuml;hren von Java-Anwendungen im Browser. appletviewer dient zum Testen von Anwendungen, die f&uuml;r die Ausf&uuml;hrung in einem Browser entworfen wurden. Java Web
Start dient zum Implementieren von Java-Desktopanwendungen in einem Netzwerk und stellt einen Mechanismus zum Aktualisieren dieser Anwendungen bereit.</p></div>
<a name="using_plugin"></a>
<h2 id="using_plugin"><a href="#ToC_86"><strong><span class="bold-italic">(Nur Linux IA 32 Bit und PPC32) </span></strong>Verwenden des
Java Plug-ins</a></h2>
<div>
<p>Das Java Plug-in ist ein Web-Browser Plug-in. Sie verwenden das Java Plug-in zum Ausf&uuml;hren von Applets im Browser.</p></div>
<p>Sie m&uuml;ssen warten, bis die Applets vollst&auml;ndig geladen wurden, um zu vermeiden, dass sich der Browser aufh&auml;ngt.
Wenn Sie beispielsweise die Kn&ouml;pfe <strong>Zur&uuml;ck</strong> und <strong>Weiter</strong>
verwenden, w&auml;hrend ein Applet geladen wird, k&ouml;nnen die HTML-Seiten
unter Umst&auml;nden nicht geladen werden.</p>
<p>Das Java Plug-in wird von Sun auf folgender Website dokumentiert: <a href="http://java.sun.com/javase/6/docs/technotes/guides/plugin/developer_guide/" target="_blank">http://java.sun.com/javase/6/docs/technotes/guides/plugin/developer_guide/</a>.</p>
<a name="suppbrowse"></a>
<h3 id="suppbrowse"><a href="#ToC_87">Unterst&uuml;tzte Browser</a></h3>
<div>
<p>Das Java Plug-in unterst&uuml;tzt SeaMonkey, Mozilla, und
Mozilla Firefox.</p></div>
<p></p>
<a name="suppbrowse__plugintable"></a>
<table id="suppbrowse__plugintable" width="100%" summary="" border="1" frame="border" rules="all">
<caption>Tabelle 9. Vom Java Plug-in unterst&uuml;tzte Browser unter Linux IA32</caption>
<thead valign="bottom">
<tr>
<th id="wq106" width="50%" align="left" valign="top">Browser</th>
<th id="wq107" width="50%" align="left" valign="top">Unterst&uuml;tzte Versionen</th>
</tr>
</thead>
<tbody valign="top">
<tr>
<td headers="wq106">Mozilla</td>
<td headers="wq107">1.7.12, 1.8</td>
</tr>
<tr>
<td headers="wq106">Firefox</td>
<td headers="wq107">1.5, 2.0</td>
</tr>
</tbody>
</table>
<a name="suppbrowse__plugintable-ppc32"></a>
<table id="suppbrowse__plugintable-ppc32" width="100%" summary="" border="1" frame="border" rules="all">
<caption>Tabelle 10. Vom Java Plug-in unterst&uuml;tzte Browser unter Linux PPC32</caption>
<thead valign="bottom">
<tr>
<th id="wq108" width="50%" align="left" valign="top">Browser</th>
<th id="wq109" width="50%" align="left" valign="top">Unterst&uuml;tzte Versionen</th>
</tr>
</thead>
<tbody valign="top">
<tr>
<td headers="wq108">Mozilla</td>
<td headers="wq109">1.6</td>
</tr>
<tr>
<td headers="wq108"><font color="RED"><span id="changed">|</span>SeaMonkey</font></td>
<td headers="wq109"><font color="RED"><span id="changed">|</span>1.0.8</font></td>
</tr>
</tbody>
</table>
<p>Neuere untergeordnete Releases von Browsern werden ebenfalls unterst&uuml;tzt.</p>
<a name="installing_plugin"></a>
<h3 id="installing_plugin"><a href="#ToC_88">Installieren und Konfigurieren des Java Plug-ins</a></h3>
<div>
<p>Verlinken Sie das Java Plug-in zum Installieren symbolisch mit dem Plug-in-Verzeichnis Ihres Browsers.</p></div>
<p>Das Java Plug-in basiert auf der Initiative <a href="http://www.mozilla.org/oji/" target="_blank">Open JVM Integration</a> von Mozilla, die f&uuml;r die meisten Mozilla-Produkte und von Mozilla abgeleiteten Produkte, einschlie&szlig;lich Firefox, verwendet wird.</p>
<p>Im Folgenden finden Sie Anweisungen zum Installieren des Plug-ins auf einigen g&auml;ngigen Browsern.</p>
<p>Sie m&uuml;ssen das Plug-in symbolisch verlinken, statt es zu kopieren, so dass es JVM finden kann.</p>
<a name="mozilla"></a>
<h4 id="mozilla">Mozilla</h4>
<p>
<p>Nur Mozilla ab Version 1.4 wird unterst&uuml;tzt.</p></p>
<ol type="1">
<li>Melden Sie sich als Root an.</li>
<li>Wechseln Sie in das Plug-in-Verzeichnis f&uuml;r Mozilla (dieses Verzeichnis
kann bei einigen Linux-Varianten anders lauten).

<ul>
<li>Gehen Sie wie folgt vor, um das Plug-in allen Benutzern zur Verf&uuml;gung zu stellen:
<pre class="xmp"> cd /usr/local/mozilla/plugins/</pre></li>
<li>Gehen Sie wie folgt vor, um das Plug-in nur dem aktuellen Benutzer zur Verf&uuml;gung zu stellen:
<pre class="xmp">cd $HOME/.mozilla/plugins</pre></li></ul></li>
<li>Erstellen Sie einen symbolischen Link zum Plug-in. 
<pre class="xmp"> ln -s /opt/ibm/java-i386-60/jre/plugin/&lt;Architektur&gt;/ns7/libjavaplugin_oji.so .</pre> Dabei stellt &lt;Architektur&gt; die Architektur Ihres Systems dar.</li></ol>
<p>
<p>W&auml;hlen Sie in Mozilla <strong>Help</strong> -&gt; <strong>About Plug-ins</strong> aus, um zu pr&uuml;fen, ob das Java Plug-in verf&uuml;gbar und aktiviert ist.</p></p>
<p>
<p>Sie m&uuml;ssen das Plug-in symbolisch verlinken, statt es zu kopieren, so dass es JVM finden kann.</p></p>
<a name="wq114"></a>
<div class="note-noindent" id="wq114">
<span class="notetitle">Einschr&auml;nkung:</span> <span class="notebody">Das Verzeichnis /usr/local/mozilla/plugins/ darf nur <em>eine</em> gemeinsam genutzte Java Plug-in-Bibliothek enthalten.
Mozilla versucht, alle Elemente dieses Verzeichnisses (oder des zugeh&ouml;rigen Unterverzeichnisses) als Plug-in zu laden. Wenn jedoch zwei Versionen des Java Plug-ins geladen werden, kann es zu unvorhersehbaren Ergebnissen kommen.</span></div>
<a name="lnx_firefox"></a>
<h4 id="lnx_firefox">Firefox</h4>
<p> Durch diese Schritte wird das Java Plug-in f&uuml;r alle Benutzer verf&uuml;gbar:</p>
<ol type="1">
<li>Melden Sie sich als Root an.</li>
<li>Wechseln Sie in das Plug-in-Verzeichnis f&uuml;r Firefox (dieses Verzeichnis kann bei einigen Linux-Varianten anders lauten). 
<pre class="xmp">cd /usr/local/mozilla-firefox/plugins/</pre></li>
<li>Erstellen Sie einen symbolischen Link zum Plug-in. 
<pre class="xmp"> ln -s /opt/ibm/java-i386-60/jre/plugin/&lt;Architektur&gt;/ns7/libjavaplugin_oji.so .</pre> Dabei stellt &lt;Architektur&gt; die Architektur Ihres Systems dar.</li></ol>
<p>Sie m&uuml;ssen das Plug-in symbolisch verlinken, statt es zu kopieren, so dass es JVM finden kann.</p>
<a name="plugin_dom"></a>
<h3 id="plugin_dom"><a href="#ToC_91">Allgemeine Dokumentobjektmodellunterst&uuml;tzung (Document Object Model, DOM)</a></h3>
<div>
<p>Auf Grund von Einschr&auml;nkungen bei bestimmten Browsern k&ouml;nnen
Sie m&ouml;glicherweise nicht alle Funktionen des Pakets org.w3c.dom.html
implementieren.</p></div>
<p>
<p>Einer der folgenden Fehler wird ausgegeben: 
</p>
<ul>
<li>F&uuml;r einige dieser Funktionen wird eine Ausnahmebedingung sun.plugin.dom.exception.InvalidStateException ausgegeben.</li>
<li>Wenn der Browser eine bestimmte Funktion nicht unterst&uuml;tzt, wird eine Ausnahmebedingung sun.plugin.dom.exception.NotSupportedException ausgegeben.</li></ul></p>
<a name="plugin_dbcs"></a>
<h3 id="plugin_dbcs"><a href="#ToC_92">Verwenden von DBCS-Parametern</a></h3>
<div>
<p>Das Java Plug-in unterst&uuml;tzt Doppelbytezeichen (z.&nbsp;B. Traditionelles Chinesisch BIG-5, Koreanisch, Japanisch) als Parameter
f&uuml;r die Tags <tt class="xph">&lt;APPLET&gt;</tt>, <tt class="xph">&lt;OBJECT&gt;</tt>
und <tt class="xph">&lt;EMBED&gt;</tt>. Sie m&uuml;ssen die richtige Zeichencodierung f&uuml;r das
HTML-Dokument ausw&auml;hlen, damit das Java Plug-in den Parameter syntaktisch analysieren kann.</p></div>
<p>
<p>Geben Sie die Zeichencodierung f&uuml;r Ihr HTML-Dokument an, indem Sie den Tag
<tt class="xph">&lt;META&gt;</tt> im Abschnitt
<tt class="xph">&lt;HEAD&gt;</tt> wie folgt verwenden: </p>
<pre class="xmp">&lt;meta http-equiv="Content-Type" content="text/html; charset=big5"&gt;</pre><p class="indatacontent">In diesem Beispiel wird dem Browser mitgeteilt, dass er die
HTML-Datei mit Hilfe der Zeichencodierung f&uuml;r Chinesisch BIG-5
syntaktisch analysieren soll.</p></p>
<a name="applets"></a>
<h2 id="applets"><a href="#ToC_93">Arbeiten mit Applets</a></h2>
<div>
<p>Mit Applet Viewer k&ouml;nnen Sie mit Hilfe des Applet-Tags mindestens ein Applet ausf&uuml;hren, das durch Verweise auf einer Webseite (HTML-Datei) aufgerufen wird. Applet Viewer findet die APPLET-Tags in der HTML-Datei und f&uuml;hrt die Applets, wie durch die Tags angegeben, in separaten Fenstern aus.</p></div>
<p>Da Applet Viewer f&uuml;r das Anzeigen von Applets konzipiert wurde, kann eine Webseite, die viele HTML-Tags enth&auml;lt, mit Applet Viewer nicht vollst&auml;ndig angezeigt werden. Mit Applet Viewer kann lediglich eine syntaktische Analyse der APPLET-Tags und nicht der anderen auf der Webseite enthaltenen HTML-Tags durchgef&uuml;hrt werden.</p>
<a name="applet_viewer"></a>
<h3 id="applet_viewer"><a href="#ToC_94">Ausf&uuml;hren von Applets mit Applet Viewer</a></h3>
<div>
<p>Mit dem folgenden Befehl f&uuml;hren Sie ein Applet mit Applet Viewer aus.</p></div>
<p>
<p>Geben Sie Folgendes an einer Shelleingabeaufforderung ein:</p></p>
<pre class="xmp">   appletviewer <em>&lt;Name&gt;</em></pre>
<p>Dabei steht <em>&lt;Name&gt;</em> f&uuml;r Folgendes:</p>
<ul>
<li>Dateiname einer HTML-Datei, die ein Applet aufruft oder</li>
<li>URL einer Webseite, die ein Applet aufruft.</li></ul>
<p>Geben Sie z.&nbsp;B.
zum Aufrufen von Applet Viewer &uuml;ber eine HTML-Datei, die ein Applet aufruft, an einer Shelleingabeaufforderung Folgendes ein:</p>
<pre class="xmp">  appletviewer $HOME/<em>&lt;Dateiname&gt;</em>.html</pre>
<p>Dabei gilt Folgendes: <em>&lt;Dateiname&gt;</em> ist der Name der HTML-Datei.</p>
<p>Geben Sie zum Aufrufen von Applet Viewer auf einer Webseite an einer Shelleingabeaufforderung Folgendes ein:</p>
<pre class="xmp">appletviewer http://java.sun.com/applets/NervousText/Beispiel1.html</pre>
<p>Applet Viewer erkennt die Option <strong>charset</strong> des Tags
&lt;META&gt; nicht. Wenn die Datei, die der Applet Viewer l&auml;dt, nicht als Systemstandard codiert ist, wird m&ouml;glicherweise eine E/A-Ausnahmebedingung angezeigt. Verwenden Sie beim Ausf&uuml;hren des Befehls appletviewer die Option <strong>-encoding</strong>, um die Ausnahmebedingung zu vermeiden. Beispiel:  </p>
<pre class="xmp">appletviewer -encoding JISAutoDetect Beispiel.html</pre>
<a name="applet_debugging"></a>
<h3 id="applet_debugging"><a href="#ToC_95">Debugging von Applets mit Applet Viewer</a></h3>
<div>
<p>Mit Hilfe der Option <strong>-debug</strong> von Applet Viewer k&ouml;nnen Sie Fehler in Applets beheben.</p></div>
<p>
<p>Beispiel:</p></p>
<pre class="xmp">cd demo/applets/TicTacToe
../../../bin/appletviewer -debug example1.html</pre>
<p>Dokumentation zum Debugging von Applets mit Applet Viewer finden Sie auf der Website von Sun unter: <a href="http://java.sun.com/javase/6/docs/technotes/guides/plugin/developer_guide/debugger.html" target="_blank">http://java.sun.com/javase/6/docs/technotes/guides/plugin/developer_guide/debugger.html</a>.</p>
<a name="using_webstart"></a>
<h2 id="using_webstart"><a href="#ToC_96"><strong><span class="bold-italic">(Nur Linux IA 32 Bit, PPC32 und PPC64)</span></strong> Verwenden von Web Start</a></h2>
<div>
<p>Java Web Start wird f&uuml;r die Implementierung von Java-Anwendungen verwendet.</p></div>
<p>
<p>Web Start bietet Ihnen die M&ouml;glichkeit, Anwendungen direkt &uuml;ber das Internet
aufzurufen und zu verwalten. Die Anwendungen sind in einem Cache gespeichert, um die Installationszeit zu verringern. F&uuml;r die Anwendungen werden automatisch Upgrades durchgef&uuml;hrt, sobald neue Versionen verf&uuml;gbar sind.</p></p>
<p>
<p>Web Start unterst&uuml;tzt die folgenden JVM-Attribute (java-vm-args), die unter <a href="http://java.sun.com/javase/6/docs/technotes/guides/javaws/developersguide/syntax.html#resources" target="_blank">http://java.sun.com/javase/6/docs/technotes/guides/javaws/developersguide/syntax.html#resources</a> dokumentiert sind: 
</p>
<ul>
<li>-verbose</li>
<li>-version</li>
<li>-showversion</li>
<li>-help</li>
<li>-X</li>
<li>-ea</li>
<li>-enableassertions</li>
<li>-da</li>
<li>-disableassertions</li>
<li>-esa</li>
<li>-enablesystemassertions</li>
<li>-dsa</li>
<li>-disablesystemassertions</li>
<li>-Xint</li>
<li>-Xnoclassgc</li>
<li>-Xdebug</li>
<li>-Xfuture</li>
<li>-Xrs</li>
<li>-Xms</li>
<li>-Xmx</li>
<li>-Xss</li></ul></p>
<p>
<p>IBM Web
Start unterst&uuml;tzt auch <strong>-Xgcpolicy</strong>, um die Garbage-Collection-Richtlinie festzulegen.</p></p>
<p>
<p>Weitere Informationen zu Browsern, die Web Start unterst&uuml;tzen, finden Sie in<a href="#suppbrowse">Unterst&uuml;tzte Browser</a>.</p></p>
<p>
<p>Weitere Informationen zu Web Start finden Sie unter: 
</p>
<ul>
<li><a href="http://java.sun.com/products/javawebstart" target="_blank">http://java.sun.com/products/javawebstart</a> und</li></ul>
<ul>
<li><a href="http://java.sun.com/javase/6/docs/technotes/guides/javaws/index.html" target="_blank">http://java.sun.com/javase/6/docs/technotes/guides/javaws/index.html</a>.</li></ul><p class="indatacontent"> Weitere Informationen zur Implementierung von Anwendungen finden Sie unter </p>
<ul>
<li><a href="http://java.sun.com/javase/6/docs/technotes/guides/deployment/index.html" target="_blank">http://java.sun.com/javase/6/docs/technotes/guides/deployment/index.html</a>.</li></ul></p>
<a name="installing_webstart"></a>
<h3 id="installing_webstart"><a href="#ToC_97">Ausf&uuml;hren von Java Web Start</a></h3>
<div>
<p>Web Start kann in einer Webseite oder in der Befehlszeile ausgef&uuml;hrt werden. Web Start-Anwendungen werden im
Java-Anwendungscache gespeichert.</p></div>
<p>
<p>Java Web Start Version 6 wird automatisch installiert, wenn Sie
Java mit Hilfe der .rpm oder .tgz-Pakete installieren.
Wenn Sie Java aus dem .tgz-Paket extrahieren, f&uuml;hren Sie das Shell-Script
jre/lib/javaws/updateSettings.sh aus, um die Dateien
.mailcap und .mime.types auf Ihrem System zu aktualisieren.</p></p>
<p>
<p>Sie k&ouml;nnen Web Start auf verschiedene Arten aufrufen.</p></p>
<ul>
<li>W&auml;hlen Sie auf einer Webseite einen Link aus, der auf eine .jnlp-Datei verweist.</li>
<li>Geben Sie an einer Shelleingabeaufforderung Folgendes ein: 
<pre class="xmp">javaws <em>&lt;URL&gt;</em></pre>Dabei gilt Folgendes: <em>&lt;URL&gt;</em> ist die Speicherposition einer .jnlp-Datei.</li>
<li>Wenn Sie in der Vergangenheit Java Web Start zum &Ouml;ffnen der Anwendung verwendet haben, k&ouml;nnen Sie
Java Application Cache Viewer verwenden. Geben Sie an einer Shelleingabeaufforderung Folgendes ein:

<pre class="xmp">/opt/ibm/java-i386-60/jre/bin/javaws<span><font color="RED"><span id="changed">|</span> -viewer</font></span></pre> 

<p>Alle Java Web
Start-Anwendungen werden im Cache der Java-Anwendung zwischengespeichert. Eine Anwendung wird nur heruntergeladen, wenn sich die neueste Version nicht im Cache befindet.</p></li></ul>
<a name="webstart_ssv"></a>
<h3 id="webstart_ssv"><a href="#ToC_98"><strong><span class="bold-italic">(Nur Linux IA 32 Bit) </span></strong>Sichere statische Versionssteuerung f&uuml;r WebStart</a></h3>
<div>
<p>Die statische Versionssteuerung erm&ouml;glicht es Web Start-Anwendungen, eine bestimmte JVM-Version anzufordern, um unter dieser Version ausgef&uuml;hrt zu werden. Da Anwendungen auf Grund dieser Funktionalit&auml;t auch alte Sicherheitsl&uuml;cken auf Systemen ausnutzen k&ouml;nnen, f&uuml;r die ein Upgrade auf eine neue JVM ausgef&uuml;hrt wurde, wird die sichere statische Versionssteuerung (SSV - Secure Static Versioning) nun standardm&auml;&szlig;ig verwendet.</p></div>
<p>Durch SSV erh&auml;lt der Benutzer eine Warnung, bevor er eine nicht signierte Web Start-Anwendung ausf&uuml;hrt, die die Verwendung einer bestimmten JVM erfordert. Signierte Anwendungen und Anwendungen, die die neueste Version von JVM erfordern, werden wie &uuml;blich ausgef&uuml;hrt.</p>
<p>Sie k&ouml;nnen die SSV inaktivieren, indem Sie f&uuml;r das Merkmal <strong>deployment.javaws.ssv.enabled</strong> in der Datei
deployment.properties den Wert 'false' festlegen.</p>
<a name="shipping"></a>
<h2 id="shipping"><a href="#ToC_99">Ausliefern von Java-Anwendungen</a></h2>
<div>
<p>Java-Anwendungen bestehen normalerweise aus Klassen-, Ressourcen- und Datendateien.</p></div>
<p>Bei der Auslieferung einer Java-Anwendung kann im Softwarepaket
beispielsweise Folgendes enthalten sein:</p>
<ul>
<li>Ihre eigenen Klassen-, Ressourcen- und Datendateien</li>
<li>Ein Installationsverfahren oder Installationsprogramm</li></ul>
<p>Zum Ausf&uuml;hren der Anwendung ben&ouml;tigt der Benutzer Runtime Environment for Linux. In SDK for Linux ist Runtime Environment enthalten. Sie k&ouml;nnen jedoch nicht davon
ausgehen, dass SDK for Linux auf den Systemen aller Benutzer installiert ist.</p>
<p>Die Lizenz f&uuml;r SDK for Linux berechtigt <strong>nicht</strong> dazu,
Dateien aus SDK zusammen mit der Anwendung weiter zu verteilen. Sie m&uuml;ssen sicherstellen, dass auf dem Zielsystem eine lizenzierte Version von SDK for Linux installiert ist.</p>
<a name="classdatasharing"></a>
<h1 id="classdatasharing"><a href="#ToC_100">Gemeinsame Nutzung von Klassendaten auf verschiedenen JVMs</a></h1>
<div>
<p>Die gemeinsame Nutzung von Klassendaten erm&ouml;glicht es mehreren JVMs, einen einzigen Speicherbereich im Hauptspeicher gemeinsam zu nutzen. </p></div><a id="idx46" name="idx46"></a>
<p>Java Virtual
Machine (JVM) erm&ouml;glicht Ihnen die gemeinsame Nutzung von Klassendaten auf verschiedenen JVMs, indem die Daten in eine im Speicher abgelegte Cachedatei auf Platte gestellt werden. Durch die gemeinsame Nutzung verringert sich die gesamte virtuelle Speicherbelegung, wenn mehrere JVMs einen Cache gemeinsam nutzen. Au&szlig;erdem verk&uuml;rzt sich durch die gemeinsame Nutzung der Systemstart von JVM, nachdem der Cache erstellt wurde. Der Cache f&uuml;r gemeinsam genutzte Klassen ist unabh&auml;ngig von aktiven JVMs und besteht, bis er gel&ouml;scht wird.</p>
<p>Ein gemeinsam genutzter Cache kann Folgendes enthalten:
</p>
<ul>
<li>Bootprogrammklassen</li>
<li>Anwendungsklassen</li>
<li>Metadaten, die die Klassen beschreiben</li>
<li><font color="RED"><span id="changed">|</span>Kompilierter AOT-Code (Ahead-of-time)</font></li></ul>
<a name="shc_overview"></a>
<h2 id="shc_overview"><a href="#ToC_101">&Uuml;bersicht &uuml;ber die gemeinsame Nutzung von Klassendaten</a></h2>
<div>
<p>Die gemeinsame Nutzung von Klassendaten stellt eine transparente Methode zur Verringerung des Speicherbedarfs und zur Verbesserung der JVM-Startzeit bereit. <span><font color="RED"><span id="changed">|</span>Java 6
<span id="changed">|</span>stellt neue und verbesserte Features bei Cacheverwaltung, -isolation und -leistung bereit.</font></span></p></div>
<p>
<a name="wq129"></a>
<h3 id="wq129">Aktivieren der gemeinsamen Nutzung von Klassendaten</h3>
<p>Sie k&ouml;nnen die gemeinsame Nutzung von Klassendaten mit Hilfe der
Option <strong>-Xshareclasses</strong> beim Starten von JVM aktivieren.
JVM stellt eine Verbindung zu einem vorhandenen Cache her oder erstellt einen neuen Cache, wenn keiner vorhanden ist.</p>
<p>Alle &uuml;ber JVM geladenen Boot- und Anwendungsklassen werden standardm&auml;&szlig;ig gemeinsam genutzt. Benutzerdefinierte Klassenladeprogramme nutzen Klassen automatisch gemeinsam, wenn sie das Klassenladeprogramm der Anwendung erweitern; andernfalls m&uuml;ssen sie die zusammen mit JVM verf&uuml;gbare Java Helper API verwenden, um auf den Cache zugreifen zu k&ouml;nnen. (Siehe hierzu die
Informationen in <a href="#adaptingclassloaders">Anpassen benutzerdefinierter Klassenladeprogramme an gemeinsam genutzte Klassen</a>.)</p>
<p><font color="RED"><span id="changed">|</span>Von JVM kann auch vorkompilierter Code (AOT-Code) f&uuml;r bestimmte Methoden im Cache gespeichert werden, um die Startzeit nachfolgender JVMs zu verbessern. Der vorkompilierte Code wird nicht tats&auml;chlich von den JVMs gemeinsam genutzt, sondern zwischengespeichert, um die Kompilierzeit beim Start von JVM zu verringern. Die Menge des im Cache gespeicherten AOT-Codes wird heuristisch ermittelt. Sie k&ouml;nnen nicht steuern, welche Methoden im Cache gespeichert werden, Sie k&ouml;nnen jedoch die Unter- und Obergrenzen des f&uuml;r AOT-Code verwendeten Cachespeicherplatzes festlegen oder das Caching von AOT-Code g&auml;nzlich inaktivieren.
<span id="changed">|</span>Weitere Informationen hierzu finden Sie unter <a href="#sharedclassesxoptions">Aktivieren und Konfigurieren der gemeinsamen Nutzung von Klassendaten</a>.</font></p></p>
<p>
<a name="wq130"></a>
<h3 id="wq130">Cachezugriff</h3>
<p><span><font color="RED"><span id="changed">|</span>JVM kann auf einen Cache entweder mit Lese- und Schreibzugriff oder nur mit Lesezugriff zugreifen.</font></span> Jede JVM, die mit einem Cache verbunden ist, auf den Lese- und Schreibzugriff besteht, kann den Cache aktualisieren. Es k&ouml;nnen beliebig viele JVMs gleichzeitig aus dem Cache lesen, auch w&auml;hrend eine andere JVM in den Cache schreibt.</p>
<p>Bei der Bearbeitung von Laufzeitbytecodes m&uuml;ssen Sie sorgf&auml;ltig vorgehen. Weitere Informationen hierzu finden Sie in <a href="#runtimebytecode">&Auml;nderungen bei Laufzeitbytecodes</a>.</p></p>
<p>
<a name="wq131"></a>
<h3 id="wq131">Dynamisches Aktualisieren des Caches</h3>
<p>Da der Cache f&uuml;r gemeinsam genutzte Klassen &uuml;ber die
Laufzeit von JVMs hinaus besteht, wird er dynamisch
aktualisiert, um alle &Auml;nderungen wiederzugeben, die
m&ouml;glicherweise an JARs oder Klassen auf dem Dateisystem
vorgenommen wurden. Durch die dynamische Aktualisierung
erscheint der Cache f&uuml;r die Anwendung transparent, die den Cache
nutzt.</p></p>
<p>
<a name="wq132"></a>
<h3 id="wq132">Cache-Sicherheit</h3>
<p>Der Zugriff auf den Cache f&uuml;r gemeinsam genutzte Klassen wird durch Berechtigungen des Betriebssystems und Java-Sicherheitsberechtigungen begrenzt. Der Cache f&uuml;r gemeinsam genutzte Klassen wird standardm&auml;&szlig;ig mit Benutzerzugriff erstellt, au&szlig;er wenn die Befehlszeilenunteroption <strong>groupAccess</strong> verwendet wird. Nur ein Klassenladeprogramm, in dem die gemeinsame Nutzung von Klassendaten registriert ist, kann den Cache f&uuml;r gemeinsam genutzte Klassen aktualisieren.</p>
<p><font color="RED"><span id="changed">|</span>Der Cache wird vor versehentlicher oder absichtlicher Besch&auml;digung durch den Speicherseitenschutz gesch&uuml;tzt. Dies ist kein absoluter Schutz vor einer Besch&auml;digung, weil der Schutz von Seiten durch JVM aufgehoben werden muss, damit in diese geschrieben werden kann. Die einzige M&ouml;glichkeit, sicherzustellen, dass ein Cache nicht ge&auml;ndert werden kann, besteht darin, ihn schreibgesch&uuml;tzt zu &ouml;ffnen.</font></p>
<p>Wenn ein Java-SecurityManager installiert ist, muss Klassenladeprogrammen, mit Ausnahme von Klassenladeprogrammen des Standardbootprogramms, von Anwendungen und Erweiterungen, die Berechtigung zur gemeinsamen Nutzung von Klassen erteilt werden, indem der Datei java.policy SharedClassPermission-Zeilen hinzugef&uuml;gt werden. (Siehe hierzu die
Informationen in <a href="#usingsharedclasspermissions">Verwenden von 'SharedClassPermissions'</a>.)
Die RuntimePermission &quot;createClassLoader&quot; beschr&auml;nkt die Erstellung neuer Klassenladeprogramme und daher auch den Zugriff auf den Cache.</p></p>
<p>
<a name="wq133"></a>
<h3 id="wq133">Lebensdauer des Caches</h3>
<p>Auf einem System k&ouml;nnen mehrere Caches vorhanden sein. Sie
werden nach Namen als Unteroption des Befehls
<strong>-Xshareclasses</strong> angegeben.
JVM kann zur selben Zeit nur mit jeweils einem Cache verbunden werden.</p>
<p>Die Standardcachegr&ouml;&szlig;e kann beim Systemstart &uuml;ber den Befehl <strong>-Xscmx&lt;n&gt;&lt;Gr&ouml;&szlig;e&gt;</strong> &uuml;berschrieben werden. Diese Gr&ouml;&szlig;e ist dann f&uuml;r die gesamte Lebensdauer des Caches festgelegt. Caches bestehen solange, bis sie explizit &uuml;ber eine Unteroption des Befehls
<strong>-Xshareclasses</strong> gel&ouml;scht werden oder die Cachedatei manuell gel&ouml;scht wird.</p></p>
<p>
<a name="wq134"></a>
<h3 id="wq134">Cache-Dienstprogramme</h3>
<p>Alle Cache-Dienstprogramme sind Unteroptionen des
Befehls <strong>-Xshareclasses</strong>. Lesen Sie <a href="#sharedclassesxoptions">Aktivieren und Konfigurieren der gemeinsamen Nutzung von Klassendaten</a> oder verwenden Sie
<strong>-Xshareclasses:help</strong>, um eine Liste der verf&uuml;gbaren Unteroptionen anzuzeigen.</p></p>
<a name="sharedclassesxoptions"></a>
<h2 id="sharedclassesxoptions"><a href="#ToC_108">Aktivieren und Konfigurieren der gemeinsamen Nutzung von Klassendaten</a></h2>
<div>
<p>Die Dienstprogramme zur gemeinsamen Nutzung von Klassendaten und zur Cacheverwaltung werden mit Hilfe von Befehlszeilenoptionen des Startprogramms java gesteuert.</p></div><a id="idx47" name="idx47"></a><a id="idx48" name="idx48"></a>
<p>
<p>In Optionen, die einen Parameter <em>&lt;Gr&ouml;&szlig;e&gt;</em> enthalten, m&uuml;ssen Sie der Zahl ein "k" oder "K" f&uuml;r Kilobyte, ein "m" oder "M" f&uuml;r Megabyte oder ein "g" oder "G" f&uuml;r Gigabyte nachstellen.</p></p>
<dl class="parml">
<dt class="bold"><strong>-Xscmaxaot</strong><em>&lt;Gr&ouml;&szlig;e&gt;</em></dt>
<dd>Legt die maximale Anzahl von Byte im Cache fest, die f&uuml;r AOT-Daten verwendet werden k&ouml;nnen. Verwenden Sie diese Option, um sicherzustellen, dass eine bestimmte Menge an Cachespeicherbereich f&uuml;r Nicht-AOT-Daten zur Verf&uuml;gung steht. Der Maximalwert f&uuml;r AOT-Daten ist standardm&auml;&szlig;ig die Menge des freien Speicherbereichs im Cache. Der Wert f&uuml;r diese Option sollte nicht kleiner als der Wert f&uuml;r <strong>-Xscminaot</strong> und nicht gr&ouml;&szlig;er als der Wert f&uuml;r
<strong>-Xscmx</strong> sein.
</dd>
<dt class="bold"><strong>-Xscminaot</strong><em>&lt;Gr&ouml;&szlig;e&gt;</em></dt>
<dd>Legt die minimale Anzahl von Byte im Cache fest, die f&uuml;r AOT-Daten reserviert werden soll.
F&uuml;r AOT-Daten wird standardm&auml;&szlig;ig kein Speicherbereich reserviert, obwohl AOT-Daten in den Cache geschrieben werden, bis der Cache voll oder der Grenzwert <strong>-Xscmaxaot</strong> erreicht ist. Der Wert f&uuml;r diese Option sollte nicht den Wert f&uuml;r <strong>-Xscmx</strong> oder <strong>-Xscmaxaot</strong> &uuml;berschreiten.
Der Wert f&uuml;r <strong>-Xscminaot</strong> sollte immer deutlich unter der Gesamtcachegr&ouml;&szlig;e liegen, weil AOT-Daten nur f&uuml;r zwischengespeicherte Klassen erstellt werden k&ouml;nnen. Falls der Wert f&uuml;r <strong>-Xscminaot</strong> gleich dem Wert f&uuml;r
<strong>-Xscmx</strong> ist, werden keine Klassen- oder AOT-Daten gespeichert, weil AOT-Daten einer Klasse im Cache zugeordnet sein m&uuml;ssen.
</dd>
<dt class="bold"><strong>-Xscmx</strong><em>&lt;Gr&ouml;&szlig;e&gt;</em></dt>
<dd>Gibt die Cachegr&ouml;&szlig;e an. Diese Option wird nur angewendet, wenn ein Cache erstellt wird und kein Cache mit demselben Namen vorhanden ist. Die Standardcachegr&ouml;&szlig;e h&auml;ngt von der
jeweiligen Plattform ab.
Den verwendeten Gr&ouml;&szlig;enwert k&ouml;nnen Sie durch Hinzuf&uuml;gen von <strong>-verbose:sizes</strong> als Befehlszeilenargument ermitteln. Der Cache ist mindestens 4 KB gro&szlig;. Die maximale Gr&ouml;&szlig;e des Caches h&auml;ngt ebenfalls von der Plattform ab. (Siehe hierzu die
Informationen in <a href="#cachesizelimits">Grenzwerte f&uuml;r die Cachegr&ouml;&szlig;e</a>.)
</dd>
<dt class="bold"><strong>-Xshareclasses</strong>:<em>&lt;Unteroption&gt;</em>[,<em>&lt;Unteroption&gt;</em>...]</dt>
<dd>Aktiviert die gemeinsame Nutzung von Klassendaten. Hierf&uuml;r liegt
eine Reihe von Unteroptionen vor, bei denen es sich bei einigen um
Cache-Dienstprogramme handelt. Cache-Dienstprogramme f&uuml;hren den erforderlichen Vorgang f&uuml;r den angegebenen Cache durch, ohne VM zu starten. Sie k&ouml;nnen mehrere Unteroptionen miteinander
kombinieren, wobei diese durch Kommas voneinander getrennt sein
m&uuml;ssen. Die Cache-Dienstprogramme schlie&szlig;en sich allerdings
gegenseitig aus. Wenn Cache-Dienstprogramme ausgef&uuml;hrt werden, wird die Nachricht erwartet, dass die virtuelle Maschine nicht erstellt werden konnte (&quot;Could not create the Java virtual
machine&quot;). Cache-Dienstprogramme erstellen nicht die virtuelle Maschine.

<p>Manche Cache-Dienstprogramme arbeiten mit Caches von vorherigen Java-Versionen bzw. Caches zusammen, die von JVMs mit unterschiedlichen Bitbreiten erstellt wurden. Diese Caches werden als &quot;inkompatible&quot; Caches bezeichnet.</p>

<p>Zusammen mit der Option <strong>-Xshareclasses</strong> k&ouml;nnen Sie folgende Unteroptionen verwenden: 
</p>
<dl class="parml">
<dt class="bold"><strong>help</strong></dt>
<dd>Listet alle Befehlszeilenunteroptionen auf.
</dd>
<dt class="bold"><strong>name</strong>=<em>&lt;Name&gt;</em></dt>
<dd>Stellt die Verbindung zu einem Cache mit einem bestimmten Namen her und erstellt den Cache, falls er nicht bereits
vorhanden ist. Wird auch verwendet, um den Cache anzugeben, der durch Cache-Dienstprogramme wie z.&nbsp;B. "destroy" ge&auml;ndert werden soll. Mit dem Dienstprogramm <strong>listAllCaches</strong> kann angezeigt werden, welche benannten Caches derzeit verf&uuml;gbar sind. Wenn Sie keinen Namen angeben, wird als Cachename der Standardname
&quot;sharedcc_%u&quot; verwendet. Durch '%u' im Cachenamen wird der Name des aktuellen Benutzers eingef&uuml;gt.
 Sie k&ouml;nnen '%g' im Cachenamen angeben, um den Namen der aktuellen Gruppe einzuf&uuml;gen.
</dd>
<dt class="bold"><font color="RED"><span id="changed">|</span><strong>cacheDir=</strong><em>&lt;Verzeichnis&gt;</em></font></dt>
<dd><font color="RED"><span id="changed">|</span>Legt das Verzeichnis fest, in dem Cachedaten gelesen und geschrieben werden. Standardm&auml;&szlig;ig ist <em>&lt;Verzeichnis&gt;</em> das Verzeichnis /tmp/javasharedresources. Der Benutzer ben&ouml;tigt ausreichende Berechtigungen im <em>&lt;Verzeichnis&gt;</em>. Standardm&auml;&szlig;ig schreibt JVM persistente Cachedateien direkt in das angegebene Verzeichnis. Persistente Cachedateien k&ouml;nnen im Dateisystem sicher verschoben und gel&ouml;scht werden. Nicht persistente Caches werden im gemeinsam genutzten Speicher gespeichert, wobei die Position des Speichers in Steuerdateien beschrieben wird. Steuerdateien werden im Unterverzeichnis javasharedresources des mit <strong>cacheDir</strong> angegebenen Verzeichnisses gespeichert.
<span id="changed">|</span>Die Steuerdateien in diesem Verzeichnis d&uuml;rfen nicht manuell verschoben oder gel&ouml;scht werden. Das Dienstprogramm <strong>listAllCaches</strong>, das Dienstprogramm <strong>destroyAll</strong> und die Unteroption <strong>expire</strong> funktionieren nur im G&uuml;ltigkeitsbereich eines mit <strong>cacheDir</strong> angegebenen Verzeichnisses.</font>
</dd>
<dt class="bold"><font color="RED"><span id="changed">|</span><strong>readonly</strong></font></dt>
<dd><font color="RED"><span id="changed">|</span>&Ouml;ffnet einen vorhandenen Cache nur mit Leseberechtigung. Mit dieser Unteroption erstellt JVM keinen neuen Cache. Wird ein Cache nur mit Leseberechtigung ge&ouml;ffnet, wird verhindert, dass von JVM Aktualisierungen des Caches vorgenommen werden. Au&szlig;erdem kann von JVM eine Verbindung zu Caches hergestellt werden, die von anderen Benutzern oder Gruppen erstellt wurden, ohne dass dazu Schreibzugriff erforderlich ist. Diese Unteroption ist standardm&auml;&szlig;ig nicht angegeben.</font>
</dd>
<dt class="bold"><font color="RED"><span id="changed">|</span><strong>nonpersistent</strong></font></dt>
<dd><font color="RED"><span id="changed">|</span>Verwendet einen nicht persistenten Cache. Standardm&auml;&szlig;ig erstellt JVM eine Cachedatei auf Platte, die beim Neustart des Betriebssystems bestehen bleibt. Mit der Unteroption <strong>nonpersistent</strong> wird der Cache im gemeinsam genutzten Speicher erstellt, er bleibt aber nicht bestehen, wenn das Betriebssystem beendet wird. Nicht persistente und persistente Caches k&ouml;nnen den gleichen Namen haben. Die Unteroption <strong>nonpersistent</strong> muss immer verwendet werden, wenn Sie Dienstprogramme wie <strong>destroy</strong> f&uuml;r einen nicht persistenten Cache ausf&uuml;hren. Diese Unteroption ist standardm&auml;&szlig;ig nicht angegeben.</font>
</dd>
<dt class="bold"><strong>groupAccess</strong></dt>
<dd>Legt die Betriebssystemberechtigungen f&uuml;r einen neuen Cache so fest, dass der Gruppenzugriff auf den Cache erlaubt wird. Standardm&auml;&szlig;ig ist nur Benutzerzugriff zul&auml;ssig.
</dd>
<dt class="bold"><strong>verbose</strong></dt>
<dd>Aktiviert die ausf&uuml;hrliche Ausgabe, mit der der Gesamtstatus des Caches f&uuml;r gemeinsam genutzte Klassen und ausf&uuml;hrlichere Fehlernachrichten bereitgestellt werden.
</dd>
<dt class="bold"><font color="RED"><span id="changed">|</span><strong>verboseAOT</strong></font></dt>
<dd><font color="RED"><span id="changed">|</span>Aktiviert die ausf&uuml;hrliche Ausgabe, wenn kompilierter AOT-Code im Cache gefunden oder gespeichert wird. AOT-Code wird heuristisch generiert. Bei einer weniger umfangreichen Anwendung sehen Sie m&ouml;glicherweise gar keinen generierten AOT-Code. Das AOT-Caching kann mit der Unteroption <strong>noaot</strong> inaktiviert werden.</font>
</dd>
<dt class="bold"><strong>verboseIO</strong></dt>
<dd>Mit dieser Option kann eine ausf&uuml;hrliche Ausgabe zu E/A-Aktivit&auml;ten im Cache angezeigt werden. Dabei werden Informationen zu Klassen aufgelistet,
die gespeichert und gefunden wurden. F&uuml;r jedes
Klassenladeprogramm wird eine eindeutige ID vergeben (das
Bootladeprogramm hat immer die ID 0), und in der Ausgabe ist
die Funktionsweise der Hierarchie von Klassenladeprogrammen dargestellt.
Die Klassenladeprogramme m&uuml;ssen bei den zugeh&ouml;rigen
&uuml;bergeordneten Programmen eine Klasse anfordern, bevor sie diese selbst
laden k&ouml;nnen. Es ist normal, dass zahlreiche fehlgeschlagene Anforderungen angezeigt werden. Dieses Verhalten wird in der Hierarchie von Klassenladeprogrammen erwartet.
</dd>
<dt class="bold"><strong>verboseHelper</strong></dt>
<dd>Aktiviert die ausf&uuml;hrliche Ausgabe f&uuml;r die Java Helper-API. Diese Ausgabe zeigt Ihnen, wie die Helper-API von Ihrem Klassenladeprogramm verwendet wird.
</dd>
<dt class="bold"><strong>silent</strong></dt>
<dd>Inaktiviert alle Nachrichten der gemeinsam genutzten Klassen, einschlie&szlig;lich der Fehlernachrichten.
</dd>
<dt class="bold"><strong>nonfatal</strong></dt>
<dd>Erm&ouml;glicht das Starten von JVM, auch wenn die gemeinsame Nutzung von Klassendaten fehlschl&auml;gt.
Das normale Verhalten von JVM w&auml;re, bei Fehlschlagen der gemeinsamen Nutzung von Klassendaten nicht zu starten.
Wenn diese Option ausgew&auml;hlt ist, und die Initialisierung des Caches f&uuml;r gemeinsam genutzte Klassen fehlschl&auml;gt, versucht JVM, die Verbindung zum Cache im Nur-Lesen-Modus herzustellen. Schl&auml;gt dies fehl, startet JVM ohne gemeinsame Nutzung der Klassendaten.
</dd>
<dt class="bold"><strong>none</strong></dt>
<dd>Kann dem Ende einer Befehlszeile hinzugef&uuml;gt werden, um die gemeinsame Nutzung von Klassendaten zu inaktivieren.
Diese Unteroption &uuml;berschreibt Argumente der gemeinsamen Nutzung von Klassen, die in einem fr&uuml;heren Stadium in der Befehlszeile enthalten waren.
</dd>
<dt class="bold"><strong>modified=</strong><em>&lt;Ge&auml;nderter Kontext&gt;</em></dt>
<dd>Wird verwendet, wenn ein JVMTI-Agent installiert wurde, der m&ouml;glicherweise den Bytecode w&auml;hrend der Laufzeit
&auml;ndert.
Wenn Sie diese Unteroption nicht angeben und ein Agent f&uuml;r &Auml;nderungen des Bytecodes installiert ist, werden Klassen sicher gemeinsam genutzt, doch dabei entsteht zus&auml;tzlicher Leistungsaufwand. Bei der Angabe <em>&lt;Ge&auml;nderter Kontext&gt;</em> handelt es sich um einen vom Benutzer ausgew&auml;hlten Deskriptor, wie z.&nbsp;B. &quot;Meine&Auml;nderungen1&quot;.
Diese Option partitioniert den Cache, so dass nur JVMs, die den Kontext "Meine&Auml;nderungen1" verwenden, dieselben Klassen gemeinsam nutzen k&ouml;nnen. Wenn Sie z.&nbsp;B. HelloWorld zusammen mit einem &Auml;nderungskontext ausf&uuml;hren und anschlie&szlig;end mit einem
anderen &Auml;nderungskontext erneut ausf&uuml;hren, werden alle
Klassen zweimal im Cache gespeichert. Weitere Informationen hierzu finden Sie in <a href="#runtimebytecode">&Auml;nderungen bei Laufzeitbytecodes</a>.
</dd>
<dt class="bold"><font color="RED"><span id="changed">|</span><strong>reset</strong></font></dt>
<dd><font color="RED"><span id="changed">|</span>Bewirkt, dass ein Cache gel&ouml;scht und beim Initialisieren von JVM erneut erstellt wird. Kann als <strong>-Xshareclasses:reset</strong> dem Ende einer Befehlszeile hinzugef&uuml;gt werden.</font>
</dd>
<dt class="bold"><strong>destroy</strong> (Dienstprogrammoption)</dt>
<dd>L&ouml;scht einen durch die Unteroptionen <strong>name</strong>, <strong>cacheDir</strong> und <strong>nonpersistent</strong> angegebenen Cache. Ein Cache kann nur gel&ouml;scht werden, wenn alle JVMs, die
diesen Cache verwenden, heruntergefahren wurden und der Benutzer &uuml;ber
die erforderlichen Berechtigungen verf&uuml;gt.
</dd>
<dt class="bold"><strong>destroyAll</strong> (Dienstprogrammoption)</dt>
<dd>Versucht, mit Hilfe der angegebenen Unteroptionen <strong>cacheDir</strong> und <strong>nonpersistent</strong> alle verf&uuml;gbaren Caches zu l&ouml;schen.
Ein Cache kann nur gel&ouml;scht werden, wenn alle JVMs, die
diesen Cache verwenden, heruntergefahren wurden und der Benutzer &uuml;ber
die erforderlichen Berechtigungen verf&uuml;gt.
</dd>
<dt class="bold"><strong>expire</strong>=<em>&lt;Zeit in Minuten&gt;</em></dt>
<dd>L&ouml;scht vor dem Laden der gemeinsam genutzten Klassen alle Caches, die w&auml;hrend der angegebenen Zeit nicht verwendet wurden. Dies ist keine Dienstprogrammoption, weil JVM dadurch nicht beendet wird.
</dd>
<dt class="bold"><strong>listAllCaches</strong> (Dienstprogrammoption)</dt>
<dd>Listet alle kompatiblen und inkompatiblen Caches auf, die im angegebenen Cacheverzeichnis vorhanden sind. Wenn <strong>cacheDir</strong> nicht angegeben ist, wird das Standardverzeichnis verwendet. Es werden &Uuml;bersichtsdaten wie Java-Version und aktuelle Nutzung f&uuml;r jeden Cache angezeigt.
</dd>
<dt class="bold"><strong>printStats</strong> (Dienstprogrammoption)</dt>
<dd>Zeigt &Uuml;bersichtsdaten f&uuml;r den mit den Unteroptionen <strong>name</strong>, <strong>cacheDir</strong> und <strong>nonpersistent</strong> angegebenen Cache an.
Zu den n&uuml;tzlichsten
Informationen geh&ouml;ren die Angaben zur Speicherbelegung im Cache und die Anzahl der darin enthaltenen Klassen. Bei "veralteten" Klassen handelt es sich um Klassen, die auf dem
Dateisystem aktualisiert wurden und die der Cache daher mit "veraltet" gekennzeichnet hat. Veraltete Klassen werden nicht aus dem Cache gel&ouml;scht und k&ouml;nnen wiederverwendet werden. Weitere Informationen finden Sie im Handbuch <a href="http://www.ibm.com/developerworks/java/jdk/diagnosis/60.html" target="_blank">Diagnostics
Guide</a>.
</dd>
<dt class="bold"><strong>printAllStats</strong> (Dienstprogrammoption)</dt>
<dd>
<p>Zeigt ausf&uuml;hrliche Informationen f&uuml;r den mit den Unteroptionen <strong>name</strong>, <strong>cacheDir</strong> und <strong>nonpersistent</strong> angegebenen Cache an. Alle Klassen werden in chronologischer
Reihenfolge zusammen mit einem Verweis auf die Speicherposition
aufgelistet, von der aus sie geladen wurden. Der AOT-Code f&uuml;r Klassenmethoden wird ebenfalls aufgelistet.</p> Weitere Informationen finden Sie im Handbuch 

<p><a href="http://www.ibm.com/developerworks/java/jdk/diagnosis/60.html" target="_blank">Diagnostics Guide</a>.</p>
</dd>
<dt class="bold"><font color="RED"><span id="changed">|</span><strong>mprotect=</strong>[ all
<span id="changed">|</span>| default | none ]</font></dt>
<dd><font color="RED"><span id="changed">|</span>Standardm&auml;&szlig;ig sind die im Cache enthaltenen Speicherseiten immer gesch&uuml;tzt, au&szlig;er wenn eine bestimmte Seite aktualisiert wird. So kann der Cache vor versehentlicher oder absichtlicher Besch&auml;digung gesch&uuml;tzt werden. Der Cache-Header wird standardm&auml;&szlig;ig nicht gesch&uuml;tzt, da damit ein geringer Leistungsaufwand verbunden ist. Durch Angabe von &quot;all&quot; wird sichergestellt, dass alle Cacheseiten, einschlie&szlig;lich Header, gesch&uuml;tzt werden. Durch Angabe von &quot;none&quot; wird der Seitenschutz inaktiviert.</font>
</dd>
<dt class="bold"><font color="RED"><span id="changed">|</span><strong>noBootclasspath</strong></font></dt>
<dd><font color="RED"><span id="changed">|</span>Verhindert die Speicherung von Klassen, die vom Klassenladeprogramm des Bootprogramms in den Cache f&uuml;r gemeinsam genutzte Klassen geladen wurden. Kann mit der Anwendungsprogrammierschnittstelle SharedClassURLFilter verwendet werden, um pr&auml;zise zu steuern, welche Klassen zwischengespeichert werden. Weitere Informationen zum Filtern von gemeinsam genutzten Klassen finden Sie im Handbuch <a href="http://www.ibm.com/developerworks/java/jdk/diagnosis/60.html" target="_blank">Diagnostics Guide</a>.</font>
</dd>
<dt class="bold"><font color="RED"><span id="changed">|</span><strong>cacheRetransformed</strong></font></dt>
<dd><font color="RED"><span id="changed">|</span>Inaktiviert das Caching von Klassen, die mit Hilfe der JVMTI-Funktion RetransformClasses umgesetzt wurden.</font>
</dd>
<dt class="bold"><font color="RED"><span id="changed">|</span><strong>noaot</strong></font></dt>
<dd><font color="RED"><span id="changed">|</span>Inaktiviert das Caching und Laden von AOT-Code.</font>
</dd>
</dl>
</dd>
</dl>
<a name="shc_admin"></a>
<h2 id="shc_admin"><a href="#ToC_109">Erstellen, Belegen, &Uuml;berwachen und L&ouml;schen eines Caches</a></h2>
<div>
<p>Eine &Uuml;bersicht &uuml;ber den Lebenszyklus eines Caches mit gemeinsam genutzten Klassendaten, einschlie&szlig;lich Beispielen f&uuml;r die Dienstprogramme zur Cacheverwaltung.</p></div><a id="idx49" name="idx49"></a><a id="idx50" name="idx50"></a><a id="idx51" name="idx51"></a><a id="idx52" name="idx52"></a>
<p>Zum Aktivieren der gemeinsamen Nutzung von Klassendaten m&uuml;ssen Sie
die Angabe <strong>-Xshareclasses[:name=&lt;Name&gt;]</strong> in der
Befehlszeile Ihrer Anwendung hinzuf&uuml;gen.</p>
<p>JVM stellt dann entweder eine Verbindung zu einem vorhandenen Cache mit dem angegebenen Namen her oder erstellt einen neuen Cache
mit diesem Namen. Wenn ein neuer Cache erstellt wurde, wird dieser mit allen
Boot- und Anwendungsklassen gef&uuml;llt, die geladen wurden, bis der Cache voll wird. Sollten
zwei oder mehr JVMs gleichzeitig gestartet werden, schreiben diese
gleichzeitig Daten in den Cache.</p>
<p>Wenn Sie &uuml;berpr&uuml;fen m&ouml;chten, ob der Cache erstellt wurde, f&uuml;hren
Sie den Befehl <tt class="xph">java -Xshareclasses:listAllCaches</tt> aus.
Sie m&uuml;ssen den Befehl <tt class="xph">java -Xshareclasses:[name=&lt;Name&gt;],printStats</tt> ausf&uuml;hren, um anzuzeigen, wie viele Klassen und Klassendaten gemeinsam genutzt werden. (Diese Dienstprogramme k&ouml;nnen entweder nach der Beendigung der
Anwendungs-JVM oder in einem anderen Befehlsfenster ausgef&uuml;hrt werden.)</p>
<p>Verwenden Sie die Unteroption <strong>verbose</strong>, um mehr R&uuml;ckmeldungen zur Cachebelegung zu erhalten, w&auml;hrend JVM ausgef&uuml;hrt wird.
Beispielsweise <tt class="xph">java -Xshareclasses:[name=&lt;Name&gt;],verbose</tt>.</p>
<p>Wenn Sie Klassen anzeigen m&ouml;chten, die in den Cache
geladen oder im Cache gespeichert wurden, f&uuml;gen Sie in der
Befehlszeile Ihrer Anwendung <tt class="xph">-Xshareclasses:[name=&lt;Name&gt;],verboseIO</tt> hinzu.</p>
<p>Zum L&ouml;schen des zuvor erstellten Caches f&uuml;hren Sie den Befehl
<tt class="xph">java -Xshareclasses:[name=&lt;Name&gt;],destroy</tt> aus. Caches m&uuml;ssen normalerweise nur dann gel&ouml;scht werden, wenn sie
zahlreiche veraltete Klassen enthalten bzw. wenn der Cache voll
ist und Sie einen gr&ouml;&szlig;eren Cache erstellen m&ouml;chten.</p>
<p>Es wird empfohlen, die Cachegr&ouml;&szlig;e f&uuml;r Ihre spezielle Anwendung zu optimieren, da die Standardeinstellung sehr wahrscheinlich nicht die optimale Gr&ouml;&szlig;e angibt. Am besten ermitteln Sie die optimale Cachegr&ouml;&szlig;e, indem Sie einen gro&szlig;en Cache (mit <strong>-Xscmx</strong>) angeben, die Anwendung ausf&uuml;hren und dann mit <strong>printStats</strong> ermitteln, wie viele Klassendaten gespeichert wurden. Addieren Sie f&uuml;r alle F&auml;lle einen kleinen Betrag zu dem in <strong>printStats</strong> angezeigten Wert hinzu.
Da Klassen jederzeit w&auml;hrend der Lebensdauer von JVM geladen werden k&ouml;nnen, empfiehlt es sich, diese Analyse nach Beendigung der Anwendung durchzuf&uuml;hren.
Da jedoch ein voller Cache keine negativen Auswirkungen auf die Leistung oder Funktionalit&auml;t von JVMs hat, die mit diesem Cache verbunden sind, k&ouml;nnen Sie auch eine kleinere als die erforderliche Cachegr&ouml;&szlig;e ausw&auml;hlen.</p>
<p>Wenn ein Cache voll wird, wird eine entsprechende Nachricht in der Befehlszeile aller JVMs angezeigt, die die Unteroption 'verbose' verwenden. Alle JVMs, die den vollen Cache gemeinsam nutzen, laden dann alle weiteren Klassen in ihren eigenen Prozessspeicher. Die in einem vollen Cache enthaltenen Klassen k&ouml;nnen weiterhin gemeinsam genutzt werden, der volle
Cache ist jedoch schreibgesch&uuml;tzt und kann nicht mit neuen
Klassen aktualisiert werden.</p>
<a name="shc_performance"></a>
<h2 id="shc_performance"><a href="#ToC_110">Leistung und Speicherbelegung</a></h2>
<div>
<p>Die gemeinsame Nutzung von Klassendaten empfiehlt sich
insbesondere auf Systemen, auf denen mit mehreren JVMs
gearbeitet wird, die &auml;hnlichen Code ausf&uuml;hren. Diese Systeme profitieren von der
geringeren virtuellen Speicherbelegung. Au&szlig;erdem ist die gemeinsame Nutzung von Klassen auf Systemen sinnvoll, auf denen JVMs h&auml;ufig
gestartet und heruntergefahren werden. Auf diesen Systemen
verk&uuml;rzt sich dadurch der Zeitraum f&uuml;r den Systemstart.</p></div><a id="idx53" name="idx53"></a><a id="idx54" name="idx54"></a>
<p>Der Aufwand f&uuml;r das Erstellen und Belegen eines neuen Caches
ist minimal. Der JVM-Startvorgang f&uuml;r eine einzige JVM ist abh&auml;ngig von der Anzahl der geladenen Klassen im Vergleich zu einem System, das nicht die gemeinsame Nutzung von Klassendaten verwendet, in der Regel zwischen 0 und 5 % l&auml;nger. Die Zeiteinsparung beim JVM-Startvorgang mit einem gef&uuml;llten Cache ist abh&auml;ngig vom Betriebssystem und der Anzahl der geladenen Klassen im Vergleich zu einem System, das nicht die gemeinsame Nutzung von Klassendaten verwendet, in der Regel 10 % bis 20 % k&uuml;rzer. Bei mehreren gleichzeitig ablaufenden JVMs ergeben sich gr&ouml;&szlig;ere Verk&uuml;rzungen bei der Startzeit.</p>
<p>Doppelte Klassen werden innerhalb des Caches f&uuml;r gemeinsam genutzte Klassen konsolidiert. Die aus MeineKlassen.jar geladene Klasse A z.&nbsp;B. und die aus
MeineAnderenKlassen.jar geladene Klasse B (mit identischem Inhalt) wird im Cache nur einmal gespeichert. Das Dienstprogramm <strong>printAllStats</strong> zeigt f&uuml;r doppelte Klassen mehrere Eintr&auml;ge an, wobei jeder Eintrag auf dieselbe Klasse verweist.</p>
<p>Wenn bei der Ausf&uuml;hrung Ihrer Anwendung die gemeinsame Nutzung von Klassendaten aktiviert ist, k&ouml;nnen Sie mit Hilfe von
Betriebssystemtools die Verringerung der virtuellen Speicherbelegung anzeigen.</p>
<a name="shc_limitations"></a>
<h2 id="shc_limitations"><a href="#ToC_111">Besondere Aspekte und Einschr&auml;nkungen bei der gemeinsamen Nutzung von Klassendaten</a></h2>
<div>
<p>Faktoren, die beim Implementieren der gemeinsamen Nutzung von Klassendaten in einem Produkt und beim Verwenden von Klassendaten in einer Entwicklungsumgebung zu ber&uuml;cksichtigen sind.</p></div><a id="idx55" name="idx55"></a><a id="idx56" name="idx56"></a>
<a name="cachesizelimits"></a>
<h3 id="cachesizelimits"><a href="#ToC_112">Grenzwerte f&uuml;r die Cachegr&ouml;&szlig;e</a></h3>
<div>
<p>Die maximale theoretische Cachegr&ouml;&szlig;e betr&auml;gt 2 GB. Die Cachegr&ouml;&szlig;e, die Sie angeben k&ouml;nnen, wird durch die Gr&ouml;&szlig;e des auf dem System verf&uuml;gbaren physischen Speichers und des Umlagerungspeichers begrenzt.</p></div><a id="idx57" name="idx57"></a>
<p>Der Cache f&uuml;r gemeinsam genutzte Klassen wird mit dem Mechanismus 'System V IPC' f&uuml;r gemeinsam genutzten Speicher zugewiesen.</p>
<p>Da der virtuelle Adressraum eines Prozesses vom Cache f&uuml;r gemeinsam genutzte Klassen und dem Java-Freispeicher gemeinsam genutzt wird, kann sich bei Erh&ouml;hung der maximalen Gr&ouml;&szlig;e des Java-Freispeichers die Gr&ouml;&szlig;e des Caches f&uuml;r gemeinsam genutzte Klassen verringern, den Sie erstellen k&ouml;nnen.</p>
<p>Die Cachegr&ouml;&szlig;e ist durch die Einstellungen f&uuml;r
<strong>SHMMAX</strong> begrenzt, da hiermit der
gemeinsam genutzte Speicher begrenzt wird, der
zugeordnet werden kann. Diese Einstellungen sind in der Datei
/proc/sys/kernel/shmmax enthalten. Der Wert f&uuml;r <strong>SHMMAX</strong>
wird normalerweise auf 30 MB festgelegt.</p>
<a name="runtimebytecode"></a>
<h3 id="runtimebytecode"><a href="#ToC_113">&Auml;nderungen bei Laufzeitbytecodes</a></h3>
<div>
<p>Jede JVM, die einen JVMTI-Agenten (JVM Tool Interface) verwendet, der Bytecode &auml;ndern kann, sollte die Unteroption 'modified=<em>&lt;Ge&auml;nderter Kontext&gt;</em>' verwenden, um die ge&auml;nderten Klassen mit einer anderen JVM gemeinsam zu nutzen.</p></div><a id="idx58" name="idx58"></a>
<p>Bei dem ge&auml;nderten Kontext handelt es sich um einen benutzerdefinierten Deskriptor, der die Art der durchgef&uuml;hrten &Auml;nderung beschreibt. Der ge&auml;nderte Kontext partioniert den Cache, so dass alle im selben Kontext aktiven JVMs eine Partition gemeinsam nutzen.</p>
<p>Diese Partionierung erm&ouml;glicht JVMs, die keinen ge&auml;nderten Bytecode verwenden, die sichere gemeinsame Nutzung eines Caches mit denjenigen, die ge&auml;nderten Bytecode verwenden. Alle JVMs, die einen bestimmten ge&auml;nderten Kontext
verwenden, m&uuml;ssen den Bytecode f&uuml;r jede Klasse in einer berechenbaren,
wiederholt anwendbaren Weise &auml;ndern, so dass die im Cache gespeicherten,
ge&auml;nderten Klassen die erwarteten &Auml;nderungen aufweisen,
wenn sie von einer anderen JVM geladen werden. Jede &Auml;nderung muss berechenbar sein, weil Klassen, die aus dem Cache f&uuml;r gemeinsam genutzte Klassen geladen wurden, nicht &uuml;ber den Agenten erneut ge&auml;ndert werden k&ouml;nnen.</p>
<p>Wenn ein JVMTI-Agent ohne einen &Auml;nderungskontext verwendet wird, werden die Klassen von JVM immer noch sicher gemeinsam genutzt, doch es ergeben sich geringe Auswirkungen auf die Leistung.
Die Verwendung eines &Auml;nderungskontextes mit einem JVMTI-Agenten macht zus&auml;tzliche &Uuml;berpr&uuml;fungen &uuml;berfl&uuml;ssig und hat daher keinen Einfluss auf die Leistung. Ein benutzerdefinierter ClassLoader, der
java.net.URLClassLoader erweitert und w&auml;hrend der Ladezeit Bytecode ver&auml;ndert, ohne die JVMTI zu verwenden, speichert den ge&auml;nderten Bytecode automatisch im Cache, doch der Cache behandelt den Bytecode nicht als ge&auml;nderten Bytecode. Jede andere virtuelle Maschine, die diesen Cache gemeinsam nutzt, l&auml;dt die ge&auml;nderten Klassen. Die Unteroption 'modified=<em>&lt;&Auml;nderungskontext&gt;</em>' kann auf dieselbe Weise wie mit JVMTI-Agenten zur Partitionierung von ge&auml;ndertem Bytecode im Cache verwendet werden. Wenn ein benutzerdefinierter ClassLoader unvorhersehbare &Auml;nderungen an Klassen w&auml;hrend der Ladezeit ausf&uuml;hren muss, darf dieser ClassLoader nicht versuchen, Klassendaten gemeinsam zu nutzen.</p>
<p>Weitere Informationen hierzu finden Sie im Handbuch
<a href="http://www.ibm.com/developerworks/java/jdk/diagnosis/60.html" target="_blank">Diagnostics Guide</a>.</p>
<a name="shc_os_limitations"></a>
<h3 id="shc_os_limitations"><a href="#ToC_114">Betriebssystemeinschr&auml;nkungen</a></h3>
<div>
<p>Die gemeinsame Nutzung von Klassen ist zwischen
32- and 64-Bit-JVMs nicht m&ouml;glich. F&uuml;r die Cachedaten muss tempor&auml;rer Plattenspeicherplatz verf&uuml;gbar sein. Die Cacheberechtigungen werden vom Betriebssystem umgesetzt.</p></div><a id="idx59" name="idx59"></a>
<p>Bei Betriebssystemen, die sowohl
32-Bit-Anwendungen als auch 64-Bit-Anwendungen ausf&uuml;hren k&ouml;nnen, ist
die gemeinsame Nutzung von Klassendaten zwischen JVMs mit 32 Bit und 64 Bit
nicht zul&auml;ssig. Die Unteroption <strong>listAllCaches</strong> listet je
nach Adressmodus der verwendeten JVM 32-Bit- oder 64-Bit-Caches
auf.</p>
<p>Der Cache f&uuml;r gemeinsam genutzte Klassen ben&ouml;tigt
Plattenspeicherplatz zum Speichern von ID-Informationen zu den Caches auf dem System. Diese Informationen sind im Verzeichnis
/tmp/javasharedresources enthalten. Wenn das Verzeichnis mit
den ID-Informationen gel&ouml;scht wird, kann JVM die gemeinsam
genutzten Klassen auf dem System nicht identifizieren und muss den Cache erneut
erstellen. Mit dem Befehl <tt class="xph">ipcs</tt> k&ouml;nnen Sie die von JVM oder einer Anwendung verwendeten Speichersegmente anzeigen.</p>
<p>Benutzer, die JVM ausf&uuml;hren, m&uuml;ssen zur Verwendung
eines Caches f&uuml;r gemeinsam genutzte Klassen in derselben Gruppe sein. Die Berechtigungen f&uuml;r den Zugriff auf einen Cache f&uuml;r gemeinsam genutzte Klassen werden vom Betriebssystem umgesetzt. Falls kein Cachename angegeben wird, wird der
Benutzername an den Standardnamen angeh&auml;ngt, damit mehrere Benutzer
auf demselben System standardm&auml;&szlig;ig eigene Caches erstellen.</p>
<a name="usingsharedclasspermissions"></a>
<h3 id="usingsharedclasspermissions"><a href="#ToC_115">Verwenden von 'SharedClassPermissions'</a></h3>
<div>
<p>Wenn ein SecurityManager mit der gemeinsamen Nutzung von Klassendaten verwendet wird und die ausgef&uuml;hrte Anwendung ihre eigenen Klassenladeprogramme verwendet, m&uuml;ssen diesen Klassenladeprogrammen Berechtigungen zur gemeinsamen Nutzung von Klassen erteilt werden, bevor sie Klassen gemeinsam nutzen k&ouml;nnen.</p></div><a id="idx60" name="idx60"></a>
<p>F&uuml;gen Sie der Datei
java.policy Berechtigungen zur gemeinsamen Nutzung von Klassen unter Verwendung des
ClassLoader-Klassennamens (Platzhalterzeichen sind zul&auml;ssig) und entweder
&quot;read&quot;, &quot;write&quot; oder &quot;read,write&quot; zur Angabe der erteilten Zugriffsberechtigung hinzu. Beispiel: </p>
<pre class="xmp">permission com.ibm.oti.shared.SharedClassPermission "com.abc.customclassloaders.*", "read,write";</pre><p class="indatacontent">Wenn ein ClassLoader nicht die korrekten Berechtigungen hat, kann er keine Klassen gemeinsam nutzen. Sie k&ouml;nnen die Berechtigungen der Klassenladeprogramme f&uuml;r das Standardbootprogramm, f&uuml;r Anwendungen oder Erweiterungen nicht &auml;ndern.</p>
<a name="adaptingclassloaders"></a>
<h2 id="adaptingclassloaders"><a href="#ToC_116">Anpassen benutzerdefinierter Klassenladeprogramme an gemeinsam genutzte Klassen</a></h2>
<div>
<p>Klassenladeprogramme, die eine Erweiterung von java.net.URLClassLoader darstellen, k&ouml;nnen Klassen ohne &Auml;nderung gemeinsam nutzen. Klassenladeprogramme, die keine Erweiterung von java.net.URLClassLoader darstellen, m&uuml;ssen f&uuml;r die gemeinsame Nutzung von Klassendaten angepasst werden.</p></div><a id="idx61" name="idx61"></a>
<p>Allen benutzerdefinierten Klassenladeprogrammen m&uuml;ssen Berechtigungen zur gemeinsamen Nutzung von Klassen erteilt werden, wenn ein SecurityManager verwendet wird. Weitere Informationen hierzu finden Sie in <a href="#usingsharedclasspermissions">Verwenden von 'SharedClassPermissions'</a>. IBM bietet mehrere Java-Schnittstellen f&uuml;r verschiedene Typen von
benutzerdefinierten Klassenladeprogrammen, mit denen die Programme im Cache f&uuml;r gemeinsam genutzte Klassen nach Klassen suchen
und diese speichern k&ouml;nnen. Diese Klassen befinden sich im Paket com.ibm.oti.shared.</p>
<p>Die Javadoc-Komponente f&uuml;r dieses Paket wird mit dem SDK in der Datei docs/content/apidoc.zip mitgeliefert.</p>
<p>Weitere Informationen zur Verwendung
dieser Schnittstellen finden Sie im Handbuch <a href="http://www.ibm.com/developerworks/java/jdk/diagnosis/index.html" target="_blank">Diagnostics
Guide</a>.</p>
<a name="jcommchapter"></a>
<h1 id="jcommchapter"><a href="#ToC_117">Verwenden der Java Communications API (JavaComm)</a></h1>
<div>
<p>Das Paket mit der Java Communications API (JavaComm) ist ein optional erh&auml;ltliches Paket, das zusammen mit Runtime Environment for Linux auf IA32-, PPC32-/PPC64- und AMD64/EM64T-Plattformen eingesetzt werden kann.
JavaComm kann unabh&auml;ngig von SDK oder Runtime Environment installiert werden.</p></div>
<p>Mit Hilfe der JavaComm API sind Java-Anwendungen in der Lage,
&Uuml;bertragungen &uuml;ber den seriellen Anschluss und den Parallelanschluss
f&uuml;r Technologien, wie z.&nbsp;B.
Voicemail, Fax und Smartcards,
unabh&auml;ngig von der jeweiligen Plattform durchzuf&uuml;hren.</p>
<p>Die Java Communications API unterst&uuml;tzt serielle EIA-232-Anschl&uuml;sse
(EIA - Electronic Industries Association) bzw. RS232-Anschl&uuml;sse sowie IEEE
1284-Parallelanschl&uuml;sse (IEEE - Institute of Electrical and Electronics
Engineers). Sie wird auf Systemen mit
IBM Runtime Environment Version 6 unterst&uuml;tzt.</p>
<p>Bei Verwendung der Java Communications API haben Sie folgende
M&ouml;glichkeiten:</p>
<ul>
<li>Auflisten von Anschl&uuml;ssen auf einem System</li>
<li>&Ouml;ffnen und Anfordern des Eigentumsrechts von Anschl&uuml;ssen</li>
<li>Beheben von Konkurrenzsituationen in Bezug auf das
Eigentumsrecht f&uuml;r Anschl&uuml;sse zwischen Anwendungen, die mit der
Java Communications API arbeiten</li>
<li>&Uuml;berwachen asynchroner und synchroner E/A-Anschl&uuml;sse unter Verwendung
von Ereignisbenachrichtigungen</li>
<li>Empfangen von Bean-&auml;hnlichen Ereignissen, die Status&auml;nderungen am
Anschluss angeben</li></ul>
<a name="instcomm"></a>
<h2 id="instcomm"><a href="#ToC_118">Installieren der Java Communications API aus einer komprimierten Datei</a></h2>
<div>
<p>Stellen Sie vor der Installation der Java Communications API sicher, dass SDK oder Runtime Environment installiert ist.</p></div>
<p>
<p>Wenn Sie bei der urspr&uuml;nglichen Installation von
Java das RPM-Paket verwendet haben, m&uuml;ssen Sie die
Java Communications API &uuml;ber die RPM-Datei installieren. Informationen zur Installation der
Java Communications API &uuml;ber ein RPM-Paket finden Sie in <a href="#instcomm_rpm">Installieren der Java Communications API &uuml;ber eine RPM-Datei</a>.</p>
<p>Gehen Sie wie folgt vor, um
Java Communications API aus einer komprimierten Datei zu installieren:</p></p>
<ol type="1">
<li>Stellen Sie die komprimierte Datei der Java Communications API, <a name="instcomm__install-file"></a><span id="instcomm__install-file">ibm-java-javacomm-3.0-0.0-&lt;Plattform&gt;-&lt;Architektur&gt;.tar.gz</span>,
in das Verzeichnis, in dem SDK oder Runtime Environment installiert ist. Falls Sie bei der Installation das
Standardverzeichnis verwendet haben, handelt es sich hierbei um /opt/ibm/java-i386-60/.</li>
<li>Extrahieren Sie diese Datei &uuml;ber eine Shelleingabeaufforderung in dem Verzeichnis, in dem die komprimierte Datei enthalten ist: 
<pre class="xmp">tar -xvzf ibm-java-javacomm-3.0-0.0-&lt;Plattform&gt;-&lt;Architektur&gt;.tar.gz</pre>



<p>Dabei steht <tt class="xph">&lt;Architektur&gt;</tt> f&uuml;r Ihre Architektur:
i386, x86_64, ppc oder ppc64.</p></li>
<li><font color="RED"><span id="changed">|</span>Kopieren Sie die javacomm-Dateien in die korrekten Verzeichnisse in Ihrem SDK.
<span id="changed">|</span>
<span id="changed">|</span><ol type="a">
<span id="changed">|</span><li>Kopieren Sie lib/libLinuxSerialParallel.so in Ihr Verzeichnis jre/bin/.</li>
<span id="changed">|</span><li>Kopieren Sie jar/comm.jar in Ihr Verzeichnis
<span id="changed">|</span>jre/lib/ext/.</li>
<span id="changed">|</span><li>Kopieren Sie lib/javax.comm.properties in Ihr Verzeichnis
<span id="changed">|</span>jre/lib/.</li></ol> Das SDK ist standardm&auml;&szlig;ig im Verzeichnis /opt/ibm/java-i386-60/ installiert.</font></li></ol>
<a name="instcomm_rpm"></a>
<h2 id="instcomm_rpm"><a href="#ToC_119">Installieren der Java Communications API &uuml;ber eine RPM-Datei</a></h2>
<div>
<p>Stellen Sie vor der Installation der Java Communications API sicher, dass eine Kopie von SDK oder Runtime Environment installiert ist.</p></div>
<p>Wenn Sie bei der urspr&uuml;nglichen Installation von
Java das RPM-Paket verwendet haben, m&uuml;ssen Sie die
Java Communications API &uuml;ber die RPM-Datei installieren.</p>
<ol type="1">
<li>Rufen Sie eine Shelleingabeaufforderung auf, und stellen
Sie sicher, dass Sie als Root angemeldet sind.</li>
<li>Installieren Sie die RPM-Datei der Java Communications API
mit dem Befehl <tt class="xph">rpm -ivh</tt>. Beispiel:


<pre class="xmp">rpm -ivh ibm-javacomm-3.0-0.0.&lt;Architektur&gt;.rpm</pre> Die Java Communications API wird in der Verzeichnisstruktur /opt/ibm/java-i386-60/ installiert.</li>
<li><font color="RED"><span id="changed">|</span>Kopieren Sie die javacomm-Dateien in die korrekten Verzeichnisse in Ihrem SDK.
<span id="changed">|</span>
<span id="changed">|</span><ol type="a">
<span id="changed">|</span><li>Kopieren Sie lib/libLinuxSerialParallel.so in Ihr Verzeichnis jre/bin/.</li>
<span id="changed">|</span><li>Kopieren Sie jar/comm.jar in Ihr Verzeichnis
<span id="changed">|</span>jre/lib/ext/.</li>
<span id="changed">|</span><li>Kopieren Sie lib/javax.comm.properties in Ihr Verzeichnis
<span id="changed">|</span>jre/lib/.</li></ol> Das SDK ist standardm&auml;&szlig;ig im Verzeichnis /opt/ibm/java-i386-60/ installiert.</font></li></ol>
<a name="fileloc"></a>
<h2 id="fileloc"><a href="#ToC_120">Speicherposition der Java Communications API-Dateien</a></h2>
<p>
<p>Java Communications API-Dateien sind standardm&auml;&szlig;ig im Verzeichnis
/opt/ibm/java-i386-60/ installiert.
Die Dateien und ihre Struktur sind wie folgt:</p></p>
<ul>
<li>jar/comm.jar</li>
<li>jar/commtest.jar</li>
<li>jar/tools/BlackBox.jar</li>
<li>jar/tools/ParallelBlackBox.jar</li>
<li>lib/javax.comm.properties</li>
<li>lib/libLinuxSerialParallel.so</li></ul>
<a name="javacomm_configure"></a>
<h2 id="javacomm_configure"><a href="#ToC_121">Konfigurieren der Java Communications API</a></h2>
<div>
<p>Sie m&uuml;ssen zur Verwendung der Java Communications API den Zugriffsmodus des seriellen Anschlusses und des Parallelanschlusses &auml;ndern und <strong>PATH</strong> setzen, wenn Sie dies nicht bereits bei der Installation von Java getan haben.</p></div>
<p>
<p>Siehe <a href="#pathcons">Festlegen des Pfads</a>.</p></p>
<a name="javacomm_lnx_serial"></a>
<h3 id="javacomm_lnx_serial"><a href="#ToC_122">&Auml;ndern des Zugriffsmodus f&uuml;r den seriellen Anschluss
und den Parallelanschluss</a></h3>
<div>
<p>Nach der Installation der Java Communications API m&uuml;ssen Sie
den Zugriffsmodus f&uuml;r den seriellen Anschluss und den
Parallelanschluss so &auml;ndern, dass die Benutzer auf diese Einheiten
zugreifen k&ouml;nnen.</p></div>
<p>
<p>Sie m&uuml;ssen den Benutzern Schreib- und Lesezugriff auf die erforderlichen Einheiten einr&auml;umen.
Melden Sie sich dazu als
Root an, und verwenden Sie einen der folgenden Befehle:  </p>
<pre class="xmp">    chmod 660 /dev/ttyS0    (wird auch als serieller Anschluss COM1 bezeichnet)
    chmod 660 /dev/lp0      (wird auch als Parallelanschluss LPT1 bezeichnet)
    chmod 660 /dev/ttyS1    (wird auch als serieller Anschluss COM2 bezeichnet)
    chmod 660 /dev/ttyS2    (wird auch als serieller Anschluss COM3 bezeichnet)
    chmod 660 /dev/ttyS3    (wird auch als serieller Anschluss COM4 bezeichnet)</pre>
<p>F&uuml;gen Sie
bestimmte Benutzer zu der Gruppe hinzu, in der sich die Einheiten befinden. Auf einem SUSE-System
befinden sich die Einheiten z.&nbsp;B. in der Gruppe <tt>uucp</tt>. Auf diese Weise k&ouml;nnen der Gruppe <tt>uucp</tt> Benutzer hinzugef&uuml;gt werden, um Zugriff auf die Einheiten zu erhalten.</p>
<p>&Auml;ndern Sie bei Bedarf den Zugriffsmodus anderer Anschl&uuml;sse.</p></p>
<a name="javacomm_lnx_devices"></a>
<h3 id="javacomm_lnx_devices"><a href="#ToC_123">Angeben von Einheiten in der Datei javax.comm.properties</a></h3>
<div>
<p>&Uuml;ber die Datei javax.comm.properties k&ouml;nnen Sie die Pr&auml;fixe
der Einheiten angeben, die der Java Communications API zur
Verf&uuml;gung stehen. Au&szlig;erdem k&ouml;nnen Sie angeben, ob es sich um
parallele oder serielle Einheiten handelt. Die Anschlussnummern
werden allen Einheiten nacheinander zugeordnet.</p></div>
<p>
<p>Wenn Sie z.&nbsp;B.
<tt class="xph">/dev/ttyS=PORT_SERIAL</tt> angeben und die Einheiten
<tt class="xph">/dev/ttyS0</tt> und <tt class="xph">/dev/ttyS1</tt> vorhanden sind,
werden diese COM1 und COM2 zugeordnet.</p>
<p><span>Zur Verwendung der seriellen USB-Anschl&uuml;sse
m&uuml;ssen Sie das Kommentarzeichen in der Zeile mit der Angabe
<tt class="xph">/dev/ttyUSB=PORT_SERIAL</tt> in der Datei
javax.comm.properties entfernen.</span> Sollten die Einheiten <tt class="xph">/dev/ttyUSB0</tt> und <tt class="xph">/dev/ttyUSB1</tt> vorhanden, COM1 und COM2 aber bereits zugeordnet sein, werden die seriellen USB-Einheiten den n&auml;chsten Anschl&uuml;ssen, COM3 und COM4, zugeordnet.</p></p>
<a name="javacomm_thinkpad"></a>
<h2 id="javacomm_thinkpad"><a href="#ToC_124">Aktivieren von seriellen Anschl&uuml;ssen auf IBM ThinkPads</a></h2>
<div>
<p>Bei den meisten ThinkPads sind die seriellen Anschl&uuml;sse
standardm&auml;&szlig;ig im BIOS inaktiviert. Derzeit besteht keine M&ouml;glichkeit, die Anschl&uuml;sse unter
Linux zu aktivieren (mit dem Paket tpctl k&ouml;nnen die Anschl&uuml;sse
<em>nicht</em> aktiviert werden, wenn sie im BIOS
inaktiviert sind).</p></div>
<p>
<p>Zum Aktivieren der Anschl&uuml;sse im BIOS m&uuml;ssen Sie die
DOS-Version des ThinkPad-Konfigurationsprogramms verwenden. Dieses
Programm steht auf der Download-Site f&uuml;r IBM ThinkPads zur
Verf&uuml;gung. F&uuml;r die Verwendung des ThinkPad-Konfigurationsprogramms ben&ouml;tigen Sie eine startf&auml;hige DOS-Diskette.
Beachten Sie, dass das ThinkPad-Konfigurationsprogramm - je nach
den verwendeten Installationsoptionen - m&ouml;glicherweise als Teil der
ThinkPad-Dienstprogramme unter Windows installiert wurde. In diesem
Fall k&ouml;nnen Sie es &uuml;ber eine Eingabeaufforderung unter Windows
aufrufen.</p>
<p>Das unter Windows verf&uuml;gbare
ThinkPad-Konfigurationsprogramm bietet Optionen zum Aktivieren
oder Inaktivieren der seriellen Anschl&uuml;sse und
Parallelanschl&uuml;sse. Dadurch werden allerdings
<em>nicht</em> die Einstellungen im BIOS ge&auml;ndert. Wenn Sie mit diesem Programm daher unter Windows arbeiten, sind die
Anschl&uuml;sse verf&uuml;gbar. Sobald Ihr System allerdings unter Linux
erneut gestartet wird, werden die Anschl&uuml;sse
<em>nicht</em> aktiviert.</p></p>
<a name="javacomm_printing"></a>
<h2 id="javacomm_printing"><a href="#ToC_125">Einschr&auml;nkung beim Drucken mit der Java Communications API</a></h2>
<div>
<p>Bei Druckvorg&auml;ngen &uuml;ber die Java Communications API m&uuml;ssen Sie auf dem Drucker m&ouml;glicherweise die Tasten f&uuml;r Seitenvorschub oder Weiter oder eine &auml;hnliche Funktion dr&uuml;cken.</p></div>
<a name="javacomm_lnx_remove"></a>
<h2 id="javacomm_lnx_remove"><a href="#ToC_126">Deinstallieren der Java Communications API</a></h2>
<div>
<p>Die Vorgehensweise zur Deinstallation der Java Communications API h&auml;ngt davon ab, ob Sie das installierbare RPM-Paket
(Red Hat Package Manager) oder das komprimierte TAR-Paket (Tape Archive) installiert haben.</p></div>
<p></p>
<a name="javacomm_redhat_remove"></a>
<h3 id="javacomm_redhat_remove"><a href="#ToC_127">Deinstallieren des RPM-Pakets (Red Hat Package Manager)</a></h3>
<div>
<p>Deinstallieren der Java Communications API mit Hilfe des RPM-Pakets.</p></div>
<p></p>
<ol type="1">
<li>Verwenden Sie das Tool 'rpm' zum Deinstallieren des Pakets. Geben Sie den folgenden Befehl an einer Shelleingabeaufforderung ein:



<pre class="xmp">rpm -e ibm-javacomm-3.0-0.0</pre> Sie k&ouml;nnen auch ein
grafisches Tool verwenden, wie beispielsweise kpackage oder yast2.</li>
<li>Sollten in dem Verzeichnis, in dem Sie die Java Communications API installiert haben, keine anderen Tools enthalten sein, die Sie
ben&ouml;tigen, entfernen Sie dieses Verzeichnis aus der Anweisung <strong>PATH</strong>.</li>
<li><font color="RED"><span id="changed">|</span>Falls Sie die javacomm-Bibliotheken in das SDK-Verzeichnis kopiert haben, l&ouml;schen Sie folgende Dateien aus dem SDK-Verzeichnis.
<span id="changed">|</span>
<span id="changed">|</span><ul>
<span id="changed">|</span><li>jre/bin/libLinuxSerialParallel.so</li>
<span id="changed">|</span><li>jre/lib/ext/comm.jar</li>
<span id="changed">|</span><li>jre/lib/javax.comm.properties</li></ul> Das SDK ist standardm&auml;&szlig;ig im Verzeichnis /opt/ibm/java-i386-60/ installiert.</font></li></ol>
<a name="javacomm_tar_remove"></a>
<h3 id="javacomm_tar_remove"><a href="#ToC_128">Deinstallieren des komprimierten TAR-Pakets (Tape Archive)</a></h3>
<div>
<p>Deinstallieren der Java Communications API, falls Sie das komprimierte TAR-Paket installiert haben.</p></div>
<p>
<p> L&ouml;schen Sie die folgenden Dateien aus dem Verzeichnis, in dem sie installiert wurden:</p></p>
<ul><font color="RED"><span id="changed">|</span>
<span id="changed">|</span><li>jre/bin/libLinuxSerialParallel.so</li>
<span id="changed">|</span><li>jre/lib/ext/comm.jar</li>
<span id="changed">|</span><li>jre/lib/javax.comm.properties</li></font></ul>
<a name="javacomm_apidoc"></a>
<h2 id="javacomm_apidoc"><a href="#ToC_129">Dokumentation zur Java Communications API</a></h2>
<div>
<p>Dokumentation zu APIs und Beispiele zur Java Communications API finden Sie auf der Sun-Website.</p></div>
<p>
<p><a href="http://java.sun.com/products/javacomm/" target="_blank">http://java.sun.com/products/javacomm/</a>.</p></p>
<a name="support"></a>
<h1 id="support"><a href="#ToC_130">Service und Unterst&uuml;tzung f&uuml;r unabh&auml;ngige Softwareanbieter</a></h1>
<div>
<p>Kontaktpunkte f&uuml;r Service:</p></div>
<p> Falls Sie berechtigt sind, Serviceleistungen f&uuml;r den Programmcode des Programms IBM Solutions Developer Program in Anspruch zu nehmen, gehen Sie hierbei wie gewohnt vor,
oder rufen Sie das Programm im Internet unter folgender Adresse auf: <a href="http://www.ibm.com/partnerworld/" target="_blank">http://www.ibm.com/partnerworld/</a>.</p>
<p>Wenn Sie einen Servicevertrag (z. B. f&uuml;r IBM Personal Systems Support Line oder f&uuml;r einen vergleichbaren, in Ihrem Land verf&uuml;gbaren Service) unterzeichnet haben, ist in den Vertragsbedingungen dieses Servicevertrags festgelegt, welche Services Sie - falls verf&uuml;gbar - gem&auml;&szlig; dem o.&nbsp;g. Programm in Anspruch nehmen d&uuml;rfen.</p>
<a name="accessibility"></a>
<h1 id="accessibility"><a href="#ToC_131">Eingabehilfen</a></h1>
<div>
<p>Die Benutzerhandb&uuml;cher zu SDK und
Runtime Environment wurden mit Sprachausgabeprogrammen getestet.</p></div>
<p>Verwenden Sie zum &Auml;ndern der Schriftgr&ouml;&szlig;en in den Benutzerhandb&uuml;chern die Funktion, die in Ihrem Browser enthalten ist. Sie finden diese Funktion in der Regel im Men&uuml; <strong>Ansicht</strong>.</p>
<p>Benutzer, die &uuml;ber die Tastatur navigieren m&uuml;ssen, finden unter <cite>Swing Key Bindings</cite> (<a href="http://www.ibm.com/developerworks/java/jdk/additional/" target="_blank">http://www.ibm.com/developerworks/java/jdk/additional/</a>) eine Beschreibung von n&uuml;tzlichen Tastaturangaben f&uuml;r Swing-Anwendungen.</p>
<a name="access_keyboard"></a>
<h2 id="access_keyboard"><a href="#ToC_132">Verschieben des Eingabefokus von JComboBox-Komponenten in Swing per Tastatur</a></h2>
<div>
<p>Beim Bl&auml;ttern in der Dropdown-Liste einer JComboBox-Komponente mit den Cursortasten kann der Wert mit Hilfe des Knopfs oder des editierbaren Felds der JComboBox erst dann ge&auml;ndert werden, wenn ein Element ausgew&auml;hlt wird. Mit diesem f&uuml;r dieses Release korrekten Verhalten verbessern sich Eingabehilfen und Benutzerfreundlichkeit, da sichergestellt wird, dass das Verschieben des Eingabefokus per Tastatur dem Verschieben des Eingabefokus per Maus entspricht.</p></div>
<a name="access_webstart"></a>
<h2 id="access_webstart"><a href="#ToC_133">Web Start-Eingabehilfen (nur Linux IA 32 Bit, PPC32 und PPC64)</a></h2>
<div>
<p>In Java Web Start sind ab Version 5.0 die Eingabehilfen und die Benutzerfreundlichkeit verbessert worden. Dazu geh&ouml;ren z.&nbsp;B.
eine bessere Unterst&uuml;tzung f&uuml;r Sprachausgabeprogramme und eine bessere Navigation &uuml;ber die Tastatur.</p></div>
<p>Sie k&ouml;nnen die Befehlszeile nur zum Starten einer Java-Anwendung verwenden, die f&uuml;r Web Start aktiviert ist. Zum &Auml;ndern von Einstellungsoptionen m&uuml;ssen Sie die Konfigurationsdatei .java/.deployment/.deployment.properties im Ausgangsverzeichnis des Benutzers editieren. Sichern Sie die Datei, bevor Sie sie editieren. Nicht alle Einstellungen, die in Java Application Cache Viewer festgelegt werden k&ouml;nnen, sind in der Konfigurationsdatei verf&uuml;gbar.</p>
<a name="rcf"></a>
<h1 id="rcf"><a href="#ToC_134">Kommentare zu diesem Handbuch</a></h1>
<div>
<p>Wenn Sie Kommentare zu diesem Benutzerhandbuch abgeben m&ouml;chten, kontaktieren Sie uns auf einem der folgenden Mitteilungswege. Beachten Sie, dass diese Mitteilungswege nicht eingerichtet wurden, um technische Fragen zu
beantworten. Sie sind nur f&uuml;r Kommentare zur Dokumentation bestimmt.</p></div>
<p>Senden Sie Ihre Kommentare an folgende Adresse:</p>
<ul>
<li>Per E-Mail: idrcf@hursley.ibm.com</li>
<li>Per Fax:  

<ul>
<li>Von Gro&szlig;britannien: 01962 842327</li>
<li>Von anderen L&auml;ndern: +44 1962 842327</li></ul></li>
<li>Per Post: 
<div class="lines">IBM United Kingdom Ltd<br />
User Technologies,<br />
Mail Point 095<br />
Hursley Park<br />
Winchester<br />
Hampshire<br />
SO21 2JN<br />
United Kingdom <br />
</div></li></ul>
<p><strong>Das Kleingedruckte.</strong> Wenn Sie eine Nachricht an IBM senden, erkl&auml;ren
Sie sich einverstanden, dass alle in Ihrer Nachricht enthaltenen Informationen, einschlie&szlig;lich
der R&uuml;ckmeldedaten, wie beispielsweise Fragen, Kommentare, Anregungen o.&nbsp;&Auml;., nicht vertraulich
behandelt werden und dass IBM keinerlei Verpflichtungen in Bezug auf diese Informationen hat
und diese uneingeschr&auml;nkt abdrucken, verwenden, ver&ouml;ffentlichen und an andere weitergeben kann. Des Weiteren kann IBM in diesen Informationen enthaltene Ideen, Konzepte oder Angaben zu
Know-how oder technischen Verfahren uneingeschr&auml;nkt und f&uuml;r beliebige Zwecke verwenden, u.&nbsp;a.
f&uuml;r die Entwicklung, die Produktion und das Marketing von Produkten, die diese Informationen
enthalten.</p>
<a name="xoptions"></a>
<h1 id="xoptions"><a href="#ToC_135">Anhang A. Vom Standard abweichende Optionen</a></h1>
<div>
<p>Bei den unten aufgelisteten <strong>-X</strong>-Optionen handelt es sich um Optionen, die vom Standard abweichen und jederzeit ohne vorherige Ank&uuml;ndigung ge&auml;ndert werden k&ouml;nnen.</p></div>
<p>
<p>In Optionen, die einen Parameter <em>&lt;Gr&ouml;&szlig;e&gt;</em> enthalten, m&uuml;ssen Sie der Zahl ein "k" oder "K" f&uuml;r Kilobyte, ein "m" oder "M" f&uuml;r Megabyte oder ein "g" oder "G" f&uuml;r Gigabyte nachstellen.</p>
<p>In Optionen, die einen Parameter
<em>&lt;Prozentsatz&gt;</em> verwenden, sollten Sie eine Zahl von 0 bis 1 verwenden. Beispiel: '50 %' ist '0,5'.</p></p>
<dl class="parml">
<dt class="bold"><strong>-Xargencoding</strong></dt>
<dd> Mit dieser Option k&ouml;nnen Sie Unicode-Escapezeichenfolgen in die Argumentenliste aufnehmen. Sie ist standardm&auml;&szlig;ig inaktiviert.
</dd>
<dt class="bold"><strong>-Xbootclasspath</strong>:<em>&lt;Durch : getrennte Verzeichnisse und ZIP- oder JAR-Dateien&gt;</em></dt>
<dd> Definiert den Suchpfad f&uuml;r Bootklassen und -ressourcen. Standardm&auml;&szlig;ig wird in den internen VM-Verzeichnissen und JAR-Dateien nach Bootklassen und -ressourcen gesucht.
</dd>
<dt class="bold"><strong>-Xbootclasspath/a</strong>:<em>&lt;Durch : getrennte Verzeichnisse und ZIP- oder JAR-Dateien&gt;</em></dt>
<dd> F&uuml;gt die angegebenen Verzeichnisse, ZIP- oder JAR-Dateien am Ende des Bootklassenpfads hinzu. Standardm&auml;&szlig;ig wird in den internen VM-Verzeichnissen und JAR-Dateien nach Bootklassen und -ressourcen gesucht.
</dd>
<dt class="bold"><strong>-Xbootclasspath/p</strong>:<em>&lt;Durch : getrennte Verzeichnisse und ZIP- oder JAR-Dateien&gt;</em></dt>
<dd> F&uuml;gt die angegebenen Verzeichnisse, ZIP- oder JAR-Dateien am Anfang des Bootklassenpfads hinzu. Implementieren Sie keine Anwendungen, bei denen mit der Option <strong>-Xbootclasspath:</strong> oder <strong>-Xbootclasspath/p:</strong> eine Klasse in der Standard-API &uuml;berschrieben wird, da eine solche Implementierung gegen die Java Runtime Environment-Bin&auml;rcodelizenz verst&ouml;&szlig;t.
Standardm&auml;&szlig;ig wird in den internen VM-Verzeichnissen und JAR-Dateien nach Bootklassen und -ressourcen gesucht.
</dd>
<dt class="bold"><font color="RED"><span id="changed">|</span><strong>-Xcheck:classpath</strong></font></dt>
<dd><font color="RED"><span id="changed">|</span>Zeigt eine Warnung an, wenn im Klassenpfad ein Fehler aufgesp&uuml;rt wurde, z.&nbsp;B. ein fehlendes Verzeichnis oder eine fehlende JAR-Datei.</font>
</dd>
<dt class="bold"><span class="synph"><span class="kwd">-Xcheck:gc</span><span class="delim">[</span><span class="delim">:</span><span class="var">&lt;Suchoptionen
&gt;</span><span class="delim">]</span><span class="delim">[</span><span class="delim">:</span><span class="var">&lt;Pr&uuml;foptionen
&gt;</span><span class="delim">]</span><span class="delim">[</span><span class="delim">:</span><span class="var">&lt;Sonstige
Optionen&gt;</span><span class="delim">]</span></span></dt>
<dd> F&uuml;hrt zus&auml;tzliche Pr&uuml;fungen f&uuml;r die Garbage-Collection aus. Standardm&auml;&szlig;ig wird keine Pr&uuml;fung ausgef&uuml;hrt. Weitere Informationen finden Sie in der Ausgabe von <strong>-Xcheck:gc:help</strong>.
</dd>
<dt class="bold"><a id="xoptions__xcheckjni" name="xoptions__xcheckjni"></a><strong>-Xcheck:jni</strong></dt>
<dd>F&uuml;hrt zus&auml;tzliche Pr&uuml;fungen f&uuml;r JNI-Funktionen aus. Standardm&auml;&szlig;ig wird keine Pr&uuml;fung ausgef&uuml;hrt.
</dd>
<dt class="bold"><font color="RED"><span id="changed">|</span><span class="synph"><span class="kwd">-Xcheck:memory</span><span class="delim">[</span><span class="delim">:</span><span class="var">&lt;Option&gt;</span><span class="delim">]</span></span></font></dt>
<dd><a id="idx62" name="idx62"></a><a id="idx63" name="idx63"></a>Identifiziert Speicherverluste innerhalb von JVM mit Hilfe von genauen Pr&uuml;fungen, die dazu f&uuml;hren, dass JVM mit einem Fehler beendet wird. Wenn keine Option angegeben wird, wird standardm&auml;&szlig;ig <strong>all</strong> verwendet. Weitere Informationen finden Sie in der Ausgabe von <strong>-Xcheck:memory:help</strong> oder im Handbuch <a href="http://www.ibm.com/developerworks/java/jdk/diagnosis/60.html" target="_blank">Diagnostics Guide</a>.
</dd>
<dt class="bold"><a id="xoptions__xchecknabounds" name="xoptions__xchecknabounds"></a><strong>-Xcheck:nabounds</strong></dt>
<dd> F&uuml;hrt zus&auml;tzliche Pr&uuml;fungen f&uuml;r JNI-Funktionen aus. Standardm&auml;&szlig;ig wird keine Pr&uuml;fung ausgef&uuml;hrt.
</dd>
<dt class="bold"><a id="xoptions__classgc" name="xoptions__classgc"></a><strong>-Xclassgc</strong></dt>
<dd> Aktiviert die Erfassung von Klassenobjekten bei jeder Garbage-Collection. Siehe auch
<a href="#xoptions__noclassgc"><strong>-Xnoclassgc</strong></a>.
Diese Option ist standardm&auml;&szlig;ig aktiviert.
</dd>
<dt class="bold"><strong>-Xcodecache</strong><em>&lt;Gr&ouml;&szlig;e&gt;</em></dt>
<dd> Legt die Gr&ouml;&szlig;e der Einheit fest, bei der Hauptspeicherblocks zugeordnet werden, so dass sie nativen Code von kompilierten
Java-Methoden speichern. F&uuml;r die jeweils ausgef&uuml;hrte Anwendung kann eine entsprechende Gr&ouml;&szlig;e ausgew&auml;hlt werden. Dies ist standardm&auml;&szlig;ig intern ausgew&auml;hlt, je nach der CPU-Architektur und der Funktionalit&auml;t Ihres Systems.
</dd>
<dt class="bold"><a id="xoptions__compactexplicitgc" name="xoptions__compactexplicitgc"></a><strong>-Xcompactexplicitgc</strong></dt>
<dd>Komprimiert bei jedem Aufruf an <tt class="xph">System.gc()</tt>.
Siehe auch <a href="#xoptions__nocompactexplicitgc"><strong>-Xnocompactexplicitgc</strong></a>.
Standardm&auml;&szlig;ig wird die Komprimierung nur ausgef&uuml;hrt, wenn sie intern ausgel&ouml;st wird.
</dd>
<dt class="bold"><a id="xoptions__compactgc" name="xoptions__compactgc"></a><strong>-Xcompactgc</strong></dt>
<dd>F&uuml;hrt eine Komprimierung f&uuml;r jede Garbage-Collection aus. Siehe auch <a href="#xoptions__nocompactgc"><strong>-Xnocompactgc</strong></a>.
Standardm&auml;&szlig;ig wird die Komprimierung nur ausgef&uuml;hrt, wenn sie intern ausgel&ouml;st wird.
</dd>
<dt class="bold"><strong>-Xconcurrentbackground</strong><em>&lt;Anzahl&gt;</em></dt>
<dd>Gibt die Anzahl der Hintergrundthreads mit niedriger Priorit&auml;t an, die w&auml;hrend der Garbage-Collection-Phase der gleichzeitigen Markierung zur Unterst&uuml;tzung der Mutator-Threads zugeordnet sind. Die Standardeinstellung lautet 1.
</dd>
<dt class="bold"><strong>-Xconcurrentlevel</strong><em>&lt;Anzahl&gt;</em></dt>
<dd> Gibt die Zuordnungsauslastungsrate an. Sie gibt das Verh&auml;ltnis zwischen dem zugeordneten und dem markierten Freispeicher an. Die Standardeinstellung lautet 8.
</dd>
<dt class="bold"><span class="synph"><span class="kwd">-Xconmeter</span><span class="sep">:</span><span class="var">&lt;</span><span class="var">soa</span><span class="delim">|</span><span class="var">loa</span><span class="delim">|</span><span class="var">dynamic</span><span class="var">&gt;</span></span></dt>
<dd>Legt fest, f&uuml;r welchen Speicherbereich (Large Object Area (LOA) oder Small Object Area (SOA)) die Belegung gemessen wird, und folglich, welche Zuordnungen w&auml;hrend der gleichzeitigen Markierung belastet werden. Die Zuordnungsauslastung wird auf den ausgew&auml;hlten Bereich angewendet. Wenn <strong>-Xconmeter:dynamic</strong>	angegeben ist, legt der Collector den zu messenden Bereich dynamisch fest, basierend darauf, welcher Bereich zuerst ausgelastet ist. Standardm&auml;&szlig;ig ist die Option auf <strong>-Xconmeter:soa</strong> gesetzt.
</dd>
<dt class="bold"><a id="xoptions__xdbg" name="xoptions__xdbg"></a><strong>-Xdbg</strong>:<em>&lt;Optionen&gt;</em></dt>
<dd>L&auml;dt Debugbibliotheken, damit das ferne Debugging von Anwendungen unterst&uuml;tzt wird.
Weitere Informationen hierzu finden Sie in <a href="#debugger">Debugging in Java-Anwendungen</a>. Die Angabe eines Werts f&uuml;r <a href="#xoptions__runjdwp"><strong>-Xrunjdwp</strong></a> stellt dieselbe Unterst&uuml;tzung bereit.
</dd>
<dt class="bold"><strong>-Xdebug</strong></dt>
<dd>Startet JVM mit aktiviertem Debugger. Der Debugger ist standardm&auml;&szlig;ig inaktiviert.
</dd>
<dt class="bold"><strong>-Xdisableexcessivegc</strong></dt>
<dd>Inaktiviert die Ausl&ouml;sung der Ausnahmebedingung OutOfMemoryError, wenn in der Garbage-Collection zu viel Zeit ben&ouml;tigt wurde. Diese Option ist standardm&auml;&szlig;ig inaktiviert.
</dd>
<dt class="bold"><strong>-Xdisableexplicitgc</strong></dt>
<dd>Signalisiert VM, dass Aufrufe an System.gc() keine Auswirkung haben. Aufrufe an System.gc() l&ouml;sen standardm&auml;&szlig;ig eine Garbage-Collection aus.
</dd>
<dt class="bold"><strong>-Xdisablestringconstantgc</strong></dt>
<dd>Verhindert, dass Zeichenfolgen in der zeichenfolgeninternen Tabelle erfasst werden. Diese Option ist standardm&auml;&szlig;ig inaktiviert.
</dd>
<dt class="bold"><strong>-Xdisablejavadump</strong></dt>
<dd>Inaktiviert die Generierung von Java-Speicherausz&uuml;gen bei Fehlern und Signalen. Die Generierung von Java-Speicherausz&uuml;gen ist standardm&auml;&szlig;ig aktiviert.
</dd>
<dt class="bold"><strong>-Xenableexcessivegc</strong></dt>
<dd>Wenn in der GC zu viel Zeit beansprucht wird, gibt diese Option f&uuml;r eine Zuordnungsanforderung NULL zur&uuml;ck, wodurch die Ausnahmebedingung OutOfMemoryError ausgel&ouml;st wird. Diese Aktion tritt nur auf, wenn der Freispeicher vollst&auml;ndig ausgelastet ist, und die Garbage-Collection 95 % der ben&ouml;tigten Zeit in Anspruch nimmt. Dies ist das Standardverhalten.
</dd>
<dt class="bold"><strong>-Xenableexplicitgc</strong></dt>
<dd>Signalisiert VM, dass Aufrufe an System.gc() eine Garbage-Collection ausl&ouml;sen sollen. Dies ist der Standardwert.
</dd>
<dt class="bold"><strong>-Xenablestringconstantgc</strong></dt>
<dd>Erm&ouml;glicht die Erfassung von Zeichenfolgen aus der internen Zeichenfolgentabelle. Diese Option ist standardm&auml;&szlig;ig aktiviert.
</dd>
<dt class="bold"><strong>-Xfuture</strong></dt>
<dd>Aktiviert genaue Formatpr&uuml;fungen von Klassendateien. Verwenden Sie diese Option f&uuml;r die Entwicklung von neuem Code, da in den zuk&uuml;nftigen Releases standardm&auml;&szlig;ig genauere Pr&uuml;fungen ausgef&uuml;hrt werden.
Genaue Formatpr&uuml;fungen sind standardm&auml;&szlig;ig inaktiviert.
</dd>
<dt class="bold"><span class="synph"><span class="kwd">-Xgcpolicy</span><span class="sep">:</span><span class="var">&lt;</span><span class="var">optthruput</span><span class="delim">|</span><span class="var">optavgpause</span><span class="delim">|</span><span class="var">gencon</span><span class="delim">|</span><span class="var">subpool</span><span class="var">&gt;</span></span> (Speicherteilbereich f&uuml;r PPC und zSeries)</dt>
<dd>Steuert das Verhalten des Garbage-Collectors. Weitere Informationen hierzu finden Sie in <a href="#garbage_options">Optionen der Garbage-Collection</a>.
</dd>
<dt class="bold"><strong>-Xgcthreads</strong><em>&lt;Anzahl Threads&gt;</em></dt>
<dd> Definiert die Anzahl der Helper-Threads, die f&uuml;r Paralleloperationen w&auml;hrend der Garbage-Collection verwendet werden. Standardm&auml;&szlig;ig entspricht die Anzahl Threads der Anzahl vorhandener physischer CPUs minus 1 (mindestens 1).
</dd>
<dt class="bold"><strong>-Xgcworkpackets</strong><em>&lt;Anzahl&gt;</em></dt>
<dd> Gibt die Gesamtzahl der Vorgangspakete an, die im globalen Collector zur Verf&uuml;gung stehen.
Wenn keine Anzahl angegeben ist, ordnet der Collector auf Grundlage der maximalen Gr&ouml;&szlig;e des Freispeichers eine Paketzahl zu.
</dd>
<dt class="bold"><strong>-Xint</strong></dt>
<dd>Mit Hilfe dieser Option verwendet JVM nur den Interpreter. Der JIT-Compiler (Just-In-Time)
wird inaktiviert. Der JIT-Compiler ist standardm&auml;&szlig;ig aktiviert.
</dd>
<dt class="bold"><strong>-Xiss</strong><em>&lt;Gr&ouml;&szlig;e&gt;</em></dt>
<dd>Definiert die urspr&uuml;ngliche Gr&ouml;&szlig;e des Java-Thread-Stacks. Standardm&auml;&szlig;ig sind dies 2 KB.
Verwenden Sie die Option <a href="#standard_options__verbose"><strong>-verbose:sizes</strong></a>, um den Wert auszugeben, den VM gerade verwendet.
</dd>
<dt class="bold"><font color="RED"><span id="changed">|</span><strong>-Xjarversion</strong></font></dt>
<dd><font color="RED"><span id="changed">|</span>Siehe
<span id="changed">|</span>hierzu den Abschnitt <a href="#build_number">Erhalten von Versionsinformationen</a>.</font>
</dd>
<dt class="bold"><a id="xoptions__xjit" name="xoptions__xjit"></a><span class="synph"><span class="kwd">-Xjit</span><span class="sep">[</span><span class="delim">:</span><span class="var">&lt;Unteroption&gt;</span><span class="delim">,</span><span class="var">&lt;Unteroption&gt;</span><span class="sep">...</span><span class="sep">]</span></span></dt>
<dd>Aktiviert den JIT-Compiler. Weitere Informationen zu den Unteroptionen finden Sie im Handbuch <a href="http://www.ibm.com/developerworks/java/jdk/diagnosis/60.html" target="_blank">Diagnostics Guide</a>. Siehe auch <a href="#xoptions__xnojit"><strong>-Xnojit</strong></a>.
Der JIT-Compiler ist standardm&auml;&szlig;ig aktiviert.
</dd>
<dt class="bold"><a id="xoptions__xlinenumbers" name="xoptions__xlinenumbers"></a><strong>-Xlinenumbers</strong></dt>
<dd>Zeigt Zeilennummern in Stack-Traces f&uuml;r das Debugging an. Siehe auch <a href="#xoptions__xnolinenumbers"><strong>-Xnolinenumbers</strong></a>. Zeilennummern sind standardm&auml;&szlig;ig aktiviert.
</dd>
<dt class="bold"><a id="xoptions__loa" name="xoptions__loa"></a><strong>-Xloa</strong></dt>
<dd>Ordnet einen LOA (Large Object Area) zu. Objekte werden diesem LOA statt dem SOA zugeordnet. Standardm&auml;&szlig;ig ist der LOA f&uuml;r alle GC-Richtlinien aktiviert, mit Ausnahme des Speicherteilbereichs, in dem der LOA nicht verf&uuml;gbar ist. Siehe auch <a href="#xoptions__noloa"><strong>-Xnoloa</strong></a>.
</dd>
<dt class="bold"><strong>-Xloainitial</strong><em>&lt;Prozentsatz&gt;</em></dt>
<dd><em>&lt;Prozentsatz&gt;</em> liegt zwischen 0 und 0,95 und gibt den Anfangsprozentsatz des aktuellen Bereichs f&uuml;r alte Objekte an, der dem LOA (Large Object Area) zugeordnet ist. Die Standardeinstellung lautet 0,05 oder 5 %.
</dd>
<dt class="bold"><strong>-Xloamaximum</strong><em>&lt;Prozentsatz&gt;</em></dt>
<dd><em>&lt;Prozentsatz&gt;</em> liegt zwischen 0 und 0,95 und gibt den maximalen Prozentsatz des aktuellen Bereichs f&uuml;r alte Objekte an, der dem LOA (Large Object Area) zugeordnet ist. Die Standardeinstellung lautet 0,5 oder 50 %.
</dd>
<dt class="bold"><a id="xoptions__xlp" name="xoptions__xlp"></a><strong>-Xlp</strong></dt>
<dd>Fordert JVM auf, Java-Freispeicher mit gro&szlig;en Seiten zuzuordnen. Wenn keine gro&szlig;en Seiten zur Verf&uuml;gung stehen, startet JVM nicht, und die folgende Fehlernachricht wird angezeigt: <tt class="xph">GC: Systemkonfiguration unterst&uuml;tzt Option --&gt; '-Xlp' nicht</tt>. JVM verwendet shmget(), um dem Freispeicher gro&szlig;e Seiten zuzuordnen. Gro&szlig;e Seiten werden von Systemen unterst&uuml;tzt, die den Linux-Kernel ab Version 2.6 oder fr&uuml;here Kernel ausf&uuml;hren, bei denen die Unterst&uuml;tzung gro&szlig;er Seiten nachtr&auml;glich hinzugef&uuml;gt wurde. Standardm&auml;&szlig;ig werden keine gro&szlig;en Seiten verwendet. Siehe den Abschnitt <a href="#alloc_large_page">Konfigurieren einer Speicherzuordnung von gro&szlig;en Seiten</a>.
</dd>
<dt class="bold"><strong>-Xmaxe</strong><em>&lt;Gr&ouml;&szlig;e&gt;</em></dt>
<dd>Definiert den Maximalwert, um den der Garbage-Collector den Freispeicher erweitert.
Standardm&auml;&szlig;ig erweitert der Garbage-Collector den Freispeicher, wenn sich der freie Speicherbereich auf unter 30 % verringert (oder um den Wert, der mit <strong>-Xminf</strong> angegeben wurde). Der Freispeicher wird dann um den Wert erweitert, der f&uuml;r die Wiederherstellung von 30 % freiem Speicherbereich erforderlich ist. Die Option <strong>-Xmaxe</strong> begrenzt die Erweiterung auf den angegeben Wert. Beispielsweise begrenzt die Angabe von <tt class="xph">-Xmaxe10M</tt> die Erweiterung auf 10 MB. Standardm&auml;&szlig;ig ist keine maximale Gr&ouml;&szlig;e f&uuml;r die Erweiterung angegeben.
</dd>
<dt class="bold"><strong>-Xmaxf</strong><em>&lt;Prozentsatz&gt;</em></dt>
<dd>Definiert den maximalen Prozentsatz des Freispeichers, der nach einer Garbage-Collection frei sein muss. Wenn der freie Speicherbereich diesen Prozentsatz &uuml;berschreitet, versucht JVM, den Freispeicher zu verkleinern. Der Standardwert lautet 0,6 (60 %).
</dd>
<dt class="bold"><strong>-Xmca</strong><em>&lt;Gr&ouml;&szlig;e&gt;</em></dt>
<dd>Definiert den Erweiterungsschritt f&uuml;r den Speicher, der zum Speichern des Arbeitsspeicherabschnitts f&uuml;r geladene Klassen zugeordnet wurde. Wenn mehr Speicher zum Speichern von Klassen im Arbeitsspeicher erforderlich ist, wird der zugeordnete Speicher um diesen Wert erh&ouml;ht. Standardm&auml;&szlig;ig lautet der Erweiterungsschritt
32 KB. Verwenden Sie die Option <a href="#standard_options__verbose"><strong>-verbose:sizes</strong></a>, um den Wert auszugeben, den VM gerade verwendet.
</dd>
<dt class="bold"><strong>-Xmco</strong><em>&lt;Gr&ouml;&szlig;e&gt;</em></dt>
<dd>Definiert den Erweiterungsschritt f&uuml;r den Speicher, der zum Speichern des ROM-Abschnitts f&uuml;r geladene Klassen zugeordnet wurde. Wenn mehr Speicher zum Speichern von Klassen im ROM erforderlich ist, wird der zugeordnete Speicher um diesen Wert erh&ouml;ht. Standardm&auml;&szlig;ig lautet der Erweiterungsschritt
128 KB. Verwenden Sie die Option <a href="#standard_options__verbose"><strong>-verbose:sizes</strong></a>, um den Wert auszugeben, den VM gerade verwendet.
</dd>
<dt class="bold"><strong>-Xmine</strong><em>&lt;Gr&ouml;&szlig;e&gt;</em></dt>
<dd>Definiert den Mindestwert, um den der Garbage-Collector den Freispeicher erweitert.
Standardm&auml;&szlig;ig erweitert der Garbage-Collector den Freispeicher um den Wert, der f&uuml;r die Wiederherstellung von 30 % freiem Speicherbereich erforderlich ist (oder um den Wert, der mit <strong>-Xminf</strong> angegeben wurde).
Die Option <strong>-Xmine</strong> setzt die Erweiterung auf mindestens den angegebenen Wert. Beispielsweise wird mit der Angabe <tt class="xph">-Xmine50M</tt> eine Mindesterweiterungsgr&ouml;&szlig;e von 50 MB angegeben. Standardm&auml;&szlig;ig lautet die Erweiterungsgr&ouml;&szlig;e 1 MB.
</dd>
<dt class="bold"><strong>-Xminf</strong><em>&lt;Prozentsatz&gt;</em></dt>
<dd>Definiert den Mindestprozentsatz des Freispeichers, der nach einer Garbage-Collection frei sein sollte. Wenn der freie Speicherbereich diesen Wert unterschreitet, versucht JVM, den Freispeicher zu erweitern. Standardm&auml;&szlig;ig lautet der Mindestwert 0,3 (30 %).
</dd>
<dt class="bold"><strong>-Xmn</strong><em>&lt;Gr&ouml;&szlig;e&gt;</em></dt>
<dd>Legt f&uuml;r die Anfangsgr&ouml;&szlig;e und die maximale Gr&ouml;&szlig;e des neuen Freispeichers den angegebenen Wert fest, wenn <strong>-Xgcpolicy:gencon</strong> verwendet wird. Die Definition von <strong>-Xmn</strong> ist &auml;quivalent mit der Definition von <strong>-Xmns</strong> und <strong>-Xmnx</strong>. <span>Wenn Sie <strong>-Xmns</strong> oder <strong>-Xmnx</strong> definieren, k&ouml;nnen Sie <strong>-Xmn</strong> nicht definieren. Wenn Sie versuchen, <strong>-Xmn</strong> mit Hilfe von <strong>-Xmns</strong> oder <strong>-Xmnx</strong> zu definieren, startet VM nicht, und eine Fehlermeldung wird zur&uuml;ckgegeben.</span> <strong>-Xmn</strong> wird standardm&auml;&szlig;ig intern ausgew&auml;hlt, je nach der Funktionalit&auml;t Ihres Systems. Verwenden Sie die Option <a href="#standard_options__verbose"><strong>-verbose:sizes</strong></a>, um den Wert auszugeben, den VM gerade verwendet.
</dd>
<dt class="bold"><strong>-Xmns</strong><em>&lt;Gr&ouml;&szlig;e&gt;</em></dt>
<dd>Legt f&uuml;r die Anfangsgr&ouml;&szlig;e des neuen Freispeichers den angegebenen Wert fest, wenn <strong>-Xgcpolicy:gencon</strong> verwendet wird. Diese Option wird standardm&auml;&szlig;ig intern ausgew&auml;hlt, je nach der Funktionalit&auml;t Ihres Systems. <span>Diese Option gibt eine Fehlermeldung zur&uuml;ck, wenn Sie sie mit der Option <strong>-Xmn</strong> verwenden.</span> Verwenden Sie die Option <a href="#standard_options__verbose"><strong>-verbose:sizes</strong></a>, um den Wert auszugeben, den VM gerade verwendet.
</dd>
<dt class="bold"><strong>-Xmnx</strong><em>&lt;Gr&ouml;&szlig;e&gt;</em></dt>
<dd>Legt f&uuml;r die maximale Gr&ouml;&szlig;e des neuen Freispeichers den angegebenen Wert fest, wenn <strong>-Xgcpolicy:gencon</strong> verwendet wird. Diese Option wird standardm&auml;&szlig;ig intern ausgew&auml;hlt, je nach der Funktionalit&auml;t Ihres Systems. <span>Diese Option gibt eine Fehlermeldung zur&uuml;ck, wenn Sie sie mit der Option <strong>-Xmn</strong> verwenden.</span> Verwenden Sie die Option <a href="#standard_options__verbose"><strong>-verbose:sizes</strong></a>, um den Wert auszugeben, den VM gerade verwendet.
</dd>
<dt class="bold"><a id="xoptions__xmo" name="xoptions__xmo"></a><strong>-Xmo</strong><em>&lt;Gr&ouml;&szlig;e&gt;</em></dt>
<dd>Legt f&uuml;r die Anfangsgr&ouml;&szlig;e und die maximale Gr&ouml;&szlig;e des Freispeichers f&uuml;r alte Objekte den angegebenen Wert fest, wenn <strong>-Xgcpolicy:gencon</strong> verwendet wird. Ist &auml;quivalent zur Definition von <strong>-Xmos</strong> und <strong>-Xmox</strong>. <span>Wenn Sie <strong>-Xmos</strong> oder <strong>-Xmox</strong> definieren, k&ouml;nnen Sie <strong>-Xmo</strong> nicht definieren. Wenn Sie versuchen, <strong>-Xmo</strong> mit Hilfe von <strong>-Xmos</strong> oder <strong>-Xmox</strong> zu definieren, startet VM nicht, und eine Fehlermeldung wird zur&uuml;ckgegeben. </span> Standardm&auml;&szlig;ig wird <strong>-Xmo</strong> intern ausgew&auml;hlt, je nach der Funktionalit&auml;t Ihres Systems. Verwenden Sie die Option <a href="#standard_options__verbose"><strong>-verbose:sizes</strong></a>, um den Wert auszugeben, den VM gerade verwendet.
</dd>
<dt class="bold"><strong>-Xmoi</strong><em>&lt;Gr&ouml;&szlig;e&gt;</em></dt>
<dd>Definiert den Wert, um den der Java-Freispeicher stufenweise erweitert wird, wenn <strong>-Xgcpolicy:gencon</strong> verwendet wird.
Wenn der Wert null betr&auml;gt, ist keine Erweiterung zul&auml;ssig. Die Gr&ouml;&szlig;e der einzelnen Stufen wird standardm&auml;&szlig;ig auf der Grundlage der Erweiterungsgr&ouml;&szlig;e, <strong>-Xmine</strong> und <strong>-Xminf</strong> berechnet.
</dd>
<dt class="bold"><strong>-Xmos</strong><em>&lt;Gr&ouml;&szlig;e&gt;</em></dt>
<dd>Legt f&uuml;r die Anfangsgr&ouml;&szlig;e des Freispeichers f&uuml;r alte Objekte den angegebenen Wert fest, wenn <strong>-Xgcpolicy:gencon</strong> verwendet wird. Diese Option wird standardm&auml;&szlig;ig intern ausgew&auml;hlt, je nach der Funktionalit&auml;t Ihres Systems. <span>Diese Option gibt eine Fehlermeldung zur&uuml;ck, wenn Sie sie zusammen mit der Option <strong>-Xmo</strong> verwenden.</span> Verwenden Sie die Option <a href="#standard_options__verbose"><strong>-verbose:sizes</strong></a>, um den Wert auszugeben, den VM gerade verwendet.
</dd>
<dt class="bold"><strong>-Xmox</strong><em>&lt;Gr&ouml;&szlig;e&gt;</em></dt>
<dd>Legt f&uuml;r die maximale Gr&ouml;&szlig;e des Freispeichers f&uuml;r alte Objekte den angegebenen Wert fest, wenn <strong>-Xgcpolicy:gencon</strong> verwendet wird. Diese Option wird standardm&auml;&szlig;ig intern ausgew&auml;hlt, je nach der Funktionalit&auml;t Ihres Systems. <span>Diese Option gibt eine Fehlermeldung zur&uuml;ck, wenn Sie sie zusammen mit der Option <strong>-Xmo</strong> verwenden.</span> Verwenden Sie die Option <a href="#standard_options__verbose"><strong>-verbose:sizes</strong></a>, um den Wert auszugeben, den VM gerade verwendet.
</dd>
<dt class="bold"><strong>-Xmr</strong><em>&lt;Gr&ouml;&szlig;e&gt;</em></dt>
<dd>Definiert die Gr&ouml;&szlig;e f&uuml;r die "gemerkte Gruppe" der Garbage-Collection, wenn <strong>-Xgcpolicy:gencon</strong> verwendet wird.
Es handelt sich um eine Liste mit Objekten im alten Freispeicher, die auf Objekte im neuen Freispeicher verweisen. Die Standardeinstellung f&uuml;r diese Option lautet 16 Kilobyte.
Verwenden Sie die Option <a href="#standard_options__verbose"><strong>-verbose:sizes</strong></a>, um den Wert auszugeben, den VM gerade verwendet.
</dd>
<dt class="bold"><strong>-Xmrx</strong><em>&lt;Gr&ouml;&szlig;e&gt;</em></dt>
<dd>Definiert die gespeicherte maximale Gr&ouml;&szlig;eneinstellung.
</dd>
<dt class="bold"><a id="xoptions__xms" name="xoptions__xms"></a><strong>-Xms</strong><em>&lt;Gr&ouml;&szlig;e&gt;</em></dt>
<dd>Definiert die Anfangsgr&ouml;&szlig;e des Java-Freispeichers.  Sie k&ouml;nnen auch die Option <a href="#xoptions__xmo"><strong>-Xmo</strong></a>. verwenden. Der Standardwert wird intern entsprechend der Funktionalit&auml;t Ihres Systems definiert. Verwenden Sie die Option <a href="#standard_options__verbose"><strong>-verbose:sizes</strong></a>, um den Wert auszugeben, den VM gerade verwendet.
</dd>
<dt class="bold"><strong>-Xmso</strong><em>&lt;Gr&ouml;&szlig;e&gt;</em></dt>
<dd>Definiert die C-Stackgr&ouml;&szlig;e f&uuml;r verzweigte Java-Threads. Die Standardeinstellung f&uuml;r diese Option lautet 32 KB auf 32-Bit-Plattformen und 256 KB auf 64-Bit-Plattformen. Verwenden Sie die Option <a href="#standard_options__verbose"><strong>-verbose:sizes</strong></a>, um den Wert auszugeben, den VM gerade verwendet.
</dd>
<dt class="bold"><strong>-Xmx</strong><em>&lt;Gr&ouml;&szlig;e&gt;</em></dt>
<dd>Definiert die Maximalgr&ouml;&szlig;e des Java-Freispeichers. Die Standardeinstellung f&uuml;r diese Option wird intern entsprechend der Funktionalit&auml;t Ihres Systems definiert. Verwenden Sie die Option <a href="#standard_options__verbose"><strong>-verbose:sizes</strong></a>, um den Wert auszugeben, den VM gerade verwendet.
</dd>
<dt class="bold"><a id="xoptions__noclassgc" name="xoptions__noclassgc"></a><strong>-Xnoclassgc</strong></dt>
<dd>Inaktiviert die Garbage-Collection f&uuml;r Klassen. Diese Option inaktiviert die Garbage-Collection f&uuml;r Speicher, der Java-Klassen zugeordnet ist, die nicht mehr von JVM verwendet werden sollen. Siehe auch <a href="#xoptions__classgc"><strong>-Xclassgc</strong></a>.
Standardm&auml;&szlig;ig wird eine Garbage-Collection f&uuml;r Klassen ausgef&uuml;hrt.
</dd>
<dt class="bold"><a id="xoptions__nocompactexplicitgc" name="xoptions__nocompactexplicitgc"></a><strong>-Xnocompactexplicitgc</strong></dt>
<dd>Inaktiviert die Komprimierung beim Aufruf an <tt class="xph">System.gc()</tt>. Siehe auch <a href="#xoptions__compactexplicitgc"><strong>-Xcompactexplicitgc</strong></a>.
Die Komprimierung ist bei Aufrufen an <tt class="xph">System.gc()</tt> standardm&auml;&szlig;ig aktiviert.
</dd>
<dt class="bold"><a id="xoptions__nocompactgc" name="xoptions__nocompactgc"></a><strong>-Xnocompactgc</strong></dt>
<dd>Inaktiviert die Komprimierung f&uuml;r den Garbage-Collector. Siehe auch <a href="#xoptions__compactgc"><strong>-Xcompactgc</strong></a>.
Die Komprimierung ist standardm&auml;&szlig;ig aktiviert.
</dd>
<dt class="bold"><a id="xoptions__xnojit" name="xoptions__xnojit"></a><strong>-Xnojit</strong></dt>
<dd>Inaktiviert den JIT-Compiler. Siehe auch <a href="#xoptions__xjit"><strong>-Xjit</strong></a>.
Der JIT-Compiler ist standardm&auml;&szlig;ig aktiviert.
</dd>
<dt class="bold"><a id="xoptions__xnolinenumbers" name="xoptions__xnolinenumbers"></a><strong>-Xnolinenumbers</strong></dt>
<dd>Inaktiviert die Zeilennummern f&uuml;r das Debugging. Siehe auch <a href="#xoptions__xlinenumbers"><strong>-Xlinenumbers</strong></a>.
Zeilennummern sind standardm&auml;&szlig;ig aktiviert.
</dd>
<dt class="bold"><a id="xoptions__noloa" name="xoptions__noloa"></a><strong>-Xnoloa</strong></dt>
<dd>Verhindert die Zuordnung eines LOAs (Large Object Area). Alle Objekte werden im SOA zugeordnet. Standardm&auml;&szlig;ig ist der LOA f&uuml;r alle GC-Richtlinien aktiviert, mit Ausnahme des Speicherteilbereichs, in dem der LOA nicht verf&uuml;gbar ist. Siehe auch <a href="#xoptions__loa"><strong>-Xloa</strong></a>.
</dd>
<dt class="bold"><a id="xoptions__nopartialcompactgc" name="xoptions__nopartialcompactgc"></a><strong>-Xnopartialcompactgc</strong></dt>
<dd>Inaktiviert die schrittweise ausgef&uuml;hrte Komprimierung. Siehe auch <a href="#xoptions__partialcompactgc"><strong>-Xpartialcompactgc</strong></a>.
</dd>
<dt class="bold"><a id="xoptions__nosigcatch" name="xoptions__nosigcatch"></a><strong>-Xnosigcatch</strong></dt>
<dd>Inaktiviert den JVM-Signalverarbeitungscode. Siehe auch <a href="#xoptions__sigcatch"><strong>-Xsigcatch</strong></a>.
Die Signalverarbeitung ist standardm&auml;&szlig;ig aktiviert.
</dd>
<dt class="bold"><a id="xoptions__nosigchain" name="xoptions__nosigchain"></a><strong>-Xnosigchain</strong></dt>
<dd>Inaktiviert die Verkettung von Signalroutinen. Siehe auch <a href="#xoptions__sigchain"><strong>-Xsigchain</strong></a>.
Die Verkettung von Signalroutinen ist standardm&auml;&szlig;ig aktiviert.
</dd>
<dt class="bold"><strong>-Xoptionsfile</strong>=<em>&lt;Datei&gt;</em></dt>
<dd>Gibt eine Datei an, die JVM-Optionen und die zugeh&ouml;rigen Definitionen enth&auml;lt. Standardm&auml;&szlig;ig wird keine Optionsdatei verwendet.
</dd>
<dt class="bold"><strong>-Xoss</strong><em>&lt;Gr&ouml;&szlig;e&gt;</em></dt>
<dd>Definiert die Java-Stackgr&ouml;&szlig;e und die C-Stackgr&ouml;&szlig;e f&uuml;r einen beliebigen Thread. Diese Option wird aus Kompatibilit&auml;tsgr&uuml;nden zur Verf&uuml;gung gestellt und entspricht der Einstellung von <strong>-Xss</strong> und von <strong>-Xmso</strong> auf den angegebenen Wert.
</dd>
<dt class="bold"><a id="xoptions__partialcompactgc" name="xoptions__partialcompactgc"></a><strong>-Xpartialcompactgc</strong></dt>
<dd>Inaktiviert die Teilkomprimierung. Diese Option ist standardm&auml;&szlig;ig nicht definiert, somit werden alle Komprimierungen vollst&auml;ndig ausgef&uuml;hrt. Siehe auch <a href="#xoptions__nopartialcompactgc"><strong>-Xnopartialcompactgc</strong></a>.
</dd>
<dt class="bold"><strong>-Xquickstart</strong></dt>
<dd>Verbessert die Startzeit durch das Verz&ouml;gern der JIT-Kompilierung und der Optimierungen. Diese Option ist standardm&auml;&szlig;ig inaktiviert und die JIT-Kompilierung wird nicht verz&ouml;gert.
</dd>
<dt class="bold"><strong>-Xrdbginfo</strong>:<em>&lt;Host&gt;</em>:<em>&lt;Port&gt;</em></dt>
<dd>L&auml;dt und &uuml;bergibt Optionen an den fernen Debuginformationsserver. Der ferne Debuginformationsserver ist standardm&auml;&szlig;ig inaktiviert.
</dd>
<dt class="bold"><strong>-Xrs</strong></dt>
<dd>Reduziert die Verwendung von Betriebssystemsignalen. JVM nutzt die Betriebssystemsignale standardm&auml;&szlig;ig vollst&auml;ndig. Siehe <a href="#sighand">Von JVM verwendete Signale</a>.
</dd>
<dt class="bold"><strong>-Xrun</strong><em>&lt;Bibliotheksname&gt;</em>[:<em>&lt;Optionen&gt;</em>]</dt>
<dd>L&auml;dt Bibliotheken mit Hilfeprogrammen. Geben Sie zum Laden
mehrerer Bibliotheken diese Option mehrmals in der Befehlszeile an. Beispiele f&uuml;r diese Bibliotheken: 

<dl class="parml">
<dt class="bold"><strong>-Xrunhprof</strong>[:help] | [:<em>&lt;Option&gt;</em>=<em>&lt;Wert&gt;</em>,
...]</dt>
<dd>Erstellt Profile f&uuml;r Freispeicher, CPU oder &Uuml;berwachungsprogramme. Weitere Informationen finden Sie im Handbuch <a href="http://www.ibm.com/developerworks/java/jdk/diagnosis/60.html" target="_blank">Diagnostics Guide</a>.
</dd>
<dt class="bold"><a id="xoptions__runjdwp" name="xoptions__runjdwp"></a><strong>-Xrunjdwp</strong>[:help] | [:&lt;<em>Option</em>&gt;=&lt;<em>Wert</em>&gt;,
...]</dt>
<dd>L&auml;dt Debugbibliotheken, damit das ferne Debugging von Anwendungen unterst&uuml;tzt wird.
Weitere Informationen hierzu finden Sie in <a href="#xoptions__xdbg"><strong>-Xdbg</strong></a>.
</dd>
<dt class="bold"><a name="xoptions__xrunjnichk"></a><strong id="xoptions__xrunjnichk">-Xrunjnichk</strong>[:help] | [:&lt;<em>Option</em>&gt;=&lt;<em>Wert</em>&gt;,
...]</dt>
<dd>Veraltet; verwenden Sie <strong>-Xcheck:jni</strong>.
</dd>
</dl>
</dd>
<dt class="bold"><strong>-Xscmx</strong><em>&lt;Gr&ouml;&szlig;e&gt;</em></dt>
<dd>Weitere Informationen zu <strong>-Xscmx</strong> finden Sie in <a href="#sharedclassesxoptions">Aktivieren und Konfigurieren der gemeinsamen Nutzung von Klassendaten</a>.
</dd>
<dt class="bold"><strong>-Xshareclasses</strong>:<em>&lt;Optionen&gt;</em></dt>
<dd>Weitere Informationen zu den <strong>-Xshareclasses</strong>-Optionen finden Sie in <a href="#sharedclassesxoptions">Aktivieren und Konfigurieren der gemeinsamen Nutzung von Klassendaten</a>.
</dd>
<dt class="bold"><a id="xoptions__sigcatch" name="xoptions__sigcatch"></a><strong>-Xsigcatch</strong></dt>
<dd>Aktiviert den VM-Signalverarbeitungscode. Siehe auch <a href="#xoptions__nosigcatch"><strong>-Xnosigcatch</strong></a>.
Die Signalverarbeitung ist standardm&auml;&szlig;ig aktiviert.
</dd>
<dt class="bold"><a id="xoptions__sigchain" name="xoptions__sigchain"></a><strong>-Xsigchain</strong></dt>
<dd> Aktiviert die Verkettung von Signalroutinen. Siehe auch <a href="#xoptions__nosigchain"><strong>-Xnosigchain</strong></a>.
Die Verkettung von Signalroutinen ist standardm&auml;&szlig;ig aktiviert.
</dd>
<dt class="bold"><strong>-Xsoftrefthreshold</strong><em>&lt;Anzahl&gt;</em></dt>
<dd>Definiert die Anzahl GCs. Anschlie&szlig;end wird ein indirekter Verweis gel&ouml;scht, wenn das zugeh&ouml;rige Verweisobjekt nicht markiert wurde. Die Standardeinstellung lautet 3. Dies bedeutet, dass der indirekte Verweis bei der dritten GC, bei der das Verweisobjekt nicht markiert ist, gel&ouml;scht wird.
</dd>
<dt class="bold"><strong>-Xss</strong><em>&lt;Gr&ouml;&szlig;e&gt;</em></dt>
<dd>Definiert die Maximalgr&ouml;&szlig;e f&uuml;r den Java-Stack f&uuml;r einen beliebigen Thread. Standardm&auml;&szlig;ig wird dieser Wert auf 256 KB gesetzt. Verwenden Sie die Option <a href="#standard_options__verbose"><strong>-verbose:sizes</strong></a>, um den Wert auszugeben, den VM gerade verwendet.
</dd>
<dt class="bold"><strong>-Xthr</strong>:<em>&lt;Optionen&gt;</em></dt>
<dd>Definiert die Threading-Optionen.
</dd>
<dt class="bold"><a id="xoptions__xverbosegclog" name="xoptions__xverbosegclog"></a><strong>-Xverbosegclog</strong>:<em>&lt;Dateipfad&gt;</em>[<em>X</em>,<em>Y</em>]</dt>
<dd>
<p>Die Ausgabe der ausf&uuml;hrlichen Garbage-Collection (GC) wird in die angegebene Datei geschrieben. Wenn die Datei bereits vorhanden ist, wird sie &uuml;berschrieben. Ist dies nicht der Fall, wird die Ausgabe an stderr umgeleitet, falls
eine vorhandene Datei nicht ge&ouml;ffnet oder eine neue Datei nicht
erstellt werden kann. Wenn Sie die Argumente X und Y (bei beiden handelt es sich um ganze Zahlen) angeben, wird die Ausgabe der ausf&uuml;hrlichen Garbage-Collection an X Dateien umgeleitet, von denen jede Y gc-Zyklen mit Ausgaben von ausf&uuml;hrlichen Garbage-Collections enth&auml;lt. Diese Dateien weisen folgendes Format auf:
<em>Dateiname1, Dateiname2</em> usw. Die Protokollierung der ausf&uuml;hrlichen GC wird nicht standardm&auml;&szlig;ig durchgef&uuml;hrt.</p>

<p>Weitere Informationen zur Ausgabe der ausf&uuml;hrlichen GC finden Sie im Handbuch <a href="http://www.ibm.com/developerworks/java/jdk/diagnosis/60.html" target="_blank">Diagnostics Guide</a>.</p>
</dd>
<dt class="bold"><strong>-Xverify</strong></dt>
<dd>Aktiviert die genaue Pr&uuml;fung aller geladenen Klassen. Die genaue Pr&uuml;fung von Klassen ist standardm&auml;&szlig;ig inaktiviert.
</dd>
<dt class="bold"><strong>-Xverify:none</strong></dt>
<dd>Inaktiviert die genaue Pr&uuml;fung von Klassen. Die genaue Pr&uuml;fung von Klassen ist standardm&auml;&szlig;ig inaktiviert.
</dd>
</dl>
<a name="limitations"></a>
<h1 id="limitations"><a href="#ToC_136">Anhang B. Bekannte Einschr&auml;nkungen</a></h1>
<div>
<p>Hier werden bekannte Einschr&auml;nkungen f&uuml;r SDK und Runtime Environment for Linux erl&auml;utert.</p></div>
<p>
<p>Weitere Hilfestellungen zur Problemdiagnose finden Sie im <cite>Diagnostics Guide</cite> unter <a href="http://www.ibm.com/developerworks/java/jdk/diagnosis/60.html" target="_blank">http://www.ibm.com/developerworks/java/jdk/diagnosis/60.html</a>.</p></p>
<p>
<a name="wq154"></a>
<h2 id="wq154">BIOS-Einstellungen auf AMD64 SMP-Systemen</h2>
<p>Die BIOS-Einstellung <strong>Node memory interleaving</strong> muss auf
<tt class="xph">DISABLED</tt> gesetzt werden. Andernfalls k&ouml;nnen unvorhersehbare Fehler auftreten,
wie z.&nbsp;B.
Ausf&auml;lle und Blockierungen in Java-Anwendungen. Diese Anweisung stimmt mit den Empfehlungen von AMD &uuml;berein.</p></p>
<p>
<a name="wq155"></a>
<h2 id="wq155">Indexzunge 'Local' des &Uuml;berwachungstools JConsole</h2>
<p>Im Tool JConsole von IBM ist die Indexzunge <strong>Local</strong>, &uuml;ber die Sie Verbindungen zu anderen virtuellen Maschinen auf dem selben System herstellen k&ouml;nnen, nicht verf&uuml;gbar.
Au&szlig;erdem wird die entsprechende Befehlszeilenoption <strong>pid</strong> nicht unterst&uuml;tzt. Verwenden Sie stattdessen die Indexzunge <strong>Remote</strong> in JConsole, um eine Verbindung zu der virtuellen Maschine herzustellen, die Sie &uuml;berwachen wollen. Verwenden Sie alternativ dazu die Befehlszeilenoption
<strong>connection</strong>, indem Sie einen Host von
<tt class="xph">localhost</tt> und eine Portnummer angeben. Legen Sie beim Starten der zu &uuml;berwachenden Anwendung die folgenden Befehlszeilenoptionen fest:
</p>
<dl class="parml">
<dt class="bold"><strong>-Dcom.sun.management.jmxremote.port</strong>=<em>&lt;Wert&gt;</em></dt>
<dd>Gibt den Port an, an dem der Managementagent empfangsbereit sein sollte.
</dd>
<dt class="bold"><strong>-Dcom.sun.management.jmxremote.authenticate=false</strong></dt>
<dd>Inaktiviert die Authentifizierung, sofern Sie keine Benutzernamendatei erstellt haben.
</dd>
<dt class="bold"><strong>-Dcom.sun.management.jmxremote.ssl=false</strong></dt>
<dd>Inaktiviert die SSL-Verschl&uuml;sselung.
</dd>
</dl></p>
<p>
<a name="wq156"></a>
<h2 id="wq156">Die JavaScript-Steuerkomponente Rhino ist nicht vorhanden</h2>
<p>Auf Grund von Lizenzierungsproblemen umfasst IBM SDK for Java nicht die JavaScript-Steuerkomponente Mozilla Rhino. Laden Sie zum Verwenden der JavaScript-Steuerkomponente Rhino mit IBM SDK for Java die Steuerkomponente zur Scripterstellung jsr223 von <a href="https://scripting.dev.java.net/" target="_blank">https://scripting.dev.java.net/</a> und die JavaScript-Steuerkomponente Rhino von der Mozilla-Website <a href="http://www.mozilla.org/rhino/" target="_blank">http://www.mozilla.org/rhino/</a> herunter.</p></p>
<p>
<a name="wq157"></a>
<h2 id="wq157">Erstellen von DSA-Schl&uuml;sselpaaren</h2>
<p>Das Erstellen von besonders langen DSA-Schl&uuml;sselpaaren kann auf
langsamen Maschinen sehr lange dauern. Interpretieren Sie die Verz&ouml;gerung nicht als Blockierung, weil der
Prozess nach ausreichender Zeit beendet wird. Der Algorithmus f&uuml;r die Generierung von DSA-Schl&uuml;sseln wurde optimiert, um
Schl&uuml;ssel mit Standardl&auml;ngen (z.&nbsp;B. 512 oder 1024) schneller zu
generieren als andere.</p></p>
<p>
<a name="wq158"></a>
<h2 id="wq158">Erstellen von JVM mit Hilfe von JNI (Java Native Interface)</h2>
<p>Native
Programme k&ouml;nnen keine VM mit JNI_VERSION_1_1(0x00010001)-Schnittstellen erstellen. Es ist nicht m&ouml;glich, JNI_CreateJavaVM() aufzurufen und eine Version von JNI_VERSION_1_1(0x00010001) weiterzuleiten. Die folgenden Versionen k&ouml;nnen weitergeleitet werden:</p></p>
<ul>
<li>JNI_VERSION_1_2(0x00010002)</li>
<li>JNI_VERSION_1_4(0x00010004)</li></ul>
<p>Bei der erstellten VM handelt es sich um diejenige, die &uuml;ber die vorhandenen Java-Bibliotheken festgelegt wird (d. h. 1.2.2, 1.3.x, 1.4.x, 5.x, 6.x) und nicht um diejenige, die &uuml;ber die weitergeleitete
JNI-Schnittstellenversion festgelegt wird.</p>
<p>Die Schnittstellenversion hat nur Auswirkungen auf die f&uuml;r den nativen Code verf&uuml;gbaren Funktionen.</p>
<p>
<a name="wq159"></a>
<h2 id="wq159">Fenstermanager und Tastaturkurzbefehle</h2>
<p>Ihr Fenstermanager setzt m&ouml;glicherweise einige Java-Tastaturkurzbefehle au&szlig;er Kraft. Wenn Sie einen au&szlig;er Kraft gesetzten Java-Tastaturkurzbefehl verwenden wollen, ziehen Sie das Handbuch zu Ihrem Betriebssystem zu Rate, und &auml;ndern Sie die Tastaturkurzbefehle Ihres Fenstermanagers.</p></p>
<p>
<a name="wq160"></a>
<h2 id="wq160">Dateideskriptoren von X Window System</h2>
<p>X Window System kann keine Dateideskriptoren &uuml;ber 255 verwenden. Da JVM Dateideskriptoren f&uuml;r ge&ouml;ffnete Jar-Dateien verwendet, ist es m&ouml;glich, dass f&uuml;r X nicht mehr gen&uuml;gend Dateideskriptoren zur Verf&uuml;gung stehen.
Als Fehlerumgehung k&ouml;nnen Sie die Umgebungsvariable <strong>JAVA_HIGH_ZIPFDS</strong> so definieren, dass sie JVM anweist, h&ouml;here Dateideskriptoren f&uuml;r JAR-Dateien zu verwenden.</p>
<p>Setzen Sie die Umgebungsvariable <strong>JAVA_HIGH_ZIPFDS</strong> auf einen Wert zwischen 0 und 512, um sie zu verwenden. JVM &ouml;ffnet dann die ersten JAR-Dateien mit den Dateideskriptoren bis 1024. Legen Sie die Umgebungsvariable z.&nbsp;B. wie folgt fest, wenn Ihr Programm voraussichtlich 300 JAR-Dateien &ouml;ffnet:</p>
<p><tt class="xph">export JAVA_HIGH_ZIPFDS=300</tt></p>
<p>Die ersten 300 JAR-Dateien werden dann mit den Dateideskriptoren 724 bis 1023 geladen.
Alle JAR-Dateien, die danach ge&ouml;ffnet werden, werden im normalen Bereich ge&ouml;ffnet.</p></p>
<p>
<a name="wq161"></a>
<h2 id="wq161">DBCS-Daten und die KDE-Zwischenablage</h2>
<p>M&ouml;glicherweise k&ouml;nnen Sie bei Verwendung von KDE (K Desktop
Environment) keine DBCS-Daten (Double Byte Character Set, Doppelbytezeichensatz)
&uuml;ber die Systemzwischenablage zwischen Linux-Anwendungen und Java-Anwendungen
kopieren.</p></p>
<p>
<a name="wq162"></a>
<h2 id="wq162">Begrenzung f&uuml;r Threads, die die Bibliothek LinuxThreads verwenden</h2>
<p>Unter SLES9 und neueren Distributionen ist die Standardthreadbibliothek NPTL. Sie implementiert Java-Threads als native Threads. Unter fr&uuml;heren Distributionen lautete die Standardthreadbibliothek LinuxThreads. Sie implementiert Threads als neue Prozesse. Wenn die Anzahl der Java-Threads die
maximal zul&auml;ssige Anzahl an Prozessen &uuml;berschreitet, blockiert Ihr System m&ouml;glicherweise.</p>
<p> Die maximale Anzahl der verf&uuml;gbaren Threads wird durch das
Minimum f&uuml;r die folgenden Werte bestimmt:</p></p>
<ul>
<li>Die Einstellung f&uuml;r die Benutzerprozesse (ulimit -u) in
/etc/security/limits.conf</li>
<li>Die in /proc/sys/kernel/threads_max definierte Begrenzung</li>
<li>Die in libpthreads.so definierte Begrenzung <strong>PTHREAD_THREADS_MAX</strong> (bei &Auml;nderung dieses Werts muss 'glibc' erneut kompiliert werden)</li></ul>
<p>Bevor die maximale Anzahl an Threads erreicht wird, kann
jedoch der virtuelle Speicher voll sein.</p>
<p>
<a name="wq163"></a>
<h2 id="wq163">Begrenzung der Benutzer-CPU-Zeit f&uuml;r den Thread ThreadMXBean</h2>
<p>Auf dieser Plattform gibt es keine M&ouml;glichkeit, zwischen Benutzer-CPU-Zeit und System-CPU-Zeit zu unterscheiden. ThreadMXBean.getThreadUserTime(), ThreadMXBean.getThreadCpuTime(), ThreadMXBean.getCurrentThreadUserTime() und ThreadMXBean.getCurrentThreadCpuTime() geben alle die gesamte CPU-Zeit f&uuml;r den erforderlichen Thread zur&uuml;ck.</p></p>
<p>
<a name="wq164"></a>
<h2 id="wq164">KeyEvents und Fenstermanager</h2>
<p>Die Ergebnisse von KeyEvent mit der Taste <strong>Alt</strong> k&ouml;nnen bei Verwendung unterschiedlicher Fenstermanager unter
Linux voneinander abweichen.
Sie
weichen auch von Ergebnissen anderer Betriebssysteme ab. Bei der Verwendung der Standardeinstellungen wird durch <strong>Strg+Alt+A</strong> im KWin-Fenstermanager ein
KeyEvent erstellt, w&auml;hrend durch <strong>Strg+Alt+A</strong> im Metacity-Fenstermanager keine Tastenkombination erstellt wird.</p></p>
<p>
<a name="wq165"></a>
<h2 id="wq165">X Window System und die Taste 'Meta'</h2>
<p>Auf einem Linux-System mit X Window ist die Tastenbelegung wie folgt festgelegt:
64 0xffe9 (Alt_L) 0xffe7 (Meta_L) und 113 0xffea (Alt_R) 0xffe8 (Meta_R). Dies k&ouml;nnen Sie &uuml;berpr&uuml;fen, indem Sie an einer
Shelleingabeaufforderung den folgenden Befehl eingeben:</p></p>
<pre class="xmp">xmodmap -pk  </pre>
<p>Daher erwartet SDK, dass Meta zusammen mit Alt gedr&uuml;ckt wird. Sie k&ouml;nnen dies umgehen und die Meta_x-Zuordnung entfernen, indem Sie Folgendes an der Shelleingabeaufforderung eingeben:</p>
<pre class="xmp">xmodmap -e "keysym Alt_L = Alt_L" -e "keysym Alt_R = Alt_R"  </pre>
<p>Diese L&ouml;sung kann sich auf andere X-Window-Anwendungen
auswirken, die &uuml;ber dieselbe Anzeige ausgef&uuml;hrt werden, wenn die
Meta-Tastenkombination verwendet wird, die Sie zuvor entfernt haben.</p>
<p>
<a name="wq166"></a>
<h2 id="wq166">Signal SIGSEGV beim Erstellen von JVM mit Hilfe von JNI (Java Native Interface)</h2>
<p>Der Aufruf von JNI_CreateJavaVM() &uuml;ber eine
JNI-Anwendung kann zu einem Segmentierungsfehler f&uuml;hren (Signal SIGSEGV). Zum Vermeiden dieses Fehlers m&uuml;ssen Sie das JNI-Programm unter Angabe der Option <strong>-lpthread</strong> erneut erstellen.</p></p>
<p>
<a name="wq167"></a>
<h2 id="wq167">Ressourcenmangel bei Anwendungen mit vielen Threads</h2>
<p>Wenn Sie viele gleichzeitig ablaufende Threads ausf&uuml;hren, wird m&ouml;glicherweise eine Warnung angezeigt:</p></p>
<pre class="xmp">java.lang.OutOfMemoryError</pre>
<p>Es handelt sich dabei um eine Meldung, dass nicht gen&uuml;gend
Systemressourcen zur Verf&uuml;gung stehen und Nachrichten aus
folgenden Gr&uuml;nden angezeigt werden k&ouml;nnen:</p>
<ul>
<li>Die Anzahl der erstellten Prozesse &uuml;berschreitet den f&uuml;r den Benutzer festgelegten Grenzwert. (Wenn Ihre Linux-Installation eher LinuxThreads als NPTL verwendet.)</li>
<li>Es stehen nicht gen&uuml;gend Systemressourcen zum Erstellen neuer
Threads zur Verf&uuml;gung. In diesem Fall werden m&ouml;glicherweise weitere Java-Ausnahmebedingungen angezeigt, abh&auml;ngig davon, welche Operationen Ihre Anwendung ausf&uuml;hrt.</li>
<li>Der Kernelspeicher bietet entweder nicht gen&uuml;gend Kapazit&auml;t oder ist fragmentiert. Im Verzeichnis /var/log/messages finden Sie entsprechende Kernel-Nachrichten, die darauf hinweisen, dass nicht gen&uuml;gend Speicher vorhanden ist, und die die ID des mit dem Befehl 'kill' beendeten Prozesses aufweisen.</li></ul>
<p>Versuchen Sie, Ihr System dahingehend zu optimieren, dass die entsprechenden Systemressourcen erh&ouml;ht werden.</p>
<p>
<a name="wq168"></a>
<h2 id="wq168">Probleme zwischen den Schriftarten auf dem X-Server und dem X-Client</h2>
<p>Wenn Sie eine Java AWT- oder Swing-Anwendung auf einer Linux-Maschine ausf&uuml;hren und die Anzeige auf eine andere Maschine exportieren, treten m&ouml;glicherweise Fehler beim Anzeigen einiger Dialoge auf, wenn die Gruppe der geladenen Schriftarten auf der X-Clientmaschine sich von der Gruppe unterscheidet, die auf der X-Servermaschine geladen wurde.  Installieren Sie zur Vermeidung dieses Fehlers auf beiden Maschinen dieselben Schriftarten.</p></p>
<p>
<a name="wq169"></a>
<h2 id="wq169">UTF-8-Verschl&uuml;sselung und die Ausnahmebedingungen 'MalformedInputException'</h2>
<p>Wenn in der L&auml;ndereinstellung Ihres Systems eine UTF-8-Verschl&uuml;sselung verwendet wird, l&ouml;sen einige SDK-Tools m&ouml;glicherweise die Ausnahmebedingung sun.io.MalformedInputException aus.
Wenn Sie herausfinden m&ouml;chten, ob Ihr System eine UTF-8-Verschl&uuml;sselung verwendet, untersuchen Sie die f&uuml;r die L&auml;ndereinstellung spezifischen Umgebungsvariablen, wie z.&nbsp;B.
<strong>LANG</strong> oder <strong>LC_ALL</strong>, um zu pr&uuml;fen, ob sie mit dem Suffix &quot;.UTF-8&quot; enden. Wenn Sie die Ausnahmebedingung sun.io.MalformedInputException erhalten, &auml;ndern Sie die Zeichen, die nicht im 7-Bit-ASCII-Bereich (0x00 - 0x7f) liegen und nicht als Java-Unicode-Zeichenliterale dargestellt werden, in Java-Unicode-Zeichenliterale (z.&nbsp;B. '\u0080'). Sie k&ouml;nnen dieses Problem auch umgehen, indem Sie das Suffix &quot;.UTF-8&quot; aus den f&uuml;r die L&auml;ndereinstellung spezifischen Umgebungsvariablen entfernen. Wenn Ihre Maschine beispielsweise die Standardl&auml;ndereinstellung &quot;en_US.UTF-8&quot; hat, setzen Sie <strong>LANG</strong> auf &quot;en_US&quot;.</p></p>
<p>
<a name="wq170"></a>
<h2 id="wq170">Probleme mit AMI und 'xcin' beim Exportieren von Anzeigen</h2>
<p>Wenn Sie AMI und 'xcin' in einer plattform&uuml;bergreifenden Umgebung verwenden (z.&nbsp;B., wenn Sie versuchen, die Anzeige von einem 32-Bit- in ein 64-Bit-System bzw. von einem Big Endian- in ein Little Endian-System zu exportieren), treten m&ouml;glicherweise Probleme auf. F&uuml;hren Sie ein Upgrade auf die neueste Version von AMI und 'xcin' durch, wenn dies der Fall ist.</p></p>
<p>
<a name="wq171"></a>
<h2 id="wq171">RHEL4 und XIM</h2>
<p><strong>Nur f&uuml;r Benutzer der Version von RHEL4 in Chinesisch, Koreanisch und Japanisch.</strong></p>
<p>Standardm&auml;&szlig;ig ist kein XIM-Server installiert. Installieren Sie zum Eingeben von Doppelbytezeichen in eine Java-Anwendung ein X-Server-Paket, wie z.&nbsp;B. 'iiimf-x' oder 'kinput2'.</p></p>
<p>
<a name="wq172"></a>
<h2 id="wq172">RHEL4 und IIIMF</h2>
<p><strong>Nur f&uuml;r Benutzer der Version von RHEL4 in Chinesisch, Koreanisch und Japanisch.</strong></p>
<p>Wenn Sie IIIMF (Internet/Intranet Input Method Framework) verwenden, verwenden Sie IIIMF-Pakete, die in Red Hat Enterprise
Linux 4 Update 2 oder h&ouml;her enthalten sind. Wenden Sie sich an Red Hat unter <a href="http://www.redhat.com" target="_blank">http://www.redhat.com</a>, um Hilfe zu erhalten.</p>
<p><strong>(Nur zSeries 64 Bit)</strong> Es k&ouml;nnen IIIMF-Fehler oder Startfehler auftreten. F&uuml;hren Sie zur Behebung des Problems ein Upgrade auf die neuesten IIIMF-Pakete durch.</p>
<p><strong>(Nur traditionelles Chinesisch
auf PPC, s390 oder s390x)</strong> IIIMF funktioniert m&ouml;glicherweise nicht. Verwenden Sie zur Behebung des Problems
iiimf-le-xcin-0.1.7-13.EL4 oder neuer.</p>
<p><strong>(Nur vereinfachtes Chinesisch
auf PPC, s390 oder s390x)</strong> IIIMF funktioniert m&ouml;glicherweise nicht ordnungsgem&auml;&szlig;. Verwenden Sie zur Behebung des Problems
die in RHEL4 Update 5 oder neuer enthaltenen Pakete.</p></p>
<p>
<a name="wq173"></a>
<h2 id="wq173">RHEL4 und die L&auml;ndereinstellung 'zh_CN.GB18030'</h2>
<p><strong>Nur f&uuml;r Benutzer der Version von RHEL4 in vereinfachtem Chinesisch.</strong></p>
<p>Die L&auml;ndereinstellung 'zh_CN.GB18030' wird von 'xlib' in RHEL4 nicht unterst&uuml;tzt. xterm kann den Input Method Server nicht f&uuml;r die Eingabe von GB18030-Zeichen aktivieren. Verwenden Sie stattdessen die L&auml;ndereinstellung 'zh_CN.UTF8'.
Wenn Sie &uuml;ber traditionelle Programme oder Daten verf&uuml;gen, die mit GB2312, GBK oder GB18030 verschl&uuml;sselt sind, und Sie diese auf RHEL4 migrieren wollen, m&uuml;ssen Sie sie mit iconv vorverarbeiten, um sie in UTF-8 zu konvertieren. Dadurch k&ouml;nnen die Programme ausgef&uuml;hrt und die Daten ordnungsgem&auml;&szlig; in RHEL4 mit der L&auml;ndereinstellung 'zh_CN.UTF8' angezeigt werden.</p>
<p>Diese Einschr&auml;nkung wird in RHEL4 U3 behoben.</p></p>
<p>
<a name="wq174"></a>
<h2 id="wq174">RHEL4 und 'xcin'</h2>
<p>Bei xcin unter RHEL4 treten m&ouml;glicherweise Blockierungen auf. Setzen Sie zur Behebung des Problems <strong>ICCHECK_DISABLE</strong> in der Datei
/etc/chinese/xcin/xcinrc auf 'YES'.</p>
<p><strong>Nur 64-Bit-Umgebungen</strong></p>
<p>Unter RHEL4 4 mit 'xcin' (XIM-Server f&uuml;r traditionelles Chinesisch) kann mit Java in 64-Bit-Umgebungen z.&nbsp;B. AMD64- oder zSeries-64-Bit-Plattformen) ein nicht erwartetes Verhalten (z.&nbsp;B. ein Segmentierungsfehler) auftreten. F&uuml;hren Sie zur Behebung des Problems ein Upgrade auf das neueste xcin-Paket durch.</p></p>
<p>
<a name="wq175"></a>
<h2 id="wq175">Probleme mit der Fokus&auml;nderung bei RHEL4 und IIIMF</h2>
<p><strong>Nur RHEL4.</strong></p>
<p>Bei der Verwendung von IIIMF (Internet Intranet Input Method Framework) f&uuml;r die Eingabe von Doppelbytezeichen kommen m&ouml;glicherweise Probleme mit der Fokus&auml;nderung vor. Das Problem tritt auf, wenn aktive Eingabekomponenten minimiert werden.
Nach dem Wiederherstellen der Komponente wechselt die Eingabemethode zur&uuml;ck zu SBCS (SBCS - Single Byte Character Set, Einzelbytezeichensatz).
DBCS (DBCS - Double Byte Character Set, Doppelbytezeichensatz) muss dann manuell reaktiviert werden.</p>
<p>Bei den folgenden Komponenten tritt dieses Problem mit der Fokus&auml;nderung auf: 
</p>
<ul>
<li>java.awt.Canvas</li>
<li>java.awt.Button</li>
<li>javax.swing.JButton</li>
<li>javax.swing.JSplitPane</li>
<li>javax.swing.JComboBox</li>
<li>javax.swing.JList</li></ul></p>
<p>
<a name="wq176"></a>
<h2 id="wq176">XIM und das Java Plug-in</h2>
<p><strong>RHEL4 und SLES9</strong></p>
<p>Benutzer der japanischen, chinesischen und koreanischen Version k&ouml;nnen XIM nicht f&uuml;r die Eingabe ihrer eigenen Zeichen in Textkomponenten in einem Java-Applet in einem Web-Browser verwenden. Diese Einschr&auml;nkung tritt auf, da XEmbed eine Programmkorrektur f&uuml;r die X11-Bibliotheksdatei erfordert.  Wenn Sie diese Situation umgehen wollen, geben Sie den Systemparameter <strong>-Dsun.awt.noxembed=true</strong> an, um XEmbed zu inaktivieren. Sie k&ouml;nnen diese Option mit Hilfe der Systemsteuerung definieren: 
</p>
<ol type="1">
<li>&Ouml;ffnen Sie die Systemsteuerung des Java Plug-ins, und wechseln Sie in die Indexzunge <strong>Java</strong>.</li>
<li>Klicken Sie den Knopf <strong>Anzeigen</strong> in den Java-Applet-Laufzeiteinstellungen an.</li>
<li>Geben Sie <strong>-Dsun.awt.noxembed=true</strong> in den Java-Laufzeitparametern ein, und klicken Sie <strong>OK</strong> an.</li>
<li>Klicken Sie <strong>Apply</strong> an.</li>
<li>Starten Sie einen Browser.</li></ol>
<p>Diese Einschr&auml;nkung wird in RHEL4 U3 und SLES9 SP3 behoben.</p></p>
<p>
<a name="wq178"></a>
<h2 id="wq178">Arabische Zeichen und Matrox-Videokarten</h2>
<p>Nur <strong>Intel-32-Bit-Plattformen</strong></p>
<p>(F&uuml;r Benutzer von arabischem Text) Bei der Verwendung von Linux mit einer Matrox-Videokarte und aktivierter Beschleunigung werden Zeichen verzerrt angezeigt, wenn zum Anzeigen gro&szlig;er Schriftarten drawString verwendet wird. Dieser Fehler wird durch den Treiber dieser Karten verursacht. Die empfohlene Fehlerumgehung besteht darin, die Beschleunigung f&uuml;r diese Einheit zu inaktivieren.</p></p>
<p>
<a name="wq179"></a>
<h2 id="wq179">Verwendung der NPTL unter SLES9 und der Parallelanschlusstreiber</h2>
<p>Nur <strong>Intel-32-Bit-Plattformen</strong></p>
<p>Bei Verwendung der NPTL unter SLES 9 verursacht der Parallelanschlusstreiber einen Kernelabsturz und stoppt einen Java-Thread. JVM stellt diesen Absturz fest, wenn sie versucht, den Thread f&uuml;r die Garbage-Collection zur&uuml;ckzustellen, und st&uuml;rzt dann ab. Dabei wird eine Kerndatei erstellt und die Nachricht &quot;JVMLH030: threads are disappearing when trying to suspend all threads&quot; angezeigt.</p>
<p>Dieser Fehler wird im SUSE Bugzilla Report 47947 beschrieben. Er wurde unter SLES 9 Service-Pack 1 behoben.</p></p>
<p>
<a name="wq180"></a>
<h2 id="wq180">JNI-Aufrufe mit mindestens acht Parametern auf PPC-Plattformen</h2>
<p><strong>Nur PPC-Plattformen</strong></p>
<p>Wenn der Java-Code JNI-Aufrufe verwendet, und ein bestimmter Aufruf mehr als acht FLOAT- oder DOUBLE-Parameter aufweist, muss der C-Code mit der FSF-Stufe (Free Software Foundation) 'gcc-2.95.3' des GNU-C-Compilers (GCC) kompiliert werden.</p></p>
<p>
<a name="wq181"></a>
<h2 id="wq181">Parallelanschlussoperationen unter
SLES9 vor SP2</h2>
<p><strong>Nur PPC-Plattformen</strong></p>
<p>Das JavaComm-Paket kann unter der GA-Version von SLES 9 und auf SP1-Kerneln keine Parallelanschlussoperationen unterst&uuml;tzen. Diese Einschr&auml;nkung wird im SP2-Kernel behoben. Die SUSE Bugzilla-Nummer ist 50028.</p></p>
<p>
<a name="wq182"></a>
<h2 id="wq182">Kompilieren von 'libFileStat.so' auf PPC-64-Bit-Plattformen</h2>
<p><strong>Nur PPC-64-Bit-Plattformen</strong></p>
<p>Der system&uuml;bergreifende gcc-Standardcompiler (Version 3.2-49) verursacht verschiedene Fehler. F&uuml;hren Sie zum
Erstellen der gemeinsam genutzten Bibliothek libFileStat.so Folgendes aus:</p></p>
<pre class="xmp">/opt/cross/bin/powerpc64-linux-gcc -shared -o libFileStat.so -I<em>&lt;SDK_PATH&gt;</em>/include FileStat.c</pre>
<p> Dabei gilt Folgendes: <em>&lt;SDK_PATH&gt;</em> ist der Pfad zum installierten SDK-Verzeichnis.</p>
<p>
<a name="wq183"></a>
<h2 id="wq183">IP Version 6 auf zSeries-Plattformen</h2>
<p><strong>Nur zSeries-Plattformen</strong></p>
<p>Obwohl der Linux-Kernel in den aktuellen Verteilungen Unterst&uuml;tzung f&uuml;r Internet Protocol Version 6 (IPv6) bietet, treten bei der Verwendung m&ouml;glicherweise Probleme auf. In diesem Release ist die Unterst&uuml;tzung f&uuml;r IP Version 6 durch Java enthalten.
Es wird allerdings empfohlen, dass Sie diese Unterst&uuml;tzung mit der
Option <strong>-Djava.net.preferIPv4Stack=true</strong> des
Befehls java inaktivieren. Wenn Sie einen Kernel installieren, der IPv6 vollst&auml;ndig unterst&uuml;tzt, ben&ouml;tigen Sie diese Option nicht.</p></p>
<p>
<a name="wq184"></a>
<h2 id="wq184">'xcin' auf 64-Bit-zSeries-Plattformen</h2>
<p><strong>Nur zSeries-64-Bit-Plattformen</strong></p>
<p>Der chinesische und taiwanesische Input Method Server ('xcin') wurde nicht getestet.</p></p>
<p>
<a name="wq185"></a>
<h2 id="wq185">Java Desktop API</h2>
<p>Die Java Desktop API funktioniert m&ouml;glicherweise nicht, weil mindestens eine GNOME-Bibliothek nicht verf&uuml;gbar ist.</p></p>
<p>
<a name="wq186"></a>
<h2 id="wq186">NullPointerException bei GTK-Darstellung und -Funktionsweise</h2>
<p><strong>Nur DBCS-Umgebungen</strong></p>
<p>Wenn bei Ihrer Anwendung bei Verwendung der GTK-Darstellung und -Funktionsweise der Fehler NullPointerException auftritt, inaktivieren Sie die Umgebungsvariable <strong>GNOME_DESKTOP_SESSION_ID</strong>.</p></p>
<p>
<a name="wq187"></a>
<h2 id="wq187">Aliasname der Codepage in Unicode f&uuml;r 'Shift_JIS'</h2>
<p><strong>Nur f&uuml;r Benutzer der japanischen
Version</strong></p>
<p>Der Aliasname der Codepage in Unicode &quot;\u30b7\u30d5\u30c8\u7b26\u53f7\u5316\u8868\u73fe&quot; f&uuml;r
Shift_JIS wurde entfernt. Wenn Sie diese Codepage in Ihren Anwendungen verwenden, ersetzen Sie sie durch 'Shift_JIS'.</p></p>
<a name="notices"></a>
<h1 id="notices"><a href="#ToC_170">Bemerkungen</a></h1>
<div>
<p>Die vorliegenden Informationen wurden f&uuml;r Produkte und Services
entwickelt, die auf dem deutschen Markt angeboten werden. M&ouml;glicherweise bietet IBM
die in dieser Dokumentation beschriebenen Produkte,
Services oder Funktionen in anderen L&auml;ndern nicht an. Informationen
&uuml;ber die gegenw&auml;rtig im jeweiligen Land verf&uuml;gbaren Produkte und Services sind beim zust&auml;ndigen
IBM Ansprechpartner
erh&auml;ltlich.</p></div>
<p>Hinweise auf IBM
Lizenzprogramme oder andere IBM Produkte bedeuten nicht, dass
nur Programme, Produkte oder Services von IBM
verwendet werden k&ouml;nnen. An Stelle der IBM Produkte, Programme oder
Services k&ouml;nnen auch andere, ihnen
&auml;quivalente Produkte, Programme oder Services verwendet werden, solange
diese keine gewerblichen oder andere Schutzrechte der IBM verletzen. Die Verantwortung f&uuml;r den Betrieb von Fremdprodukten,
Fremdprogrammen und Fremdservices liegt beim Kunden.</p>
<p>F&uuml;r in diesem Handbuch beschriebene Erzeugnisse und Verfahren
kann es IBM Patente oder Patentanmeldungen geben. Mit der Auslieferung
dieses Handbuchs ist keine Lizenzierung dieser Patente
verbunden. Lizenzanforderungen sind schriftlich an folgende Adresse zu richten
(Anfragen an diese Adresse m&uuml;ssen auf Englisch formuliert werden):</p>
<ul class="simple">
<li>IBM Director
of Licensing</li>
<li>IBM Europe, Middle East &amp; Africa</li>
<li>Tour Descartes</li>
<li>2, avenue Gambetta</li>
<li>92066 Paris La Defense Cedex</li>
<li>France</li></ul>
<p>Trotz sorgf&auml;ltiger Bearbeitung k&ouml;nnen technische
Ungenauigkeiten oder Druckfehler in dieser Ver&ouml;ffentlichung
nicht ausgeschlossen werden. Die Angaben in diesem Handbuch werden in regelm&auml;&szlig;igen
Zeitabst&auml;nden aktualisiert. Die &Auml;nderungen werden in
&Uuml;berarbeitungen oder in Technical News Letters (TNLs) bekannt
gegeben. IBM kann ohne weitere Mitteilung jederzeit Verbesserungen und/oder
&Auml;nderungen an den in dieser Ver&ouml;ffentlichung beschriebenen Produkten
und/oder Programmen vornehmen.</p>
<p>Verweise in diesen Informationen auf Websites anderer
Anbieter werden lediglich als Service f&uuml;r den Kunden bereitgestellt und
stellen keinerlei Billigung des Inhalts dieser Websites dar. Das
&uuml;ber diese Websites verf&uuml;gbare Material ist nicht Bestandteil
des Materials f&uuml;r dieses IBM Produkt. Die Verwendung dieser
Websites geschieht auf eigene Verantwortung.</p>
<p>Werden an IBM Informationen eingesandt, k&ouml;nnen diese beliebig
verwendet werden, ohne dass eine Verpflichtung gegen&uuml;ber dem
Einsender entsteht.</p>
<p>Lizenznehmer des Programms, die Informationen zu diesem Produkt
w&uuml;nschen mit der Zielsetzung: (i) den Austausch von Informationen zwischen
unabh&auml;ngigen, erstellten Programmen und anderen Programmen (einschlie&szlig;lich
des vorliegenden Programms) sowie (ii) die gemeinsame Nutzung der
ausgetauschten Informationen zu erm&ouml;glichen, wenden sich an folgende
Adresse:</p>
<ul class="simple">
<li>JIMMAIL@uk.ibm.com</li>
<li>[Ansprechpartner im Hursley Java Technology Center (JTC)]</li></ul>
<p>Die Bereitstellung dieser Informationen kann unter Umst&auml;nden von bestimmten
Bedingungen - in einigen F&auml;llen auch von der Zahlung einer Geb&uuml;hr - abh&auml;ngig sein.</p>
<p>Die Lieferung des im Dokument aufgef&uuml;hrten Lizenzprogramms sowie des zugeh&ouml;rigen Lizenzmaterials erfolgt
auf der Basis der IBM Rahmenvereinbarung bzw. der Allgemeinen Gesch&auml;ftsbedingungen von IBM, der
IBM Internationalen Nutzungsbedingungen f&uuml;r Programmpakete oder einer &auml;quivalenten Vereinbarung.</p>
<p>Alle in diesem Dokument enthaltenen Leistungsdaten stammen aus einer kontrollierten Umgebung.
Die Ergebnisse, die in anderen Betriebsumgebungen erzielt werden, k&ouml;nnen daher erheblich von den hier erzielten Ergebnissen abweichen.
Einige Daten stammen m&ouml;glicherweise von Systemen, deren Entwicklung noch nicht abgeschlossen ist. Eine Gew&auml;hrleistung, dass diese Daten auch in allgemein verf&uuml;gbaren Systemen erzielt werden, kann nicht gegeben werden. Dar&uuml;ber hinaus wurden einige Daten unter Umst&auml;nden durch
Extrapolation berechnet.
Die tats&auml;chlichen Ergebnisse k&ouml;nnen davon abweichen. Benutzer dieses Dokuments sollten die entsprechenden Daten in ihrer spezifischen Umgebung pr&uuml;fen.</p>
<p>Informationen &uuml;ber Produkte anderer Anbieter wurden von den jeweiligen
Anbietern zur Verf&uuml;gung gestellt bzw. aus von ihnen
ver&ouml;ffentlichten Ank&uuml;ndigungen oder anderen &ouml;ffentlich zug&auml;nglichen
Quellen entnommen. IBM hat diese Produkte nicht getestet
und kann daher keine Aussagen zu Leistung,
Kompatibilit&auml;t oder anderen Merkmalen machen. Fragen zu den
Leistungsmerkmalen von Produkten anderer Anbieter sind an den jeweiligen
Anbieter zu richten.</p>
<a name="trademarks"></a>
<h2 id="trademarks"><a href="#ToC_171">Marken</a></h2>
<p>IBM, iSeries, pSeries und zSeries sind Marken oder eingetragene Marken der International
Business Machines Corporation in den USA und/oder anderen L&auml;ndern.</p>
<p>Intel ist eine Marke der Intel Corporation in den USA und/oder anderen L&auml;ndern.</p>
<p>Java und alle auf Java basierenden Marken und Logos sind Marken von Sun Microsystems, Inc. in den USA und/oder anderen L&auml;ndern.</p>
<p>Linux ist eine Marke von Linus Torvalds in den USA und/oder anderen L&auml;ndern.</p>
<p>Andere Namen von Unternehmen, Produkten oder Dienstleistungen k&ouml;nnen Marken oder Dienstleistungsmarken anderer
Unternehmen sein.</p>
<a id="Bot_Of_Page" name="Bot_Of_Page"></a>
</body>
</html>
